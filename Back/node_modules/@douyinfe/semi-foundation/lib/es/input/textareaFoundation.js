import _isString from "lodash/isString";
import _isNumber from "lodash/isNumber";
import _isFunction from "lodash/isFunction";
import _noop from "lodash/noop";
import BaseFoundation from '../base/foundation';
import calculateNodeHeight from './util/calculateNodeHeight';
import getSizingData from './util/getSizingData';
import truncateValue from './util/truncateValue';
export default class TextAreaFoundation extends BaseFoundation {
  static get textAreaDefaultAdapter() {
    return {
      notifyChange: _noop,
      setValue: _noop,
      toggleFocusing: _noop,
      toggleHovering: _noop,
      notifyFocus: _noop,
      notifyBlur: _noop,
      notifyKeyDown: _noop,
      notifyEnterPress: _noop
    };
  }
  constructor(adapter) {
    super(Object.assign(Object.assign({}, TextAreaFoundation.textAreaDefaultAdapter), adapter));
    this.resizeTextarea = () => {
      var _a;
      const {
        height
      } = this.getStates();
      const {
        rows,
        autosize
      } = this.getProps();
      const node = this._adapter.getRef();
      const nodeSizingData = getSizingData(node);
      if (!nodeSizingData) {
        return;
      }
      const [minRows, maxRows] = autosize !== null && typeof autosize === 'object' ? [(_a = autosize === null || autosize === void 0 ? void 0 : autosize.minRows) !== null && _a !== void 0 ? _a : rows, autosize === null || autosize === void 0 ? void 0 : autosize.maxRows] : [rows];
      const newHeight = calculateNodeHeight(nodeSizingData, node.value || node.placeholder || 'x', minRows, maxRows);
      if (height !== newHeight) {
        this._adapter.notifyHeightUpdate(newHeight);
        node.style.height = `${newHeight}px`;
        return;
      }
    };
  }
  destroy() {}
  handleValueChange(v) {
    this._adapter.setValue(v);
  }
  handleChange(value, e) {
    const {
      maxLength,
      minLength,
      getValueLength
    } = this._adapter.getProps();
    let nextValue = value;
    if (maxLength && _isFunction(getValueLength)) {
      nextValue = this.handleVisibleMaxLength(value);
    }
    if (minLength && _isFunction(getValueLength)) {
      this.handleVisibleMinLength(nextValue);
    }
    if (this._isControlledComponent()) {
      this._adapter.notifyChange(nextValue, e);
    } else {
      this._adapter.setValue(nextValue);
      this._adapter.notifyChange(nextValue, e);
    }
  }
  /**
   * Modify minLength to trigger browser check for minimum length
   * Controlled mode is not checked
   * @param {String} value
   */
  handleVisibleMinLength(value) {
    const {
      minLength,
      getValueLength
    } = this._adapter.getProps();
    const {
      minLength: stateMinLength
    } = this._adapter.getStates();
    if (_isNumber(minLength) && minLength >= 0 && _isFunction(getValueLength) && _isString(value)) {
      const valueLength = getValueLength(value);
      if (valueLength < minLength) {
        const newMinLength = value.length + (minLength - valueLength);
        newMinLength !== stateMinLength && this._adapter.setMinLength(newMinLength);
      } else {
        stateMinLength !== minLength && this._adapter.setMinLength(minLength);
      }
    }
  }
  /**
   * Handle input emoji characters beyond maxLength
   * Controlled mode is not checked
   * @param {String} value
   */
  handleVisibleMaxLength(value) {
    const {
      maxLength,
      getValueLength
    } = this._adapter.getProps();
    if (_isNumber(maxLength) && maxLength >= 0 && _isString(value)) {
      if (_isFunction(getValueLength)) {
        const valueLength = getValueLength(value);
        if (valueLength > maxLength) {
          console.warn('[Semi TextArea] The input character is truncated because the input length exceeds the maximum length limit');
          const truncatedValue = this.handleTruncateValue(value, maxLength);
          return truncatedValue;
        }
      } else {
        if (value.length > maxLength) {
          console.warn('[Semi TextArea] The input character is truncated because the input length exceeds the maximum length limit');
          return value.slice(0, maxLength);
        }
      }
      return value;
    }
    return undefined;
  }
  /**
   * Truncate textarea values based on maximum length
   * @param {String} value
   * @param {Number} maxLength
   * @returns {String}
   */
  handleTruncateValue(value, maxLength) {
    const {
      getValueLength
    } = this._adapter.getProps();
    return truncateValue({
      value,
      maxLength,
      getValueLength
    });
  }
  handleFocus(e) {
    const {
      value
    } = this.getStates();
    this._adapter.toggleFocusing(true);
    this._adapter.notifyFocus(value, e);
  }
  handleBlur(e) {
    const {
      value
    } = this.getStates();
    const {
      maxLength
    } = this.getProps();
    let realValue = value;
    if (maxLength) {
      // 如果设置了 maxLength，在中文输输入过程中，如果点击外部触发 blur，则拼音字符的所有内容会回显，
      // 该表现不符合 maxLength 规定，因此需要在 blur 的时候二次确认
      // 详情见 https://github.com/DouyinFE/semi-design/issues/2005
      // If maxLength is set, during the Chinese input process, if you click outside to trigger blur, 
      // all the contents of the Pinyin characters will be echoed.
      // This behavior does not meet the maxLength requirement, so we need to confirm twice when blurring。
      // For details, see https://github.com/DouyinFE/semi-design/issues/2005
      realValue = this.handleVisibleMaxLength(value);
      if (realValue !== value) {
        if (!this._isControlledComponent()) {
          this._adapter.setValue(realValue);
        }
        this._adapter.notifyChange(realValue, e);
      }
    }
    this._adapter.toggleFocusing(false);
    this._adapter.notifyBlur(realValue, e);
  }
  handleKeyDown(e) {
    const {
      disabledEnterStartNewLine
    } = this.getProps();
    if (disabledEnterStartNewLine && e.key === 'Enter' && !e.shiftKey) {
      // Prevent default line wrapping behavior
      e.preventDefault();
    }
    this._adapter.notifyKeyDown(e);
    if (e.keyCode === 13) {
      this._adapter.notifyPressEnter(e);
    }
  }
  // e: MouseEvent
  handleMouseEnter(e) {
    this._adapter.toggleHovering(true);
  }
  // e: MouseEvent
  handleMouseLeave(e) {
    this._adapter.toggleHovering(false);
  }
  isAllowClear() {
    const {
      value,
      isFocus,
      isHover
    } = this._adapter.getStates();
    const {
      showClear,
      disabled,
      readonly
    } = this._adapter.getProps();
    const allowClear = value && showClear && !disabled && (isFocus || isHover) && !readonly;
    return allowClear;
  }
  handleClear(e) {
    const {
      isFocus
    } = this.getStates();
    if (this._isControlledComponent('value')) {
      this._adapter.setState({
        isFocus: false
      });
    } else {
      this._adapter.setState({
        value: '',
        isFocus: false
      });
    }
    if (isFocus) {
      this._adapter.notifyBlur('', e);
    }
    this._adapter.notifyChange('', e);
    this._adapter.notifyClear(e);
    this.stopPropagation(e);
  }
}