"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _foundation = _interopRequireDefault(require("../base/foundation"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
class PreviewImageFoundation extends _foundation.default {
  constructor(adapter) {
    var _this;
    super(Object.assign({}, adapter));
    _this = this;
    this.startMouseClientPosition = {
      x: 0,
      y: 0
    };
    this.originImageWidth = null;
    this.originImageHeight = null;
    this.containerWidth = 0;
    this.containerHeight = 0;
    this._isImageVertical = () => this.getProp("rotation") % 180 !== 0;
    this._getContainerBoundingRectSize = () => {
      const containerDOM = this._adapter.getContainer();
      if (containerDOM) {
        this.containerWidth = containerDOM.clientWidth;
        this.containerHeight = containerDOM.clientHeight;
      }
    };
    this._getAdaptationZoom = () => {
      let _zoom = 1;
      const containerDOM = this._adapter.getContainer();
      if (containerDOM && this.originImageWidth && this.originImageHeight) {
        const {
          rotation
        } = this.getProps();
        const {
          width: imageWidth,
          height: imageHeight
        } = this.calcBoundingRectSize(this.originImageWidth, this.originImageHeight, rotation);
        const reservedWidth = this.containerWidth - 80;
        const reservedHeight = this.containerHeight - 80;
        _zoom = Number(Math.min(reservedWidth / imageWidth, reservedHeight / imageHeight).toFixed(2));
      }
      return _zoom;
    };
    this._getInitialZoom = () => {
      const {
        ratio
      } = this.getProps();
      let _zoom = 1;
      if (ratio === 'adaptation') {
        _zoom = this._getAdaptationZoom();
      }
      return _zoom;
    };
    this.setLoading = loading => {
      this._adapter.setLoading(loading);
    };
    this.handleWindowResize = () => {
      this._getContainerBoundingRectSize();
      this.initializeImage();
    };
    this.handleLoad = e => {
      if (e.target) {
        const {
          naturalWidth: w,
          naturalHeight: h
        } = e.target;
        this.originImageHeight = h;
        this.originImageWidth = w;
        this.setState({
          loading: false
        });
        // 图片初次加载，计算 zoom，zoom 改变不需要通过回调透出
        // When the image is loaded for the first time, zoom is calculated, and zoom changes do not need to be exposed through callbacks.
        this.initializeImage(false);
      }
      const {
        src,
        onLoad
      } = this.getProps();
      onLoad && onLoad(src);
    };
    this.handleError = e => {
      const {
        onError,
        src
      } = this.getProps();
      this.setState({
        loading: false
      });
      onError && onError(src);
    };
    this.handleRatioChange = () => {
      this.initializeImage();
    };
    this.initializeImageZoom = function () {
      let notify = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      const {
        currZoom
      } = _this.getStates();
      const {
        onZoom
      } = _this.getProps();
      const _zoom = _this._getInitialZoom();
      if (currZoom !== _zoom) {
        onZoom(_zoom, notify);
      } else {
        _this.changeZoom(_zoom);
      }
    };
    this.initializeTranslate = () => {
      this.setState({
        translate: {
          x: 0,
          y: 0
        }
      });
    };
    this.initializeImage = function () {
      let notify = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      _this.initializeImageZoom(notify);
      _this.initializeTranslate();
    };
    this.handleRightClickImage = e => {
      const {
        disableDownload
      } = this.getProps();
      if (disableDownload) {
        e.preventDefault();
        e.stopPropagation();
        return false;
      } else {
        return true;
      }
    };
    this.getCanDragDirection = (width, height) => {
      let canDragHorizontal = width > this.containerWidth;
      let canDragVertical = height > this.containerHeight;
      return {
        canDragVertical,
        canDragHorizontal
      };
    };
    this.changeZoom = (newZoom, e) => {
      const imageDOM = this._adapter.getImage();
      const {
        currZoom,
        translate,
        width,
        height
      } = this.getStates();
      const {
        rotation
      } = this.getProps();
      const changeScale = newZoom / (currZoom || 1);
      const newWidth = Math.floor(this.originImageWidth * newZoom);
      const newHeight = Math.floor(this.originImageHeight * newZoom);
      let newTranslateX = Math.floor(translate.x * changeScale);
      let newTranslateY = Math.floor(translate.y * changeScale);
      const imageBound = this.calcBoundingRectSize(width, height, rotation);
      const newImageBound = {
        width: imageBound.width * changeScale,
        height: imageBound.height * changeScale
      };
      if (e && imageDOM && e.target === imageDOM) {
        let angle = rotation % 360;
        angle < 0 && (angle = 360 + angle);
        switch (angle) {
          case 0:
            newTranslateX = (e.offsetX - 0.5 * width) * (1 - newZoom / currZoom) + translate.x;
            newTranslateY = (e.offsetY - 0.5 * height) * (1 - newZoom / currZoom) + translate.y;
            break;
          case 90:
            newTranslateX = (0.5 * height - e.offsetY) * (1 - newZoom / currZoom) + translate.x;
            newTranslateY = (e.offsetX - 0.5 * width) * (1 - newZoom / currZoom) + translate.y;
            break;
          case 180:
            newTranslateX = (0.5 * width - e.offsetX) * (1 - newZoom / currZoom) + translate.x;
            newTranslateY = (0.5 * height - e.offsetY) * (1 - newZoom / currZoom) + translate.y;
            break;
          case 270:
            newTranslateX = (e.offsetY - 0.5 * height) * (1 - newZoom / currZoom) + translate.x;
            newTranslateY = (0.5 * width - e.offsetX) * (1 - newZoom / currZoom) + translate.y;
            break;
          default:
            break;
        }
      }
      const newTranslate = this.getSafeTranslate(newImageBound.width, newImageBound.height, newTranslateX, newTranslateY);
      this.setState({
        translate: newTranslate,
        width: newWidth,
        height: newHeight,
        currZoom: newZoom
      });
      if (imageDOM) {
        const {
          canDragVertical,
          canDragHorizontal
        } = this.getCanDragDirection(newImageBound.width, newImageBound.height);
        const canDrag = canDragVertical || canDragHorizontal;
        this._adapter.setImageCursor(canDrag);
      }
    };
    this.getExtremeTranslate = (width, height) => {
      return {
        x: (width - this.containerWidth) / 2,
        y: (height - this.containerHeight) / 2
      };
    };
    this.getSafeTranslate = (width, height, translateX, translateY) => {
      const {
        x: extremeX,
        y: extremeY
      } = this.getExtremeTranslate(width, height);
      const {
        canDragVertical,
        canDragHorizontal
      } = this.getCanDragDirection(width, height);
      let newTranslateX = 0,
        newTranslateY = 0;
      if (canDragHorizontal) {
        newTranslateX = translateX > 0 ? Math.min(translateX, extremeX) : Math.max(translateX, -extremeX);
      }
      if (canDragVertical) {
        newTranslateY = translateY > 0 ? Math.min(translateY, extremeY) : Math.max(translateY, -extremeY);
      }
      return {
        x: newTranslateX,
        y: newTranslateY
      };
    };
    this.handleImageMove = e => {
      // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons
      const mouseLeftPress = e.buttons === 1;
      if (mouseLeftPress) {
        this.moveImage(e);
      }
    };
    this.moveImage = e => {
      const {
        clientX,
        clientY
      } = e;
      const {
        width,
        height,
        translate
      } = this.getStates();
      const {
        rotation
      } = this.getProps();
      const imageBound = this.calcBoundingRectSize(width, height, rotation);
      const {
        canDragVertical,
        canDragHorizontal
      } = this.getCanDragDirection(imageBound.width, imageBound.height);
      if (canDragVertical || canDragHorizontal) {
        let newTranslateX = canDragHorizontal ? translate.x + clientX - this.startMouseClientPosition.x : translate.x;
        let newTranslateY = canDragVertical ? translate.y + clientY - this.startMouseClientPosition.y : translate.y;
        const newTranslate = this.getSafeTranslate(imageBound.width, imageBound.height, newTranslateX, newTranslateY);
        this.setState({
          translate: newTranslate
        });
        this.startMouseClientPosition = {
          x: clientX,
          y: clientY
        };
      }
    };
    this.handleImageMouseDown = e => {
      this.startMouseClientPosition = {
        x: e.clientX,
        y: e.clientY
      };
    };
    // 鼠标事件的 e.offset 是以 dom 旋转前左上角为零点的, 这个方法会转换为以旋转后元素的外接矩形左上角为零点的 offset
    this.calcBoundingRectMouseOffset = calcBoundingRectMouseOffset => {
      const {
        width,
        height,
        offset,
        rotation = 0
      } = calcBoundingRectMouseOffset;
      let degrees = rotation % 360;
      degrees = degrees >= 0 ? degrees : 360 + degrees;
      let boundOffsetX = 0,
        boundOffsetY = 0;
      switch (degrees) {
        case 0:
          boundOffsetX = offset.x;
          boundOffsetY = offset.y;
          break;
        case 90:
          boundOffsetX = height - offset.y;
          boundOffsetY = offset.x;
          break;
        case 180:
          boundOffsetX = width - offset.x;
          boundOffsetY = height - offset.y;
          break;
        case 270:
          boundOffsetX = offset.y;
          boundOffsetY = width - offset.x;
          break;
        default:
          break;
      }
      return {
        x: boundOffsetX,
        y: boundOffsetY
      };
    };
  }
  init() {
    this._getContainerBoundingRectSize();
  }
  calcBoundingRectSize() {
    let width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let rotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    const angleInRadians = rotation * Math.PI / 180;
    const sinTheta = Math.abs(Math.sin(angleInRadians));
    const cosTheta = Math.abs(Math.cos(angleInRadians));
    const boundingWidth = width * cosTheta + height * sinTheta;
    const boundingHeight = width * sinTheta + height * cosTheta;
    return {
      width: boundingWidth,
      height: boundingHeight
    };
  }
}
exports.default = PreviewImageFoundation;