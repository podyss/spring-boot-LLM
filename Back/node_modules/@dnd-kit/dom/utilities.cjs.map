{"version":3,"sources":["src/utilities/bounding-rectangle/getBoundingRectangle.ts","src/utilities/execution-context/canUseDOM.ts","src/utilities/type-guards/isWindow.ts","src/utilities/type-guards/isNode.ts","src/utilities/execution-context/getWindow.ts","src/utilities/type-guards/isDocument.ts","src/utilities/type-guards/isHTMLElement.ts","src/utilities/execution-context/getDocument.ts","src/utilities/bounding-rectangle/getViewportBoundingRectangle.ts","src/utilities/bounding-rectangle/PositionObserver.ts","src/utilities/scheduling/timeout.ts","src/utilities/scheduling/throttle.ts","src/utilities/bounding-rectangle/isRectEqual.ts","src/utilities/bounding-rectangle/isOverflowVisible.ts","src/utilities/bounding-rectangle/getVisibleBoundingRectangle.ts","src/utilities/bounding-rectangle/isVisible.ts","src/utilities/execution-context/isSafari.ts","src/utilities/element/cloneElement.ts","src/utilities/element/proxiedElements.ts","src/utilities/event-listeners/Listeners.ts","src/utilities/popover/supportsPopover.ts","src/utilities/popover/showPopover.ts","src/utilities/scroll/documentScrollingElement.ts","src/utilities/scroll/getScrollPosition.ts","src/utilities/scroll/canScroll.ts","src/utilities/type-guards/isSVGElement.ts","src/utilities/styles/getComputedStyles.ts","src/utilities/scroll/isFixed.ts","src/utilities/scroll/isScrollable.ts","src/utilities/scroll/getScrollableAncestors.ts","src/utilities/scroll/detectScrollIntent.ts","src/utilities/scroll/scrollIntoViewIfNeeded.ts","src/utilities/scheduling/scheduler.ts","src/utilities/shapes/DOMRectangle.ts","src/utilities/transform/inverseTransform.ts","src/utilities/type-guards/supportsStyle.ts","src/utilities/styles/Styles.ts","src/utilities/transform/animateTransform.ts","src/utilities/transform/parseTranslate.ts","src/utilities/transform/computeTranslate.ts","src/utilities/transform/parseScale.ts","src/utilities/transform/parseTransform.ts","src/utilities/type-guards/isElement.ts","src/utilities/type-guards/isKeyboardEvent.ts","src/utilities/type-guards/isPointerEvent.ts","src/utilities/type-guards/supportsViewTransition.ts","src/utilities/misc/generateUniqueId.ts"],"names":["window","target","ScrollDirection","threshold","Rectangle","keyframe","translate","document"],"mappings":"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","sourcesContent":["import {BoundingRectangle} from '@dnd-kit/geometry';\n\nexport function getBoundingRectangle(element: Element): BoundingRectangle {\n  const {width, height, top, left, bottom, right} =\n    element.getBoundingClientRect();\n\n  return {width, height, top, left, bottom, right};\n}\n","// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\nexport const canUseDOM =\n  typeof window !== 'undefined' &&\n  typeof window.document !== 'undefined' &&\n  typeof window.document.createElement !== 'undefined';\n","export function isWindow(element: Object): element is typeof window {\n  const elementString = Object.prototype.toString.call(element);\n  return (\n    elementString === '[object Window]' ||\n    // In Electron context the Window object serializes to [object global]\n    elementString === '[object global]'\n  );\n}\n","export function isNode(node: Object): node is Node {\n  return 'nodeType' in node;\n}\n","import {isWindow} from '../type-guards/isWindow.ts';\nimport {isNode} from '../type-guards/isNode.ts';\n\nexport function getWindow(\n  target: Event['target'] | null | undefined\n): typeof window {\n  if (!target) {\n    return window;\n  }\n\n  if (isWindow(target)) {\n    return target;\n  }\n\n  if (!isNode(target)) {\n    return window;\n  }\n\n  return target.ownerDocument?.defaultView ?? window;\n}\n","import {getWindow} from '../execution-context/getWindow.ts';\n\nexport function isDocument(node: Node): node is Document {\n  const {Document} = getWindow(node);\n\n  return node instanceof Document;\n}\n","import {getWindow} from '../execution-context/getWindow.ts';\n\nimport {isWindow} from './isWindow.ts';\n\nexport function isHTMLElement(node: Node | Window | null): node is HTMLElement {\n  if (!node || isWindow(node)) return false;\n\n  return node instanceof getWindow(node).HTMLElement;\n}\n","import {isDocument} from '../type-guards/isDocument.ts';\nimport {isHTMLElement} from '../type-guards/isHTMLElement.ts';\nimport {isNode} from '../type-guards/isNode.ts';\nimport {isWindow} from '../type-guards/isWindow.ts';\n\nexport function getDocument(target: Event['target']): Document {\n  if (!target) {\n    return document;\n  }\n\n  if (isWindow(target)) {\n    return target.document;\n  }\n\n  if (!isNode(target)) {\n    return document;\n  }\n\n  if (isDocument(target)) {\n    return target;\n  }\n\n  if (isHTMLElement(target)) {\n    return target.ownerDocument;\n  }\n\n  return document;\n}\n","import type {BoundingRectangle} from '@dnd-kit/geometry';\n\nimport {getDocument} from '../execution-context/index.ts';\n\n/**\n * Returns the bounding rectangle of the viewport\n * @param element\n * @returns BoundingRectangle\n */\nexport function getViewportBoundingRectangle(\n  element: Element\n): BoundingRectangle {\n  const {documentElement} = getDocument(element);\n  const width = documentElement.clientWidth;\n  const height = documentElement.clientHeight;\n\n  return {\n    top: 0,\n    left: 0,\n    right: width,\n    bottom: height,\n    width,\n    height,\n  };\n}\n","import {BoundingRectangle, Rectangle} from '@dnd-kit/geometry';\n\nimport {throttle} from '../scheduling/throttle.ts';\n\nimport {isRectEqual} from './isRectEqual.ts';\nimport {isVisible} from './isVisible.ts';\nimport {getVisibleBoundingRectangle} from './getVisibleBoundingRectangle.ts';\n\ntype PositionObserverCallback = (\n  boundingClientRect: BoundingRectangle | null\n) => void;\n\nconst threshold = Array.from({length: 100}, (_, index) => index / 100);\nconst THROTTLE_INTERVAL = 75;\n\nexport class PositionObserver {\n  constructor(\n    private element: Element,\n    callback: PositionObserverCallback,\n    options: {debug?: boolean} = {debug: false}\n  ) {\n    this.#callback = callback;\n    this.boundingClientRect = element.getBoundingClientRect();\n    this.#visible = isVisible(element, this.boundingClientRect);\n\n    const root = element.ownerDocument;\n\n    if (options?.debug) {\n      this.#debug = document.createElement('div');\n      this.#debug.style.background = 'rgba(0,0,0,0.15)';\n      this.#debug.style.position = 'fixed';\n      this.#debug.style.pointerEvents = 'none';\n      root.body.appendChild(this.#debug);\n    }\n\n    this.#visibilityObserver = new IntersectionObserver(\n      (entries: IntersectionObserverEntry[]) => {\n        const entry = entries[entries.length - 1];\n        const {boundingClientRect, isIntersecting: visible} = entry;\n        const {width, height} = boundingClientRect;\n        const previousVisible = this.#visible;\n\n        this.#visible = visible;\n\n        if (!width && !height) return;\n\n        if (previousVisible && !visible) {\n          this.#positionObserver?.disconnect();\n          this.#callback(null);\n          this.#resizeObserver?.disconnect();\n          this.#resizeObserver = undefined;\n\n          if (this.#debug) this.#debug.style.visibility = 'hidden';\n        } else {\n          this.#observePosition();\n        }\n\n        if (visible && !this.#resizeObserver) {\n          this.#resizeObserver = new ResizeObserver(this.#observePosition);\n          this.#resizeObserver.observe(element);\n        }\n      },\n      {\n        threshold,\n        root,\n      }\n    );\n\n    if (this.#visible) {\n      this.#callback(this.boundingClientRect);\n    }\n\n    this.#visibilityObserver.observe(element);\n  }\n\n  public boundingClientRect: DOMRectReadOnly;\n\n  public disconnect() {\n    this.#disconnected = true;\n    this.#resizeObserver?.disconnect();\n    this.#positionObserver?.disconnect();\n    this.#visibilityObserver.disconnect();\n    this.#debug?.remove();\n  }\n\n  #callback: PositionObserverCallback;\n  #visible = true;\n  #previousBoundingClientRect: DOMRectReadOnly | undefined;\n  #resizeObserver: ResizeObserver | undefined;\n  #positionObserver: IntersectionObserver | undefined;\n  #visibilityObserver: IntersectionObserver;\n  #debug: HTMLElement | undefined;\n  #disconnected = false;\n\n  #observePosition = throttle(() => {\n    const {element} = this;\n\n    this.#positionObserver?.disconnect();\n\n    if (this.#disconnected || !this.#visible || !element.isConnected) {\n      return;\n    }\n\n    const root = element.ownerDocument ?? document;\n    const {innerHeight, innerWidth} = root.defaultView ?? window;\n    const clientRect = element.getBoundingClientRect();\n    const visibleRect = getVisibleBoundingRectangle(element, clientRect);\n    const {top, left, bottom, right} = visibleRect;\n    const insetTop = -Math.floor(top);\n    const insetLeft = -Math.floor(left);\n    const insetRight = -Math.floor(innerWidth - right);\n    const insetBottom = -Math.floor(innerHeight - bottom);\n    const rootMargin = `${insetTop}px ${insetRight}px ${insetBottom}px ${insetLeft}px`;\n\n    this.boundingClientRect = clientRect;\n    this.#positionObserver = new IntersectionObserver(\n      (entries: IntersectionObserverEntry[]) => {\n        const [entry] = entries;\n        const {intersectionRect} = entry;\n        /*\n         * The intersection ratio returned by the intersection observer entry\n         * represents the ratio of the intersectionRect to the boundingClientRect,\n         * which is not what we want. We want the ratio of the intersectionRect\n         * to the rootBounds (visible rect).\n         */\n        const intersectionRatio = Rectangle.intersectionRatio(\n          intersectionRect,\n          visibleRect\n        );\n\n        if (intersectionRatio !== 1) {\n          this.#observePosition();\n        }\n      },\n      {\n        threshold,\n        rootMargin,\n        root,\n      }\n    );\n\n    this.#positionObserver.observe(element);\n    this.#notify();\n  }, THROTTLE_INTERVAL);\n\n  #notify() {\n    if (this.#disconnected) return;\n\n    this.#updateDebug();\n\n    if (isRectEqual(this.boundingClientRect, this.#previousBoundingClientRect))\n      return;\n\n    this.#callback(this.boundingClientRect);\n    this.#previousBoundingClientRect = this.boundingClientRect;\n  }\n\n  #updateDebug() {\n    if (this.#debug) {\n      const {top, left, width, height} = getVisibleBoundingRectangle(\n        this.element\n      );\n\n      this.#debug.style.overflow = 'hidden';\n      this.#debug.style.visibility = 'visible';\n      this.#debug.style.top = `${Math.floor(top)}px`;\n      this.#debug.style.left = `${Math.floor(left)}px`;\n      this.#debug.style.width = `${Math.floor(width)}px`;\n      this.#debug.style.height = `${Math.floor(height)}px`;\n    }\n  }\n}\n","export function timeout(callback: () => void, duration: number): () => void {\n  const id = setTimeout(callback, duration);\n\n  return () => clearTimeout(id);\n}\n","import {timeout} from './timeout.ts';\n\nexport function throttle<T extends (...args: any[]) => any>(\n  func: T,\n  limit: number\n): (...args: Parameters<T>) => void {\n  const time = () => performance.now();\n  let cancel: () => void | undefined;\n  let lastRan: number;\n\n  return function (this: any, ...args: Parameters<T>) {\n    const context = this;\n    if (!lastRan) {\n      func.apply(context, args);\n      lastRan = time();\n    } else {\n      cancel?.();\n      cancel = timeout(\n        () => {\n          func.apply(context, args);\n          lastRan = time();\n        },\n        limit - (time() - lastRan)\n      );\n    }\n  };\n}\n","import type {BoundingRectangle} from '@dnd-kit/geometry';\n\nexport function isRectEqual(\n  a: BoundingRectangle | undefined,\n  b: BoundingRectangle | undefined\n) {\n  if (a === b) return true;\n  if (!a || !b) return false;\n\n  return (\n    a.top == b.top &&\n    a.left == b.left &&\n    a.right == b.right &&\n    a.bottom == b.bottom\n  );\n}\n","/*\n * Check if an element has visible overflow.\n * @param element\n * @param style\n * @returns boolean\n */\nexport function isOverflowVisible(\n  element: Element,\n  style = getComputedStyle(element)\n) {\n  const {overflow, overflowX, overflowY} = style;\n\n  return (\n    overflow === 'visible' && overflowX === 'visible' && overflowY === 'visible'\n  );\n}\n","import type {BoundingRectangle} from '@dnd-kit/geometry';\n\nimport {isOverflowVisible} from './isOverflowVisible.ts';\n\n/*\n * Get the currently visible bounding rectangle of an element\n * @param element\n * @param boundingClientRect\n * @returns Rect\n */\nexport function getVisibleBoundingRectangle(\n  element: Element,\n  boundingClientRect = element.getBoundingClientRect(),\n  margin = 0\n): BoundingRectangle {\n  // Get the initial bounding client rect of the element\n  let rect: BoundingRectangle = boundingClientRect;\n  const {ownerDocument} = element;\n  const ownerWindow = ownerDocument.defaultView ?? window;\n\n  // Traverse up the DOM tree to clip the rect based on ancestors' bounding rects\n  let ancestor: HTMLElement | null = element.parentElement;\n\n  while (ancestor && ancestor !== ownerDocument.documentElement) {\n    if (!isOverflowVisible(ancestor)) {\n      const ancestorRect = ancestor.getBoundingClientRect();\n\n      const marginTop = margin * (ancestorRect.bottom - ancestorRect.top);\n      const marginRight = margin * (ancestorRect.right - ancestorRect.left);\n      const marginBottom = margin * (ancestorRect.bottom - ancestorRect.top);\n      const marginLeft = margin * (ancestorRect.right - ancestorRect.left);\n\n      // Clip the rect based on the ancestor's bounding rect\n      rect = {\n        top: Math.max(rect.top, ancestorRect.top - marginTop),\n        right: Math.min(rect.right, ancestorRect.right + marginRight),\n        bottom: Math.min(rect.bottom, ancestorRect.bottom + marginBottom),\n        left: Math.max(rect.left, ancestorRect.left - marginLeft),\n        width: 0, // Will be calculated next\n        height: 0, // Will be calculated next\n      };\n\n      // Calculate the width and height after clipping\n      rect.width = rect.right - rect.left;\n      rect.height = rect.bottom - rect.top;\n    }\n\n    // Move to the next ancestor\n    ancestor = ancestor.parentElement;\n  }\n\n  // Clip the rect based on the viewport (window)\n  const viewportWidth = ownerWindow.innerWidth;\n  const viewportHeight = ownerWindow.innerHeight;\n  const viewportMarginY = margin * viewportHeight;\n  const viewportMarginX = margin * viewportWidth;\n\n  rect = {\n    top: Math.max(rect.top, 0 - viewportMarginY),\n    right: Math.min(rect.right, viewportWidth + viewportMarginX),\n    bottom: Math.min(rect.bottom, viewportHeight + viewportMarginY),\n    left: Math.max(rect.left, 0 - viewportMarginX),\n    width: 0, // Will be calculated next\n    height: 0, // Will be calculated next\n  };\n\n  // Calculate the width and height after clipping\n  rect.width = rect.right - rect.left;\n  rect.height = rect.bottom - rect.top;\n\n  if (rect.width < 0) {\n    rect.width = 0;\n  }\n\n  if (rect.height < 0) {\n    rect.height = 0;\n  }\n\n  return rect;\n}\n","import {getVisibleBoundingRectangle} from './getVisibleBoundingRectangle.ts';\n\nexport function isVisible(\n  element: Element,\n  boundingClientRect = element.getBoundingClientRect()\n): boolean {\n  const {width, height} = getVisibleBoundingRectangle(\n    element,\n    boundingClientRect\n  );\n\n  return width > 0 && height > 0;\n}\n","export function isSafari() {\n  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n}\n","import {getWindow} from '../execution-context/getWindow.ts';\n\nexport function cloneElement(element: Element): Element {\n  const window = getWindow(element);\n  const selector = 'input, textarea, select, canvas, [contenteditable]';\n  const clonedElement = element.cloneNode(true) as HTMLElement;\n  const fields = Array.from(element.querySelectorAll(selector));\n  const clonedFields = Array.from(clonedElement.querySelectorAll(selector));\n\n  clonedFields.forEach((field, index) => {\n    const originalField = fields[index];\n\n    if (isField(field) && isField(originalField)) {\n      if (field.type !== 'file') {\n        field.value = originalField.value;\n      }\n\n      // Fixes an issue with original radio buttons losing their value once the\n      // clone is inserted in the DOM, as radio button `name` attributes must be unique\n      if (field.type === 'radio' && field.name) {\n        field.name = `Cloned__${field.name}`;\n      }\n    }\n\n    if (\n      field instanceof window.HTMLCanvasElement &&\n      originalField instanceof window.HTMLCanvasElement &&\n      originalField.width > 0 &&\n      originalField.height > 0\n    ) {\n      const destCtx = field.getContext('2d');\n      destCtx?.drawImage(originalField, 0, 0);\n    }\n  });\n\n  return clonedElement;\n}\n\nfunction isField(\n  element: Element\n): element is HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement {\n  return 'value' in element;\n}\n","export const ProxiedElements = new WeakMap<Element, Element>();\n","export interface EventListenerDescriptor {\n  type: string;\n  listener(event: Event): void;\n  options?: AddEventListenerOptions;\n}\n\ntype EventListenerInput = EventListenerDescriptor[] | EventListenerDescriptor;\n\ntype EventListenerEntry = [EventTarget, EventListenerDescriptor];\n\nexport class Listeners {\n  private entries: Set<EventListenerEntry> = new Set();\n\n  constructor() {}\n\n  public bind(target: EventTarget, input: EventListenerInput) {\n    const listeners = Array.isArray(input) ? input : [input];\n    const entries: EventListenerEntry[] = [];\n\n    for (const descriptor of listeners) {\n      const {type, listener, options} = descriptor;\n      const entry: EventListenerEntry = [target, descriptor];\n\n      target.addEventListener(type, listener, options);\n      this.entries.add(entry);\n      entries.push(entry);\n    }\n\n    return function cleanup() {\n      for (const [target, {type, listener, options}] of entries) {\n        target.removeEventListener(type, listener, options);\n      }\n    };\n  }\n\n  public clear = () => {\n    for (const entry of this.entries) {\n      const [target, {type, listener, options}] = entry;\n\n      target.removeEventListener(type, listener, options);\n    }\n\n    this.entries.clear();\n  };\n}\n","export function supportsPopover(element: Element): element is Element & {\n  showPopover(): void;\n  hidePopover(): void;\n} {\n  return (\n    'showPopover' in element &&\n    'hidePopover' in element &&\n    typeof element.showPopover === 'function' &&\n    typeof element.hidePopover === 'function'\n  );\n}\n","import {supportsPopover} from './supportsPopover.ts';\n\nexport function showPopover(element: Element) {\n  if (\n    supportsPopover(element) &&\n    element.isConnected &&\n    element.hasAttribute('popover')\n  ) {\n    element.showPopover();\n  }\n}\n","import {canUseDOM} from '../execution-context/canUseDOM.ts';\nimport {getDocument} from '../execution-context/getDocument.ts';\n\nexport function isDocumentScrollingElement(element: Element | null) {\n  if (!canUseDOM || !element) {\n    return false;\n  }\n\n  return element === getDocument(element).scrollingElement;\n}\n","import {getBoundingRectangle} from '../bounding-rectangle/getBoundingRectangle.ts';\nimport {getViewportBoundingRectangle} from '../bounding-rectangle/getViewportBoundingRectangle.ts';\nimport {isDocumentScrollingElement} from './documentScrollingElement.ts';\n\nexport function getScrollPosition(scrollableElement: Element) {\n  const rect = isDocumentScrollingElement(scrollableElement)\n    ? getViewportBoundingRectangle(scrollableElement)\n    : getBoundingRectangle(scrollableElement);\n\n  const dimensions = isDocumentScrollingElement(scrollableElement)\n    ? {\n        height: window.innerHeight,\n        width: window.innerWidth,\n      }\n    : {\n        height: scrollableElement.clientHeight,\n        width: scrollableElement.clientWidth,\n      };\n  const position = {\n    current: {\n      x: scrollableElement.scrollLeft,\n      y: scrollableElement.scrollTop,\n    },\n    max: {\n      x: scrollableElement.scrollWidth - dimensions.width,\n      y: scrollableElement.scrollHeight - dimensions.height,\n    },\n  };\n\n  const isTop = position.current.y <= 0;\n  const isLeft = position.current.x <= 0;\n  const isBottom = position.current.y >= position.max.y;\n  const isRight = position.current.x >= position.max.x;\n\n  return {\n    rect,\n    position,\n    isTop,\n    isLeft,\n    isBottom,\n    isRight,\n  };\n}\n","import type {Coordinates} from '@dnd-kit/geometry';\n\nimport {getScrollPosition} from './getScrollPosition.ts';\n\nexport function canScroll(scrollableElement: Element, by?: Coordinates) {\n  const {isTop, isBottom, isLeft, isRight, position} =\n    getScrollPosition(scrollableElement);\n\n  const {x, y} = by ?? {x: 0, y: 0};\n\n  const top = !isTop && position.current.y + y > 0;\n  const bottom = !isBottom && position.current.y + y < position.max.y;\n  const left = !isLeft && position.current.x + x > 0;\n  const right = !isRight && position.current.x + x < position.max.x;\n\n  return {\n    top,\n    bottom,\n    left,\n    right,\n    x: left || right,\n    y: top || bottom,\n  };\n}\n","import {getWindow} from '../execution-context/getWindow.ts';\n\nexport function isSVGElement(node: Node): node is SVGElement {\n  return node instanceof getWindow(node).SVGElement;\n}\n","import {getWindow} from '../execution-context/getWindow.ts';\n\nexport function getComputedStyles(element: Element) {\n  return getWindow(element).getComputedStyle(element);\n}\n","import {getComputedStyles} from '../styles/getComputedStyles.ts';\n\nexport function isFixed(\n  node: Element,\n  computedStyle: CSSStyleDeclaration = getComputedStyles(node)\n): boolean {\n  return (\n    computedStyle.position === 'fixed' || computedStyle.position === 'sticky'\n  );\n}\n","import {getComputedStyles} from '../styles/getComputedStyles.ts';\n\nexport function isScrollable(\n  element: HTMLElement,\n  computedStyle: CSSStyleDeclaration = getComputedStyles(element)\n): boolean {\n  const overflowRegex = /(auto|scroll|overlay)/;\n  const properties = ['overflow', 'overflowX', 'overflowY'];\n\n  return properties.some((property) => {\n    const value = computedStyle[property as keyof CSSStyleDeclaration];\n\n    return typeof value === 'string' ? overflowRegex.test(value) : false;\n  });\n}\n","import {getWindow} from '../execution-context/getWindow.ts';\nimport {isDocument} from '../type-guards/isDocument.ts';\nimport {isHTMLElement} from '../type-guards/isHTMLElement.ts';\nimport {isSVGElement} from '../type-guards/isSVGElement.ts';\nimport {getComputedStyles} from '../styles/getComputedStyles.ts';\nimport {isFixed} from './isFixed.ts';\nimport {isScrollable} from './isScrollable.ts';\n\ninterface Options {\n  limit?: number;\n  excludeElement?: boolean;\n}\n\nconst defaultOptions: Options = {\n  excludeElement: true,\n};\n\nexport function getScrollableAncestors(\n  element: Node | null,\n  options: Options = defaultOptions\n): Set<Element> {\n  const {limit, excludeElement} = options;\n  const scrollParents = new Set<Element>();\n\n  function findScrollableAncestors(node: Node | null): Set<Element> {\n    if (limit != null && scrollParents.size >= limit) {\n      return scrollParents;\n    }\n\n    if (!node) {\n      return scrollParents;\n    }\n\n    if (\n      isDocument(node) &&\n      node.scrollingElement != null &&\n      !scrollParents.has(node.scrollingElement)\n    ) {\n      scrollParents.add(node.scrollingElement);\n\n      return scrollParents;\n    }\n\n    if (!isHTMLElement(node)) {\n      if (isSVGElement(node)) {\n        return findScrollableAncestors(node.parentElement);\n      }\n\n      return scrollParents;\n    }\n\n    if (scrollParents.has(node)) {\n      return scrollParents;\n    }\n\n    const computedStyle = getComputedStyles(node);\n\n    if (excludeElement && node === element) {\n      // no-op\n    } else if (isScrollable(node, computedStyle)) {\n      scrollParents.add(node);\n    }\n\n    if (isFixed(node, computedStyle)) {\n      const {scrollingElement} = node.ownerDocument;\n\n      if (scrollingElement) scrollParents.add(scrollingElement);\n\n      return scrollParents;\n    }\n\n    return findScrollableAncestors(node.parentNode);\n  }\n\n  if (!element) {\n    return scrollParents;\n  }\n\n  return findScrollableAncestors(element);\n}\n\nexport function getFirstScrollableAncestor(node: Node | null): Element | null {\n  const [firstScrollableAncestor] = getScrollableAncestors(node, {limit: 1});\n\n  return firstScrollableAncestor ?? null;\n}\n","import type {Axis, Coordinates} from '@dnd-kit/geometry';\n\nimport {getScrollPosition} from './getScrollPosition.ts';\n\nexport enum ScrollDirection {\n  Idle = 0,\n  Forward = 1,\n  Reverse = -1,\n}\n\nconst defaultThreshold: Record<Axis, number> = {\n  x: 0.2,\n  y: 0.2,\n};\n\nconst defaultTolerance: Record<Axis, number> = {\n  x: 10,\n  y: 10,\n};\n\ninterface ScrollIntent {\n  x: ScrollDirection;\n  y: ScrollDirection;\n}\n\nexport function detectScrollIntent(\n  scrollableElement: Element,\n  coordinates: Coordinates,\n  intent?: ScrollIntent,\n  acceleration = 25,\n  thresholdPercentage = defaultThreshold,\n  tolerance = defaultTolerance\n) {\n  const {\n    rect: scrollContainerRect,\n    isTop,\n    isBottom,\n    isLeft,\n    isRight,\n  } = getScrollPosition(scrollableElement);\n\n  const direction: Record<Axis, ScrollDirection> = {\n    x: ScrollDirection.Idle,\n    y: ScrollDirection.Idle,\n  };\n  const speed = {\n    x: 0,\n    y: 0,\n  };\n  const threshold = {\n    height: scrollContainerRect.height * thresholdPercentage.y,\n    width: scrollContainerRect.width * thresholdPercentage.x,\n  };\n\n  if (\n    !isTop &&\n    coordinates.y <= scrollContainerRect.top + threshold.height &&\n    intent?.y !== ScrollDirection.Forward &&\n    coordinates.x >= scrollContainerRect.left - tolerance.x &&\n    coordinates.x <= scrollContainerRect.right + tolerance.x\n  ) {\n    // Scroll Up\n    direction.y = ScrollDirection.Reverse;\n    speed.y =\n      acceleration *\n      Math.abs(\n        (scrollContainerRect.top + threshold.height - coordinates.y) /\n          threshold.height\n      );\n  } else if (\n    !isBottom &&\n    coordinates.y >= scrollContainerRect.bottom - threshold.height &&\n    intent?.y !== ScrollDirection.Reverse &&\n    coordinates.x >= scrollContainerRect.left - tolerance.x &&\n    coordinates.x <= scrollContainerRect.right + tolerance.x\n  ) {\n    // Scroll Down\n    direction.y = ScrollDirection.Forward;\n    speed.y =\n      acceleration *\n      Math.abs(\n        (scrollContainerRect.bottom - threshold.height - coordinates.y) /\n          threshold.height\n      );\n  }\n\n  if (\n    !isRight &&\n    coordinates.x >= scrollContainerRect.right - threshold.width &&\n    intent?.x !== ScrollDirection.Reverse &&\n    coordinates.y >= scrollContainerRect.top - tolerance.y &&\n    coordinates.y <= scrollContainerRect.bottom + tolerance.y\n  ) {\n    // Scroll Right\n    direction.x = ScrollDirection.Forward;\n    speed.x =\n      acceleration *\n      Math.abs(\n        (scrollContainerRect.right - threshold.width - coordinates.x) /\n          threshold.width\n      );\n  } else if (\n    !isLeft &&\n    coordinates.x <= scrollContainerRect.left + threshold.width &&\n    intent?.x !== ScrollDirection.Forward &&\n    coordinates.y >= scrollContainerRect.top - tolerance.y &&\n    coordinates.y <= scrollContainerRect.bottom + tolerance.y\n  ) {\n    // Scroll Left\n    direction.x = ScrollDirection.Reverse;\n    speed.x =\n      acceleration *\n      Math.abs(\n        (scrollContainerRect.left + threshold.width - coordinates.x) /\n          threshold.width\n      );\n  }\n\n  return {\n    direction,\n    speed,\n  };\n}\n","import {getComputedStyles} from '../styles/getComputedStyles.ts';\nimport {isHTMLElement} from '../type-guards/isHTMLElement.ts';\nimport {getFirstScrollableAncestor} from './getScrollableAncestors.ts';\n\nfunction supportsScrollIntoViewIfNeeded(\n  element: Element\n): element is Element & {\n  scrollIntoViewIfNeeded: (centerIfNeeded?: boolean) => void;\n} {\n  return (\n    'scrollIntoViewIfNeeded' in element &&\n    typeof element.scrollIntoViewIfNeeded === 'function'\n  );\n}\n\nexport function scrollIntoViewIfNeeded(el: Element, centerIfNeeded = false) {\n  if (supportsScrollIntoViewIfNeeded(el)) {\n    el.scrollIntoViewIfNeeded(centerIfNeeded);\n    return;\n  }\n\n  if (!isHTMLElement(el)) {\n    return el.scrollIntoView();\n  }\n\n  var parent = getFirstScrollableAncestor(el);\n\n  if (!isHTMLElement(parent)) {\n    return;\n  }\n\n  const parentComputedStyle = getComputedStyles(parent),\n    parentBorderTopWidth = parseInt(\n      parentComputedStyle.getPropertyValue('border-top-width')\n    ),\n    parentBorderLeftWidth = parseInt(\n      parentComputedStyle.getPropertyValue('border-left-width')\n    ),\n    overTop = el.offsetTop - parent.offsetTop < parent.scrollTop,\n    overBottom =\n      el.offsetTop - parent.offsetTop + el.clientHeight - parentBorderTopWidth >\n      parent.scrollTop + parent.clientHeight,\n    overLeft = el.offsetLeft - parent.offsetLeft < parent.scrollLeft,\n    overRight =\n      el.offsetLeft -\n        parent.offsetLeft +\n        el.clientWidth -\n        parentBorderLeftWidth >\n      parent.scrollLeft + parent.clientWidth,\n    alignWithTop = overTop && !overBottom;\n\n  if ((overTop || overBottom) && centerIfNeeded) {\n    parent.scrollTop =\n      el.offsetTop -\n      parent.offsetTop -\n      parent.clientHeight / 2 -\n      parentBorderTopWidth +\n      el.clientHeight / 2;\n  }\n\n  if ((overLeft || overRight) && centerIfNeeded) {\n    parent.scrollLeft =\n      el.offsetLeft -\n      parent.offsetLeft -\n      parent.clientWidth / 2 -\n      parentBorderLeftWidth +\n      el.clientWidth / 2;\n  }\n\n  if ((overTop || overBottom || overLeft || overRight) && !centerIfNeeded) {\n    el.scrollIntoView(alignWithTop);\n  }\n}\n","export class Scheduler {\n  private animationFrame: number | undefined;\n  private tasks: Set<() => void> = new Set();\n\n  public schedule(task: () => void) {\n    this.tasks.add(task);\n\n    if (!this.animationFrame) {\n      this.animationFrame = requestAnimationFrame(this.flush);\n    }\n  }\n\n  public flush = () => {\n    const tasks = this.tasks;\n\n    this.animationFrame = undefined;\n    this.tasks = new Set();\n\n    for (const task of tasks) {\n      task();\n    }\n  };\n}\n\nexport const scheduler = new Scheduler();\n","import {Rectangle, type BoundingRectangle} from '@dnd-kit/geometry';\n\nimport {inverseTransform} from '../transform/inverseTransform.ts';\nimport {getComputedStyles} from '../styles/getComputedStyles.ts';\nimport {parseTransform, type Transform} from '../transform/index.ts';\nimport {getBoundingRectangle} from '../bounding-rectangle/getBoundingRectangle.ts';\nimport {getWindow} from '../execution-context/getWindow.ts';\n\ninterface Options {\n  getBoundingClientRect?: (element: Element) => BoundingRectangle;\n  /* Whether to ignore transforms when calculating the rectangle */\n  ignoreTransforms?: boolean;\n}\n\nexport class DOMRectangle extends Rectangle {\n  constructor(element: Element, options: Options = {}) {\n    const {\n      ignoreTransforms = false,\n      getBoundingClientRect = getBoundingRectangle,\n    } = options;\n    const resetAnimations = forceFinishAnimations(element);\n    let {top, left, right, bottom, width, height} =\n      getBoundingClientRect(element);\n    const computedStyles = getComputedStyles(element);\n    const parsedTransform = parseTransform(computedStyles);\n    const scale = {\n      x: parsedTransform?.scaleX ?? 1,\n      y: parsedTransform?.scaleY ?? 1,\n    };\n\n    resetAnimations?.();\n\n    const projectedTransform = getProjectedTransform(element);\n\n    if (parsedTransform && (ignoreTransforms || projectedTransform)) {\n      const updated = inverseTransform(\n        {top, left, right, bottom, width, height},\n        parsedTransform,\n        computedStyles.transformOrigin\n      );\n\n      top = updated.top;\n      left = updated.left;\n      width = updated.width;\n      height = updated.height;\n    }\n\n    if (projectedTransform && !ignoreTransforms) {\n      top = top + projectedTransform.y;\n      left = left + projectedTransform.x;\n      width = width * projectedTransform.scaleX;\n      height = height * projectedTransform.scaleY;\n      scale.x = projectedTransform.scaleX;\n      scale.y = projectedTransform.scaleY;\n    }\n\n    super(left, top, width, height);\n\n    this.scale = scale;\n  }\n}\n\n/*\n * Get the projected transform of an element based on its final keyframe\n */\nfunction getProjectedTransform(element: Element): Transform | null {\n  const {KeyframeEffect} = getWindow(element);\n  const animations = element.getAnimations();\n  let projectedTransform: Transform | null = null;\n\n  if (!animations.length) return null;\n\n  for (const animation of animations) {\n    const keyframes =\n      animation.effect instanceof KeyframeEffect\n        ? animation.effect.getKeyframes()\n        : [];\n    const keyframe = keyframes[keyframes.length - 1];\n\n    if (!keyframe) continue;\n\n    const {transform = '', translate = '', scale = ''} = keyframe;\n\n    if (transform || translate || scale) {\n      const parsedTransform = parseTransform({\n        transform: typeof transform === 'string' ? transform : '',\n        translate: typeof translate === 'string' ? translate : '',\n        scale: typeof scale === 'string' ? scale : '',\n      });\n\n      if (parsedTransform) {\n        projectedTransform = projectedTransform\n          ? {\n              x: projectedTransform.x + parsedTransform.x,\n              y: projectedTransform.y + parsedTransform.y,\n              z: projectedTransform.z ?? parsedTransform.z,\n              scaleX: projectedTransform.scaleX * parsedTransform.scaleX,\n              scaleY: projectedTransform.scaleY * parsedTransform.scaleY,\n            }\n          : parsedTransform;\n      }\n    }\n  }\n\n  return projectedTransform;\n}\n\n/*\n * Force animations on ancestors of the element into their end state\n * and return a function to reset them back to their current state.\n *\n * This is useful as it allows us to immediately calculate the final position\n * of an element without having to wait for the animations to finish.\n */\nfunction forceFinishAnimations(element: Element): (() => void) | undefined {\n  const {KeyframeEffect} = getWindow(element);\n  const animations = element.ownerDocument\n    .getAnimations()\n    .filter((animation) => {\n      if (animation.effect instanceof KeyframeEffect) {\n        const {target} = animation.effect;\n\n        if (target !== element && target?.contains(element)) {\n          return animation.effect.getKeyframes().some((keyframe) => {\n            const {transform, translate, scale, width, height} = keyframe;\n\n            return transform || translate || scale || width || height;\n          });\n        }\n      }\n    })\n    .map((animation) => {\n      const {effect, currentTime} = animation;\n      const duration = effect?.getComputedTiming().duration;\n\n      if (animation.pending) return;\n\n      if (\n        typeof duration == 'number' &&\n        typeof currentTime == 'number' &&\n        currentTime < duration\n      ) {\n        animation.currentTime = duration;\n\n        return () => {\n          animation.currentTime = currentTime;\n        };\n      }\n    });\n\n  if (animations.length > 0) {\n    return () => animations.forEach((reset) => reset?.());\n  }\n}\n","import type {BoundingRectangle} from '@dnd-kit/geometry';\n\nimport {type Transform} from './parseTransform.ts';\n\nexport function inverseTransform(\n  rect: BoundingRectangle,\n  parsedTransform: Transform,\n  transformOrigin: string\n): BoundingRectangle {\n  const {scaleX, scaleY, x: translateX, y: translateY} = parsedTransform;\n  const x = rect.left - translateX - (1 - scaleX) * parseFloat(transformOrigin);\n  const y =\n    rect.top -\n    translateY -\n    (1 - scaleY) *\n      parseFloat(transformOrigin.slice(transformOrigin.indexOf(' ') + 1));\n  const w = scaleX ? rect.width / scaleX : rect.width;\n  const h = scaleY ? rect.height / scaleY : rect.height;\n\n  return {\n    width: w,\n    height: h,\n    top: y,\n    right: x + w,\n    bottom: y + h,\n    left: x,\n  };\n}\n","import {getWindow} from '../execution-context/getWindow.ts';\n\nexport function supportsStyle(\n  element: Element\n): element is Element & {style: CSSStyleDeclaration} {\n  return (\n    'style' in element &&\n    element.style instanceof getWindow(element).CSSStyleDeclaration\n  );\n}\n","import {supportsStyle} from '../type-guards/supportsStyle.ts';\n\ntype ExtractStringProperties<T> = {\n  [K in keyof T]?: T[K] extends string ? string : never;\n};\n\nexport type StyleDeclaration = ExtractStringProperties<CSSStyleDeclaration> & {\n  viewTransitionName?: string;\n};\n\nexport class Styles {\n  private initial = new Map<string, string>();\n\n  constructor(private element: Element) {}\n\n  public set(properties: Record<string, string | number>, prefix = '') {\n    const {element} = this;\n\n    if (!supportsStyle(element)) {\n      return;\n    }\n\n    for (const [key, value] of Object.entries(properties)) {\n      const property = `${prefix}${key}`;\n\n      if (!this.initial.has(property)) {\n        this.initial.set(property, element.style.getPropertyValue(property));\n      }\n\n      element.style.setProperty(\n        property,\n        typeof value === 'string' ? value : `${value}px`\n      );\n    }\n  }\n\n  public remove(properties: string[], prefix = '') {\n    const {element} = this;\n\n    if (!supportsStyle(element)) {\n      return;\n    }\n\n    for (const key of properties) {\n      const property = `${prefix}${key}`;\n\n      element.style.removeProperty(property);\n    }\n  }\n\n  public reset() {\n    const {element} = this;\n\n    if (!supportsStyle(element)) {\n      return;\n    }\n\n    for (const [key, value] of this.initial) {\n      element.style.setProperty(key, value);\n    }\n\n    if (element.getAttribute('style') === '') {\n      element.removeAttribute('style');\n    }\n  }\n}\n","import {Styles} from '../styles/index.ts';\nimport {getComputedStyles} from '../styles/getComputedStyles.ts';\n\ninterface Arguments {\n  element: Element;\n  keyframes: PropertyIndexedKeyframes | Keyframe[];\n  options: KeyframeAnimationOptions;\n  onReady?(): void;\n  onFinish?(): void;\n}\nexport function animateTransform({\n  element,\n  keyframes,\n  options,\n  onReady,\n  onFinish,\n}: Arguments) {\n  const styles = new Styles(element);\n  const {transitionProperty} = getComputedStyles(element);\n\n  const properties = transitionProperty.split(', ');\n\n  styles.set({\n    'transition-property': properties.length\n      ? properties\n          .filter(\n            (property) =>\n              !property.includes('transform') && !property.includes('translate')\n          )\n          .join(', ')\n      : 'none',\n  });\n\n  onReady?.();\n\n  element.animate(keyframes, options).finished.then(() => {\n    onFinish?.();\n    styles.reset();\n  });\n}\n","export function parseTranslate(translate: string) {\n  if (translate === 'none') {\n    return null;\n  }\n\n  const [x, y, z = '0'] = translate.split(' ');\n  const output = {x: parseFloat(x), y: parseFloat(y), z: parseInt(z, 10)};\n\n  if (isNaN(output.x) && isNaN(output.y)) {\n    return null;\n  }\n\n  return {\n    x: isNaN(output.x) ? 0 : output.x,\n    y: isNaN(output.y) ? 0 : output.y,\n    z: isNaN(output.z) ? 0 : output.z,\n  };\n}\n","import {getComputedStyles} from '../styles/getComputedStyles.ts';\nimport {getWindow} from '../execution-context/getWindow.ts';\n\nimport {parseTranslate} from './parseTranslate.ts';\n\nfunction getFinalKeyframe(\n  element: Element,\n  match: (keyframe: Keyframe) => boolean\n): Keyframe | null {\n  const {KeyframeEffect} = getWindow(element);\n  const animations = element.getAnimations();\n\n  if (animations.length > 0) {\n    for (const animation of animations) {\n      const {effect} = animation;\n      const keyframes =\n        effect instanceof KeyframeEffect ? effect.getKeyframes() : [];\n      const matchedKeyframes = keyframes.filter(match);\n\n      if (matchedKeyframes.length > 0) {\n        return matchedKeyframes[matchedKeyframes.length - 1];\n      }\n    }\n  }\n\n  return null;\n}\n\nexport function computeTranslate(\n  element: Element,\n  translate = getComputedStyles(element).translate,\n  projected = true\n): {\n  x: number;\n  y: number;\n  z: number;\n} {\n  if (projected) {\n    const keyframe = getFinalKeyframe(\n      element,\n      (keyframe) => 'translate' in keyframe\n    );\n\n    if (keyframe) {\n      const {translate = ''} = keyframe;\n\n      if (typeof translate === 'string') {\n        const finalTranslate = parseTranslate(translate);\n\n        if (finalTranslate) {\n          return finalTranslate;\n        }\n      }\n    }\n  }\n\n  if (translate) {\n    const finalTranslate = parseTranslate(translate);\n\n    if (finalTranslate) {\n      return finalTranslate;\n    }\n  }\n\n  return {x: 0, y: 0, z: 0};\n}\n","export function parseScale(scale: string) {\n  if (scale === 'none') {\n    return null;\n  }\n\n  const values = scale.split(' ');\n  const x = parseFloat(values[0]);\n  const y = parseFloat(values[1]);\n\n  if (isNaN(x) && isNaN(y)) {\n    return null;\n  }\n\n  return {\n    x: isNaN(x) ? y : x,\n    y: isNaN(y) ? x : y,\n  };\n}\n","import type {Coordinates} from '@dnd-kit/geometry';\n\nimport {parseScale} from './parseScale.ts';\nimport {parseTranslate} from './parseTranslate.ts';\n\nexport interface Transform extends Coordinates {\n  z?: number;\n  scaleX: number;\n  scaleY: number;\n}\n\nexport function parseTransform(computedStyles: {\n  scale: string;\n  transform: string;\n  translate: string;\n}): Transform | null {\n  const {scale, transform, translate} = computedStyles;\n  const parsedScale = parseScale(scale);\n  const parsedTranslate = parseTranslate(translate);\n  const parsedMatrix = parseTransformMatrix(transform);\n\n  if (!parsedMatrix && !parsedScale && !parsedTranslate) {\n    return null;\n  }\n\n  const normalizedScale = {\n    x: parsedScale?.x ?? 1,\n    y: parsedScale?.y ?? 1,\n  };\n\n  const normalizedTranslate = {\n    x: parsedTranslate?.x ?? 0,\n    y: parsedTranslate?.y ?? 0,\n  };\n\n  const normalizedMatrix = {\n    x: parsedMatrix?.x ?? 0,\n    y: parsedMatrix?.y ?? 0,\n    scaleX: parsedMatrix?.scaleX ?? 1,\n    scaleY: parsedMatrix?.scaleY ?? 1,\n  };\n\n  return {\n    x: normalizedTranslate.x + normalizedMatrix.x,\n    y: normalizedTranslate.y + normalizedMatrix.y,\n    z: parsedTranslate?.z ?? 0,\n    scaleX: normalizedScale.x * normalizedMatrix.scaleX,\n    scaleY: normalizedScale.y * normalizedMatrix.scaleY,\n  };\n}\n\nfunction parseTransformMatrix(transform: string) {\n  if (transform.startsWith('matrix3d(')) {\n    const transformArray = transform.slice(9, -1).split(/, /);\n\n    return {\n      x: +transformArray[12],\n      y: +transformArray[13],\n      scaleX: +transformArray[0],\n      scaleY: +transformArray[5],\n    };\n  } else if (transform.startsWith('matrix(')) {\n    const transformArray = transform.slice(7, -1).split(/, /);\n\n    return {\n      x: +transformArray[4],\n      y: +transformArray[5],\n      scaleX: +transformArray[0],\n      scaleY: +transformArray[3],\n    };\n  }\n\n  return null;\n}\n","import {getWindow} from '../execution-context/getWindow.ts';\n\nexport function isElement(target: EventTarget | null): target is Element {\n  return target instanceof getWindow(target).Element;\n}\n","import {getWindow} from '../execution-context/getWindow.ts';\n\nexport function isKeyboardEvent(\n  event: Event | null | undefined\n): event is KeyboardEvent {\n  if (!event) return false;\n\n  const {KeyboardEvent} = getWindow(event.target);\n\n  return event instanceof KeyboardEvent;\n}\n","import {getWindow} from '../execution-context/getWindow.ts';\n\nexport function isPointerEvent(\n  event: Event | null | undefined\n): event is PointerEvent {\n  if (!event) return false;\n\n  const {PointerEvent} = getWindow(event.target);\n\n  return event instanceof PointerEvent;\n}\n","interface ViewTransition {\n  ready: Promise<void>;\n  updateCallbackDone: Promise<void>;\n  finished: Promise<void>;\n  skipTransition(): void;\n}\n\nexport function supportsViewTransition(\n  document: Document\n): document is Document & {\n  startViewTransition(updateCallback: () => void): ViewTransition;\n} {\n  return 'startViewTransition' in document;\n}\n","const ids: Record<string, number> = {};\n\nexport function generateUniqueId(prefix: string) {\n  const id = ids[prefix] == null ? 0 : ids[prefix] + 1;\n  ids[prefix] = id;\n\n  return `${prefix}-${id}`;\n}\n"]}