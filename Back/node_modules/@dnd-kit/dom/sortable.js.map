{"version":3,"sources":["src/sortable/sortable.ts","src/sortable/SortableKeyboardPlugin.ts","src/sortable/utilities.ts","src/sortable/OptimisticSortingPlugin.ts","../helpers/dist/index.js"],"names":["batch","manager","id","source","target","Plugin","__defProp","__defProps","__getOwnPropDescs","__getOwnPropSymbols","__hasOwnProp","__propIsEnum","__defNormalProp","__spreadValues","__spreadProps","Sortable","_a","index","group"],"mappings":"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","sourcesContent":["import {batch, reactive, untracked} from '@dnd-kit/state';\nimport type {CollisionPriority} from '@dnd-kit/abstract';\nimport type {\n  Data,\n  PluginConstructor,\n  Type,\n  UniqueIdentifier,\n} from '@dnd-kit/abstract';\nimport {\n  defaultCollisionDetection,\n  type CollisionDetector,\n} from '@dnd-kit/collision';\nimport {Draggable, Droppable} from '@dnd-kit/dom';\nimport type {\n  DraggableInput,\n  FeedbackType,\n  DroppableInput,\n  Sensors,\n  DragDropManager,\n} from '@dnd-kit/dom';\nimport {\n  animateTransform,\n  getComputedStyles,\n  computeTranslate,\n  ProxiedElements,\n} from '@dnd-kit/dom/utilities';\n\nimport {SortableKeyboardPlugin} from './SortableKeyboardPlugin.ts';\nimport {OptimisticSortingPlugin} from './OptimisticSortingPlugin.ts';\n\nexport interface SortableTransition {\n  /**\n   * The duration of the transition in milliseconds.\n   * @default 300\n   */\n  duration?: number;\n  /**\n   * The easing function to use for the transition.\n   * @default 'cubic-bezier(0.25, 1, 0.5, 1)'\n   */\n  easing?: string;\n  /**\n   * Whether the sortable item should transition when its index changes,\n   * but there is no drag operation in progress.\n   * @default false\n   **/\n  idle?: boolean;\n}\n\nconst defaultPlugins: PluginConstructor[] = [\n  SortableKeyboardPlugin,\n  OptimisticSortingPlugin,\n];\n\nexport interface SortableInput<T extends Data>\n  extends DraggableInput<T>,\n    DroppableInput<T> {\n  /**\n   * The index of the sortable item within its group.\n   */\n  index: number;\n\n  /**\n   * The element that should be used as the droppable target for this sortable item.\n   */\n  target?: Element;\n\n  /**\n   * The optional unique identifier of the group that the sortable item belongs to.\n   */\n  group?: UniqueIdentifier;\n  /**\n   * The transition configuration to use when the index of the sortable item changes.\n   */\n  transition?: SortableTransition | null;\n  /**\n   * Plugins to register when sortable item is instantiated.\n   * @default [SortableKeyboardPlugin, OptimisticSortingPlugin]\n   */\n  plugins?: PluginConstructor[];\n}\n\nexport const defaultSortableTransition: SortableTransition = {\n  duration: 250,\n  easing: 'cubic-bezier(0.25, 1, 0.5, 1)',\n  idle: false,\n};\n\nexport class Sortable<T extends Data = Data> {\n  public draggable: Draggable<T>;\n  public droppable: Droppable<T>;\n\n  @reactive\n  public accessor index: number;\n\n  previousIndex: number;\n  initialIndex: number;\n  initialGroup: UniqueIdentifier | undefined;\n\n  @reactive\n  public accessor group: UniqueIdentifier | undefined;\n\n  transition: SortableTransition | null;\n\n  constructor(\n    {\n      effects: inputEffects = () => [],\n      group,\n      index,\n      sensors,\n      type,\n      transition = defaultSortableTransition,\n      plugins = defaultPlugins,\n      ...input\n    }: SortableInput<T>,\n    manager: DragDropManager<any, any> | undefined\n  ) {\n    let previousGroup = group;\n\n    this.droppable = new SortableDroppable<T>(input, manager, this);\n    this.draggable = new SortableDraggable<T>(\n      {\n        ...input,\n        effects: () => [\n          () =>\n            this.manager?.monitor.addEventListener('dragstart', () => {\n              this.initialIndex = this.index;\n              this.initialGroup = this.group;\n              this.previousIndex = this.index;\n            }),\n          () => {\n            const {index, group, previousIndex, manager: _} = this;\n\n            // Re-run this effect whenever the index changes\n            if (index !== previousIndex || group !== previousGroup) {\n              this.previousIndex = index;\n              previousGroup = group;\n\n              this.animate();\n            }\n          },\n          () => {\n            const {target} = this;\n            const {feedback, isDragSource} = this.draggable;\n\n            if (feedback == 'move' && isDragSource) {\n              this.droppable.disabled = !target;\n            }\n          },\n          () => {\n            const {manager} = this;\n\n            for (const plugin of plugins) {\n              manager?.registry.register(plugin);\n            }\n          },\n          ...inputEffects(),\n        ],\n        type,\n        sensors,\n      },\n      manager,\n      this\n    );\n\n    this.manager = manager;\n    this.index = index;\n    this.previousIndex = index;\n    this.initialIndex = index;\n    this.group = group;\n    this.type = type;\n    this.transition = transition;\n  }\n\n  protected animate() {\n    untracked(() => {\n      const {manager, transition} = this;\n      const {shape} = this.droppable;\n\n      if (!manager) return;\n\n      const {idle} = manager.dragOperation.status;\n\n      if (!shape || !transition || (idle && !transition.idle)) {\n        return;\n      }\n\n      manager.renderer.rendering.then(() => {\n        const {element} = this;\n\n        if (!element) {\n          return;\n        }\n\n        const updatedShape = this.refreshShape();\n\n        if (!updatedShape) {\n          return;\n        }\n\n        queueMicrotask(() => {\n          const delta = {\n            x:\n              shape.boundingRectangle.left -\n              updatedShape.boundingRectangle.left,\n            y: shape.boundingRectangle.top - updatedShape.boundingRectangle.top,\n          };\n\n          const {translate} = getComputedStyles(element);\n          const currentTranslate = computeTranslate(element, translate, false);\n          const finalTranslate = computeTranslate(element, translate);\n\n          if (delta.x || delta.y) {\n            animateTransform({\n              element,\n              keyframes: {\n                translate: [\n                  `${currentTranslate.x + delta.x}px ${currentTranslate.y + delta.y}px ${currentTranslate.z}`,\n                  `${finalTranslate.x}px ${finalTranslate.y}px ${finalTranslate.z}`,\n                ],\n              },\n              options: transition,\n              onFinish: () => {\n                if (!manager.dragOperation.status.dragging) {\n                  this.droppable.shape = undefined;\n                }\n              },\n            });\n          }\n        });\n      });\n    });\n  }\n\n  public get manager(): DragDropManager<any, any> | undefined {\n    return this.draggable.manager as any;\n  }\n\n  public set manager(manager: DragDropManager<any, any> | undefined) {\n    batch(() => {\n      this.draggable.manager = manager as any;\n      this.droppable.manager = manager as any;\n    });\n  }\n\n  #element: Element | undefined;\n\n  public set element(element: Element | undefined) {\n    batch(() => {\n      const previousElement = this.#element;\n      const droppableElement = this.droppable.element;\n      const draggableElement = this.draggable.element;\n\n      if (!droppableElement || droppableElement === previousElement) {\n        this.droppable.element = element;\n      }\n\n      if (!draggableElement || draggableElement === previousElement) {\n        this.draggable.element = element;\n      }\n\n      this.#element = element;\n    });\n  }\n\n  public get element() {\n    const element = this.#element;\n\n    if (!element) return;\n\n    return ProxiedElements.get(element) ?? element ?? this.droppable.element;\n  }\n\n  public set target(target: Element | undefined) {\n    this.droppable.element = target;\n  }\n\n  public get target() {\n    return this.droppable.element;\n  }\n\n  public set source(source: Element | undefined) {\n    this.draggable.element = source;\n  }\n\n  public get source() {\n    return this.draggable.element;\n  }\n\n  public get disabled() {\n    return this.draggable.disabled && this.droppable.disabled;\n  }\n\n  public set feedback(value: FeedbackType) {\n    this.draggable.feedback = value;\n  }\n\n  public set disabled(value: boolean) {\n    batch(() => {\n      this.droppable.disabled = value;\n      this.draggable.disabled = value;\n    });\n  }\n\n  public set data(data: T) {\n    batch(() => {\n      this.droppable.data = data;\n      this.draggable.data = data;\n    });\n  }\n\n  public set handle(handle: Element | undefined) {\n    this.draggable.handle = handle;\n  }\n\n  public set id(id: UniqueIdentifier) {\n    batch(() => {\n      this.droppable.id = id;\n      this.draggable.id = id;\n    });\n  }\n\n  public get id() {\n    return this.droppable.id;\n  }\n\n  public set sensors(value: Sensors | undefined) {\n    this.draggable.sensors = value;\n  }\n\n  public set collisionPriority(value: CollisionPriority | number | undefined) {\n    this.droppable.collisionPriority = value;\n  }\n\n  public set collisionDetector(value: CollisionDetector | undefined) {\n    this.droppable.collisionDetector = value ?? defaultCollisionDetection;\n  }\n\n  public set type(type: Type | undefined) {\n    batch(() => {\n      this.droppable.type = type;\n      this.draggable.type = type;\n    });\n  }\n\n  public get type() {\n    return this.draggable.type;\n  }\n\n  public set accept(value: Droppable['accept']) {\n    this.droppable.accept = value;\n  }\n\n  public get accept() {\n    return this.droppable.accept;\n  }\n\n  public get isDropTarget() {\n    return this.droppable.isDropTarget;\n  }\n\n  /**\n   * A boolean indicating whether the sortable item is the source of a drag operation.\n   */\n  public get isDragSource() {\n    return this.draggable.isDragSource;\n  }\n\n  public get status() {\n    return this.draggable.status;\n  }\n\n  public refreshShape() {\n    return this.droppable.refreshShape();\n  }\n\n  public accepts(draggable: Draggable): boolean {\n    return this.droppable.accepts(draggable);\n  }\n\n  public register() {\n    batch(() => {\n      this.manager?.registry.register(this.droppable);\n      this.manager?.registry.register(this.draggable);\n    });\n\n    return () => this.unregister();\n  }\n\n  public unregister() {\n    batch(() => {\n      this.manager?.registry.unregister(this.droppable);\n      this.manager?.registry.unregister(this.draggable);\n    });\n  }\n\n  public destroy() {\n    batch(() => {\n      this.droppable.destroy();\n      this.draggable.destroy();\n    });\n  }\n}\n\nexport class SortableDraggable<T extends Data> extends Draggable<T> {\n  constructor(\n    input: DraggableInput<T>,\n    manager: DragDropManager | undefined,\n    public sortable: Sortable<T>\n  ) {\n    super(input, manager);\n  }\n}\n\nexport class SortableDroppable<T extends Data> extends Droppable<T> {\n  constructor(\n    input: DraggableInput<T>,\n    manager: DragDropManager | undefined,\n    public sortable: Sortable<T>\n  ) {\n    super(input, manager);\n  }\n}\n","import {batch, CleanupFunction, effect} from '@dnd-kit/state';\nimport {Plugin} from '@dnd-kit/abstract';\nimport {closestCorners} from '@dnd-kit/collision';\nimport {\n  DOMRectangle,\n  getVisibleBoundingRectangle,\n  isKeyboardEvent,\n  scheduler,\n  scrollIntoViewIfNeeded,\n} from '@dnd-kit/dom/utilities';\nimport type {Coordinates} from '@dnd-kit/geometry';\n\nimport {Scroller} from '@dnd-kit/dom';\nimport type {DragDropManager, Droppable} from '@dnd-kit/dom';\n\nimport {isSortable} from './utilities.ts';\n\nconst TOLERANCE = 10;\n\nexport class SortableKeyboardPlugin extends Plugin<DragDropManager> {\n  constructor(manager: DragDropManager) {\n    super(manager);\n\n    const cleanupEffect = effect(() => {\n      const {dragOperation} = manager;\n\n      if (!isKeyboardEvent(dragOperation.activatorEvent)) {\n        return;\n      }\n\n      if (!isSortable(dragOperation.source)) {\n        return;\n      }\n\n      if (dragOperation.status.initialized) {\n        const scroller = manager.registry.plugins.get(Scroller);\n\n        if (scroller) {\n          scroller.disable();\n\n          return () => scroller.enable();\n        }\n      }\n    });\n\n    const unsubscribe = manager.monitor.addEventListener(\n      'dragmove',\n      (event, manager) => {\n        queueMicrotask(() => {\n          if (this.disabled || event.defaultPrevented) {\n            return;\n          }\n\n          const {dragOperation} = manager;\n\n          if (!isKeyboardEvent(dragOperation.activatorEvent)) {\n            return;\n          }\n\n          if (!isSortable(dragOperation.source)) {\n            return;\n          }\n\n          if (!dragOperation.shape) {\n            return;\n          }\n\n          const {actions, collisionObserver, registry} = manager;\n          const {by} = event;\n\n          if (!by) {\n            return;\n          }\n\n          const direction = getDirection(by);\n          const {source, target} = dragOperation;\n          const {center} = dragOperation.shape.current;\n          const potentialTargets: Droppable[] = [];\n          const cleanup: CleanupFunction[] = [];\n\n          batch(() => {\n            for (const droppable of registry.droppables) {\n              const {id} = droppable;\n\n              if (\n                !droppable.accepts(source) ||\n                (id === target?.id && isSortable(droppable)) ||\n                !droppable.element\n              ) {\n                continue;\n              }\n\n              let previousShape = droppable.shape;\n              const shape = new DOMRectangle(droppable.element, {\n                getBoundingClientRect: (element) =>\n                  getVisibleBoundingRectangle(element, undefined, 0.2),\n              });\n\n              if (!shape.height || !shape.width) continue;\n\n              if (\n                (direction == 'down' &&\n                  center.y + TOLERANCE < shape.center.y) ||\n                (direction == 'up' && center.y - TOLERANCE > shape.center.y) ||\n                (direction == 'left' &&\n                  center.x - TOLERANCE > shape.center.x) ||\n                (direction == 'right' && center.x + TOLERANCE < shape.center.x)\n              ) {\n                potentialTargets.push(droppable);\n                droppable.shape = shape;\n                cleanup.push(() => (droppable.shape = previousShape));\n              }\n            }\n          });\n\n          event.preventDefault();\n          collisionObserver.disable();\n\n          const collisions = collisionObserver.computeCollisions(\n            potentialTargets,\n            closestCorners\n          );\n          batch(() => cleanup.forEach((clean) => clean()));\n\n          const [firstCollision] = collisions;\n\n          if (!firstCollision) {\n            return;\n          }\n\n          const {id} = firstCollision;\n          const {index, group} = source.sortable;\n\n          actions.setDropTarget(id).then((defaultPrevented) => {\n            if (defaultPrevented) return;\n\n            // Wait until optimistic sorting has a chance to update the DOM\n            const {source, target} = dragOperation;\n\n            if (!source || !isSortable(source)) {\n              return;\n            }\n\n            const {\n              index: newIndex,\n              group: newGroup,\n              target: targetElement,\n            } = source.sortable;\n            const updated = index !== newIndex || group !== newGroup;\n            const element = updated ? targetElement : target?.element;\n\n            if (!element) return;\n\n            scrollIntoViewIfNeeded(element);\n            const shape = new DOMRectangle(element);\n\n            if (!shape) {\n              return;\n            }\n\n            actions.move({\n              to: {\n                x: shape.center.x,\n                y: shape.center.y,\n              },\n            });\n\n            if (updated) {\n              actions\n                .setDropTarget(source.id)\n                .then(() => collisionObserver.enable());\n            } else {\n              collisionObserver.enable();\n            }\n          });\n        });\n      }\n    );\n\n    this.destroy = () => {\n      unsubscribe();\n      cleanupEffect();\n    };\n  }\n}\n\nfunction getDirection(delta: Coordinates) {\n  const {x, y} = delta;\n\n  if (x > 0) {\n    return 'right';\n  } else if (x < 0) {\n    return 'left';\n  } else if (y > 0) {\n    return 'down';\n  } else if (y < 0) {\n    return 'up';\n  }\n}\n","import type {Droppable, Draggable} from '@dnd-kit/dom';\n\nimport {SortableDroppable, SortableDraggable} from './sortable.ts';\n\nexport function isSortable(\n  element: Draggable | Droppable | null\n): element is SortableDroppable<any> | SortableDraggable<any> {\n  return (\n    element instanceof SortableDroppable || element instanceof SortableDraggable\n  );\n}\n","import {Plugin, type UniqueIdentifier} from '@dnd-kit/abstract';\nimport type {DragDropManager} from '@dnd-kit/dom';\nimport {move} from '@dnd-kit/helpers';\n\nimport {isSortable} from './utilities.ts';\nimport {Sortable, SortableDroppable} from './sortable.ts';\nimport {batch} from '@dnd-kit/state';\n\nconst defaultGroup = '__default__';\n\nexport class OptimisticSortingPlugin extends Plugin<DragDropManager> {\n  constructor(manager: DragDropManager) {\n    super(manager);\n\n    const getSortableInstances = () => {\n      const sortableInstances = new Map<\n        UniqueIdentifier | undefined,\n        Set<Sortable>\n      >();\n\n      for (const droppable of manager.registry.droppables) {\n        if (droppable instanceof SortableDroppable) {\n          const {sortable} = droppable;\n          const {group} = sortable;\n\n          let instances = sortableInstances.get(group);\n\n          if (!instances) {\n            instances = new Set();\n            sortableInstances.set(group, instances);\n          }\n\n          instances.add(sortable);\n        }\n      }\n\n      for (const [group, instances] of sortableInstances) {\n        sortableInstances.set(group, new Set(sort(instances)));\n      }\n\n      return sortableInstances;\n    };\n\n    const unsubscribe = [\n      manager.monitor.addEventListener('dragover', (event, manager) => {\n        queueMicrotask(() => {\n          if (this.disabled || event.defaultPrevented) {\n            return;\n          }\n\n          const {dragOperation} = manager;\n          const {source, target} = dragOperation;\n\n          if (!isSortable(source) || !isSortable(target)) {\n            return;\n          }\n\n          if (source.sortable === target.sortable) {\n            return;\n          }\n\n          const instances = getSortableInstances();\n          const sameGroup = source.sortable.group === target.sortable.group;\n          const sourceInstances = instances.get(source.sortable.group);\n          const targetInstances = sameGroup\n            ? sourceInstances\n            : instances.get(target.sortable.group);\n\n          if (!sourceInstances || !targetInstances) return;\n\n          // Wait for the renderer to handle the event before attempting to optimistically update\n          manager.renderer.rendering.then(() => {\n            for (const [group, sortableInstances] of instances.entries()) {\n              const entries = Array.from(sortableInstances).entries();\n\n              for (const [index, sortable] of entries) {\n                if (sortable.index !== index || sortable.group !== group) {\n                  // At least one index or group was changed so we should abort optimistic updates\n                  return;\n                }\n              }\n            }\n\n            const sourceElement = source.sortable.element;\n            const targetElement = target.sortable.element;\n\n            if (!targetElement || !sourceElement) {\n              return;\n            }\n\n            const orderedSourceSortables = sort(sourceInstances);\n            const orderedTargetSortables = sameGroup\n              ? orderedSourceSortables\n              : sort(targetInstances);\n            const sourceGroup = source.sortable.group ?? defaultGroup;\n            const targetGroup = target.sortable.group ?? defaultGroup;\n            const state = {\n              [sourceGroup]: orderedSourceSortables,\n              [targetGroup]: orderedTargetSortables,\n            };\n            const newState = move(state, event);\n\n            if (state === newState) return;\n\n            const sourceIndex = newState[targetGroup].indexOf(source.sortable);\n            const targetIndex = newState[targetGroup].indexOf(target.sortable);\n\n            reorder(sourceElement, sourceIndex, targetElement, targetIndex);\n\n            manager.collisionObserver.disable();\n\n            batch(() => {\n              for (const [index, sortable] of newState[sourceGroup].entries()) {\n                sortable.index = index;\n              }\n\n              if (!sameGroup) {\n                for (const [index, sortable] of newState[\n                  targetGroup\n                ].entries()) {\n                  sortable.group = target.sortable.group;\n                  sortable.index = index;\n                }\n              }\n            });\n\n            manager.actions\n              .setDropTarget(source.id)\n              .then(() => manager.collisionObserver.enable());\n          });\n        });\n      }),\n      manager.monitor.addEventListener('dragend', (event, manager) => {\n        if (!event.canceled) {\n          return;\n        }\n\n        const {dragOperation} = manager;\n        const {source} = dragOperation;\n\n        if (!isSortable(source)) {\n          return;\n        }\n\n        if (\n          source.sortable.initialIndex === source.sortable.index &&\n          source.sortable.initialGroup === source.sortable.group\n        ) {\n          return;\n        }\n\n        queueMicrotask(() => {\n          const instances = getSortableInstances();\n          const initialGroupInstances = instances.get(\n            source.sortable.initialGroup\n          );\n\n          if (!initialGroupInstances) return;\n\n          // Wait for the renderer to handle the event before attempting to optimistically update\n          manager.renderer.rendering.then(() => {\n            for (const [group, sortableInstances] of instances.entries()) {\n              const entries = Array.from(sortableInstances).entries();\n\n              for (const [index, sortable] of entries) {\n                if (sortable.index !== index || sortable.group !== group) {\n                  // At least one index or group was changed so we should abort optimistic updates\n                  return;\n                }\n              }\n            }\n\n            const initialGroup = sort(initialGroupInstances);\n            const sourceElement = source.sortable.element;\n            const targetElement =\n              initialGroup[source.sortable.initialIndex]?.element;\n\n            if (!targetElement || !sourceElement) {\n              return;\n            }\n\n            reorder(\n              sourceElement,\n              source.sortable.initialIndex,\n              targetElement,\n              source.sortable.initialIndex\n            );\n\n            batch(() => {\n              for (const [_, sortableInstances] of instances.entries()) {\n                const entries = Array.from(sortableInstances).values();\n\n                for (const sortable of entries) {\n                  sortable.index = sortable.initialIndex;\n                  sortable.group = sortable.initialGroup;\n                }\n              }\n            });\n          });\n        });\n      }),\n    ];\n\n    this.destroy = () => {\n      for (const unsubscribeListener of unsubscribe) {\n        unsubscribeListener();\n      }\n    };\n  }\n}\n\nfunction reorder(\n  sourceElement: Element,\n  sourceIndex: number,\n  targetElement: Element,\n  targetIndex: number\n) {\n  const position = targetIndex < sourceIndex ? 'afterend' : 'beforebegin';\n\n  targetElement.insertAdjacentElement(position, sourceElement);\n}\n\nfunction sortByIndex(a: Sortable, b: Sortable) {\n  return a.index - b.index;\n}\n\nfunction sort(instances: Set<Sortable>) {\n  return Array.from(instances).sort(sortByIndex);\n}\n","var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n// src/move.ts\nfunction arrayMove(array, from, to) {\n  if (from === to) {\n    return array;\n  }\n  const newArray = array.slice();\n  newArray.splice(to, 0, newArray.splice(from, 1)[0]);\n  return newArray;\n}\nfunction arraySwap(array, from, to) {\n  if (from === to) {\n    return array;\n  }\n  const newArray = array.slice();\n  const item = newArray[from];\n  newArray[from] = newArray[to];\n  newArray[to] = item;\n  return newArray;\n}\nfunction mutate(items, event, mutation) {\n  var _a, _b;\n  const { source, target, canceled } = event.operation;\n  if (!source || !target || canceled || source.id === target.id) {\n    if (\"preventDefault\" in event) event.preventDefault();\n    return items;\n  }\n  const findIndex = (item, id) => item === id || typeof item === \"object\" && \"id\" in item && item.id === id;\n  if (Array.isArray(items)) {\n    const sourceIndex2 = items.findIndex((item) => findIndex(item, source.id));\n    const targetIndex2 = items.findIndex((item) => findIndex(item, target.id));\n    if (sourceIndex2 === -1 || targetIndex2 === -1) {\n      return items;\n    }\n    if (!canceled && \"index\" in source && typeof source.index === \"number\") {\n      const projectedSourceIndex = source.index;\n      if (projectedSourceIndex !== sourceIndex2) {\n        return mutation(items, sourceIndex2, projectedSourceIndex);\n      }\n    }\n    return mutation(items, sourceIndex2, targetIndex2);\n  }\n  const entries = Object.entries(items);\n  let sourceIndex = -1;\n  let sourceParent;\n  let targetIndex = -1;\n  let targetParent;\n  for (const [id, children] of entries) {\n    if (sourceIndex === -1) {\n      sourceIndex = children.findIndex((item) => findIndex(item, source.id));\n      if (sourceIndex !== -1) {\n        sourceParent = id;\n      }\n    }\n    if (targetIndex === -1) {\n      targetIndex = children.findIndex((item) => findIndex(item, target.id));\n      if (targetIndex !== -1) {\n        targetParent = id;\n      }\n    }\n    if (sourceIndex !== -1 && targetIndex !== -1) {\n      break;\n    }\n  }\n  if (!source.manager) return items;\n  const { dragOperation } = source.manager;\n  const position = (_b = (_a = dragOperation.shape) == null ? void 0 : _a.current.center) != null ? _b : dragOperation.position.current;\n  if (targetParent == null) {\n    if (target.id in items) {\n      const insertionIndex = target.shape && position.y > target.shape.center.y ? items[target.id].length : 0;\n      targetParent = target.id;\n      targetIndex = insertionIndex;\n    }\n  }\n  if (sourceParent == null || targetParent == null || sourceParent === targetParent && sourceIndex === targetIndex) {\n    if (\"preventDefault\" in event) event.preventDefault();\n    return items;\n  }\n  if (sourceParent === targetParent) {\n    return __spreadProps(__spreadValues({}, items), {\n      [sourceParent]: mutation(items[sourceParent], sourceIndex, targetIndex)\n    });\n  }\n  const isBelowTarget = target.shape && position.y > target.shape.center.y;\n  const modifier = isBelowTarget ? 1 : 0;\n  const sourceItem = items[sourceParent][sourceIndex];\n  return __spreadProps(__spreadValues({}, items), {\n    [sourceParent]: [\n      ...items[sourceParent].slice(0, sourceIndex),\n      ...items[sourceParent].slice(sourceIndex + 1)\n    ],\n    [targetParent]: [\n      ...items[targetParent].slice(0, targetIndex + modifier),\n      sourceItem,\n      ...items[targetParent].slice(targetIndex + modifier)\n    ]\n  });\n}\nfunction move(items, event) {\n  return mutate(items, event, arrayMove);\n}\nfunction swap(items, event) {\n  return mutate(items, event, arraySwap);\n}\nexport {\n  arrayMove,\n  arraySwap,\n  move,\n  swap\n};\n"]}