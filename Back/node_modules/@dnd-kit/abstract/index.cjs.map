{"version":3,"sources":["src/core/collision/observer.ts","src/core/plugins/plugin.ts","src/core/plugins/utilities.ts","src/core/plugins/registry.ts","src/core/collision/utilities.ts","src/core/collision/notifier.ts","src/core/manager/events.ts","src/core/collision/types.ts","src/core/entities/entity/entity.ts","src/core/entities/entity/registry.ts","src/core/entities/draggable/draggable.ts","src/core/entities/droppable/droppable.ts","src/core/sensors/sensor.ts","src/core/modifiers/modifier.ts","src/core/manager/registry.ts","src/core/manager/dragOperation.ts","src/core/manager/renderer.ts","src/core/manager/manager.ts"],"names":["untracked","descriptor","effects","CollisionPriority","CollisionType","reactive","_disabled_dec","_init","_disabled","id","manager","signal","cleanup","derived","_type_dec","_c","_type","effect","Status","transform","operation"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAQ,QAAQ,aAAAA,YAAwB,eAAc;;;ACAtD,SAAQ,UAAU,iBAAgB;;;ACO3B,SAAS,UAGd,QAAW,SAA2C;AACtD,SAAO;AAAA,IACL;AAAA,IACA;AAAA,EACF;AACF;AAEO,SAAS,aACd,QACA;AACA,SAAO,CAAC,YAAkE;AACxE,WAAO,UAAU,QAAQ,OAAO;AAAA,EAClC;AACF;AAEO,SAAS,WACd,QAC+B;AAC/B,MAAI,OAAO,WAAW,YAAY;AAChC,WAAO;AAAA,MACL;AAAA,MACA,SAAS;AAAA,IACX;AAAA,EACF;AAEA,SAAO;AACT;;;ADpCA;AAuBE,iBAAC;AAbI,IAAe,SAAf,MAGL;AAAA,EACA,YACS,SACA,SACP;AAFO;AACA;AAQT,uBAAgB,WAAoB,kBAApC,gBAAoC,SAApC;AAAA,EAPG;AAAA;AAAA;AAAA;AAAA;AAAA,EAaI,SAAS;AACd,SAAK,WAAW;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,UAAU;AACf,SAAK,WAAW;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,aAAa;AAClB,WAAO,UAAU,MAAM;AACrB,aAAO,KAAK;AAAA,IACd,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKO,UAAU,SAAa;AAC5B,SAAK,UAAU;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA,EAKO,UAAU;AAAA,EAKjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO,UAAU,SAAwB;AACvC,WAAO,UAAU,MAAa,OAAO;AAAA,EACvC;AACF;AAnEO;AAcW;AAAhB,4BAAgB,YADhB,eAboB,QAcJ;AAdX,2BAAe;AAqEf,IAAM,aAAN,cAGG,OAAa;AAAC;;;AElFxB;AAUO,IAAM,iBAAN,MAIL;AAAA,EAGA,YAAoB,SAAY;AAAZ;AAFpB,SAAQ,YAAuB,oBAAI,IAAI;AAQvC,wCAA0C,CAAC;AAAA,EANV;AAAA,EAEjC,IAAW,SAAc;AACvB,WAAO,MAAM,KAAK,KAAK,UAAU,OAAO,CAAC;AAAA,EAC3C;AAAA,EAIA,IAAW,OAAO,SAAqB;AACrC,UAAM,cAAc,QACjB,IAAI,UAAU,EACd,YAAmC,CAAC,KAAKC,gBAAe;AACvD,UAAI,IAAI,KAAK,CAAC,EAAC,OAAM,MAAM,WAAWA,YAAW,MAAM,GAAG;AAExD,eAAO;AAAA,MACT;AAEA,aAAO,CAACA,aAAY,GAAG,GAAG;AAAA,IAC5B,GAAG,CAAC,CAAC;AACP,UAAM,eAAe,YAAY,IAAI,CAAC,EAAC,OAAM,MAAM,MAAM;AAEzD,eAAW,UAAU,mBAAK,kBAAiB;AACzC,UAAI,CAAC,aAAa,SAAS,MAAM,GAAG;AAClC,YAAI,OAAO,qBAAqB,YAAY;AAC1C;AAAA,QACF;AAEA,aAAK,WAAW,MAAW;AAAA,MAC7B;AAAA,IACF;AAEA,eAAW,EAAC,QAAQ,QAAO,KAAK,aAAa;AAC3C,WAAK,SAAS,QAAa,OAAgC;AAAA,IAC7D;AAEA,uBAAK,iBAAkB;AAAA,EACzB;AAAA,EAEO,IAAiB,QAAwC;AAC9D,UAAM,WAAW,KAAK,UAAU,IAAI,MAAM;AAE1C,WAAO;AAAA,EACT;AAAA,EAEO,SACL,QACA,SACiB;AACjB,UAAM,mBAAmB,KAAK,UAAU,IAAI,MAAM;AAElD,QAAI,kBAAkB;AACpB,aAAO;AAAA,IACT;AAEA,UAAM,WAAW,IAAI,OAAO,KAAK,SAAS,OAAO;AAEjD,SAAK,UAAU,IAAI,QAAQ,QAAQ;AAEnC,WAAO;AAAA,EACT;AAAA,EAEO,WAAwB,QAAW;AACxC,UAAM,WAAW,KAAK,UAAU,IAAI,MAAM;AAE1C,QAAI,UAAU;AACZ,eAAS,QAAQ;AACjB,WAAK,UAAU,OAAO,MAAM;AAAA,IAC9B;AAAA,EACF;AAAA,EAEO,UAAU;AACf,eAAW,UAAU,KAAK,UAAU,OAAO,GAAG;AAC5C,aAAO,QAAQ;AAAA,IACjB;AAEA,SAAK,UAAU,MAAM;AAAA,EACvB;AACF;AAvEE;;;ACjBK,SAAS,eAAe,GAAc,GAAc;AACzD,MAAI,EAAE,aAAa,EAAE,UAAU;AAC7B,QAAI,EAAE,SAAS,EAAE,MAAM;AACrB,aAAO,EAAE,QAAQ,EAAE;AAAA,IACrB;AAEA,WAAO,EAAE,OAAO,EAAE;AAAA,EACpB;AAEA,SAAO,EAAE,WAAW,EAAE;AACxB;;;AJPA,IAAM,gBAA4B,CAAC;AATnC;AAWO,IAAM,oBAAN,cAIG,OAAU;AAAA,EAClB,YAAY,SAAY;AACtB,UAAM,OAAO;AAmCf;AAkEA;AAnGE,SAAK,oBAAoB,KAAK,kBAAkB,KAAK,IAAI;AACzD,uBAAK,aAAc,OAAO,aAAa;AAEvC,SAAK,UAAU;AAAA,MACb,MAAM;AACJ,cAAM,aAAa,KAAK,kBAAkB;AAC1C,cAAM,cAAcD;AAAA,UAClB,MAAM,KAAK,QAAQ,cAAc,SAAS;AAAA,QAC5C;AACA,cAAM,sBAAsB,mBAAK;AAEjC,2BAAK,sBAAuB;AAE5B,YACE,uBACA,YAAY,KAAK,oBAAoB,KACrC,YAAY,KAAK,oBAAoB,GACrC;AACA;AAAA,QACF;AAEA,2BAAK,aAAY,QAAQ;AAAA,MAC3B;AAAA,MACA,MAAM;AACJ,cAAM,EAAC,cAAa,IAAI,KAAK;AAE7B,YAAI,cAAc,OAAO,aAAa;AACpC,eAAK,YAAY;AAAA,QACnB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EAIO,YAAY,YAAY,MAAM;AACnC,IAAAA,WAAU,MAAM;AACd,UAAI,WAAW;AACb,2BAAK,aAAY,QAAQ,KAAK,kBAAkB;AAAA,MAClD,OAAO;AACL,2BAAK,sBAAuB;AAAA,MAC9B;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEO,kBACL,SACA,mBACA;AACA,UAAM,EAAC,UAAU,cAAa,IAAI,KAAK;AACvC,UAAM,EAAC,QAAQ,OAAO,OAAM,IAAI;AAEhC,QAAI,CAAC,OAAO,eAAe,CAAC,OAAO;AACjC,aAAO;AAAA,IACT;AAEA,UAAM,aAA0B,CAAC;AAEjC,eAAW,SAAS,4BAAW,SAAS,YAAY;AAClD,UAAI,MAAM,UAAU;AAClB;AAAA,MACF;AAEA,UAAI,UAAU,CAAC,MAAM,QAAQ,MAAM,GAAG;AACpC;AAAA,MACF;AAEA,YAAM,kBAAkB,gDAAqB,MAAM;AAEnD,UAAI,CAAC,iBAAiB;AACpB;AAAA,MACF;AAEA,YAAM;AACN,YAAM,YAAYA;AAAA,QAAU,MAC1B,gBAAgB;AAAA,UACd,WAAW;AAAA,UACX;AAAA,QACF,CAAC;AAAA,MACH;AAEA,UAAI,WAAW;AACb,YAAI,MAAM,qBAAqB,MAAM;AACnC,oBAAU,WAAW,MAAM;AAAA,QAC7B;AAEA,mBAAW,KAAK,SAAS;AAAA,MAC3B;AAAA,IACF;AAEA,eAAW,KAAK,cAAc;AAE9B,WAAO;AAAA,EACT;AAAA,EAEA,IAAW,aAAa;AACtB,WAAO,mBAAK,aAAY;AAAA,EAC1B;AAGF;AAnEE;AAkEA;;;AKtHF,SAAgB,WAAAE,UAAS,aAAAF,kBAAgB;;;ACezC,IAAM,UAAN,MAAgC;AAAA,EAAhC;AACE,SAAQ,WAAW,oBAAI,IAA8B;AAAA;AAAA,EAE9C,iBAAoC,MAAS,SAAe;AACjE,UAAM,EAAC,SAAQ,IAAI;AACnB,UAAM,YAAY,IAAI,IAAI,SAAS,IAAI,IAAI,CAAC;AAE5C,cAAU,IAAI,OAAO;AACrB,aAAS,IAAI,MAAM,SAAS;AAE5B,WAAO,MAAM,KAAK,oBAAoB,MAAM,OAAO;AAAA,EACrD;AAAA,EAEO,oBAAoB,MAAe,SAAqB;AAC7D,UAAM,EAAC,SAAQ,IAAI;AACnB,UAAM,YAAY,IAAI,IAAI,SAAS,IAAI,IAAI,CAAC;AAE5C,cAAU,OAAO,OAAO;AACxB,aAAS,IAAI,MAAM,SAAS;AAAA,EAC9B;AAAA,EAEU,SAA4B,SAAY,MAAa;AAC7D,UAAM,EAAC,SAAQ,IAAI;AACnB,UAAM,YAAY,SAAS,IAAI,IAAI;AAEnC,QAAI,CAAC,WAAW;AACd;AAAA,IACF;AAEA,eAAW,YAAY,WAAW;AAChC,eAAS,GAAG,IAAI;AAAA,IAClB;AAAA,EACF;AACF;AAgDO,IAAM,kBAAN,cAIG,QAAiC;AAAA,EACzC,YAAoB,SAAY;AAC9B,UAAM;AADY;AAAA,EAEpB;AAAA,EAEO,SACL,MACA,OACA;AACA,UAAM,OAAO,CAAC,OAAO,KAAK,OAAO;AAEjC,UAAM,SAAS,MAAM,GAAG,IAAI;AAAA,EAC9B;AACF;AAEO,SAAS,mBACd,OACA,aAAa,MACG;AAChB,MAAI,mBAAmB;AAEvB,SAAO,iCACF,QADE;AAAA,IAEL;AAAA,IACA,IAAI,mBAAmB;AACrB,aAAO;AAAA,IACT;AAAA,IACA,iBAAiB;AACf,UAAI,CAAC,YAAY;AACf;AAAA,MACF;AAEA,yBAAmB;AAAA,IACrB;AAAA,EACF;AACF;;;AD/HO,IAAM,oBAAN,cAAgC,WAAW;AAAA,EAChD,YAAY,SAAoC;AAC9C,UAAM,OAAO;AAEb,UAAM,UAAU,CAAC,GAAgB,MAC/B,EAAE,IAAI,CAAC,EAAC,GAAE,MAAM,EAAE,EAAE,KAAK,EAAE,MAAM,EAAE,IAAI,CAAC,EAAC,GAAE,MAAM,EAAE,EAAE,KAAK,EAAE;AAE9D,QAAI,qBAAkC,CAAC;AAEvC,SAAK,UAAUE;AAAA,MACb,MAAM;AACJ,cAAM,EAAC,eAAe,kBAAiB,IAAI;AAE3C,YAAI,cAAc,OAAO,cAAc;AACrC,+BAAqB,CAAC;AACtB,4BAAkB,OAAO;AAAA,QAC3B;AAAA,MACF;AAAA,MACA,MAAM;AACJ,cAAM,EAAC,mBAAmB,QAAO,IAAI;AACrC,cAAM,EAAC,WAAU,IAAI;AAErB,YAAI,kBAAkB,WAAW,GAAG;AAClC;AAAA,QACF;AAEA,cAAM,QAAQ,mBAAmB;AAAA,UAC/B;AAAA,QACF,CAAC;AAED,gBAAQ,SAAS,aAAa,KAAK;AAEnC,YAAI,MAAM,kBAAkB;AAC1B;AAAA,QACF;AAEA,YAAI,QAAQ,YAAY,kBAAkB,GAAG;AAC3C;AAAA,QACF,OAAO;AACL,+BAAqB;AAAA,QACvB;AAEA,cAAM,CAAC,cAAc,IAAI;AAEzB,QAAAF,WAAU,MAAM;AApDxB;AAqDU,eAAI,iDAAgB,UAAO,aAAQ,cAAc,WAAtB,mBAA8B,KAAI;AAC3D,8BAAkB,QAAQ;AAE1B,oBAAQ,QAAQ,cAAc,iDAAgB,EAAE,EAAE,KAAK,MAAM;AAC3D,gCAAkB,OAAO;AAAA,YAC3B,CAAC;AAAA,UACH;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AACF;;;AEzDO,IAAK,oBAAL,kBAAKG,uBAAL;AACL,EAAAA,sCAAA;AACA,EAAAA,sCAAA;AACA,EAAAA,sCAAA;AACA,EAAAA,sCAAA;AACA,EAAAA,sCAAA;AALU,SAAAA;AAAA,GAAA;AAQL,IAAK,gBAAL,kBAAKC,mBAAL;AACL,EAAAA,8BAAA;AACA,EAAAA,8BAAA;AACA,EAAAA,8BAAA;AAHU,SAAAA;AAAA,GAAA;;;ACfZ,SAAyB,YAAAC,iBAA4B;AAArD,IAAAC,gBAAA,kCAAAC,QAAA,sBAAAC;AAgEE,gBAACH,YAMD,WAACA,YAMD,aAACA,YAMDC,iBAAA,CAACD;AAhEI,IAAM,SAAN,MAGL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,YAAY,OAAiB,SAAwB;AAqCrD,uBAAgB,UAAhB,kBAAAE,QAAA,6BAAAA,QAAA;AAMA,uBAAgB,KAAhB,kBAAAA,QAAA,8BAAAA,QAAA;AAMA,uBAAgB,OAAhB,kBAAAA,QAAA,8BAAAA,QAAA;AAMA,uBAAgBC,YAAhB,kBAAAD,QAAA,8BAAAA,QAAA;AAtDE,UAAM,EAAC,SAAAL,UAAS,IAAI,OAAO,CAAC,GAAG,WAAW,MAAK,IAAI;AAEnD,QAAI,aAAa;AAEjB,SAAK,UAAU;AACf,SAAK,KAAK;AACV,SAAK,OAAO;AACZ,SAAK,WAAW;AAChB,SAAK,UAAU,MAAG;AArCtB;AAqCyB;AAAA,QACnB,MAAM;AAEJ,gBAAM,EAAC,IAAAO,KAAI,SAAAC,SAAO,IAAI;AAEtB,cAAID,QAAO,YAAY;AACrB;AAAA,UACF;AAEA,UAAAC,YAAA,gBAAAA,SAAS,SAAS,SAAS;AAE3B,iBAAO,MAAMA,YAAA,gBAAAA,SAAS,SAAS,WAAW;AAAA,QAC5C;AAAA,QACA,IAAI,KAAAR,YAAA,gBAAAA,eAAA,YAAe,CAAC;AAAA,MACtB;AAAA;AACA,SAAK,UAAU,KAAK,QAAQ,KAAK,IAAI;AAErC,QAAI,SAAS;AACX,qBAAe,MAAM;AAvD3B;AAwDQ,mBAAK,YAAL,mBAAc,SAAS,SAAS;AAAA,MAClC,CAAC;AAAA,IACH;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAmCO,WAAmC;AA9F5C;AA+FI,YAAO,UAAK,YAAL,mBAAc,SAAS,SAAS;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,aAAmB;AAtG5B;AAuGI,eAAK,YAAL,mBAAc,SAAS,WAAW;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,UAAgB;AA9GzB;AA+GI,eAAK,YAAL,mBAAc,SAAS,WAAW;AAAA,EACpC;AACF;AA/FOK,SAAA;AA+CW;AAMA;AAMA;AAMAC,aAAA;AAlBhB,kBAAAD,QAAA,GAAgB,WADhB,cA9CW,QA+CK;AAMhB,kBAAAA,QAAA,GAAgB,MADhB,SApDW,QAqDK;AAMhB,kBAAAA,QAAA,GAAgB,QADhB,WA1DW,QA2DK;AAMhB,kBAAAA,QAAA,GAAgB,YADhBD,gBAhEW,QAiEKE;AAjEX,oBAAAD,QAAM;;;AClBb,SAAQ,WAAAL,UAAS,UAAAS,eAAa;AAUvB,IAAM,iBAAN,MAAuC;AAAA,EAAvC;AACL,SAAQ,MAAMA,QAAiC,oBAAI,IAAI,CAAC;AACxD,SAAQ,mBAAmB,oBAAI,QAAuB;AAsCtD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAO,WAAW,CAAC,KAAuB,UAAa;AACrD,YAAM,UAAU,KAAK,IAAI,KAAK;AAC9B,YAAM,eAAe,QAAQ,IAAI,GAAG;AAEpC,UAAI,iBAAiB,OAAO;AAC1B;AAAA,MACF;AAEA,UAAI,cAAc;AAChB,cAAMC,WAAU,KAAK,iBAAiB,IAAI,YAAY;AACtD,QAAAA,YAAA,gBAAAA;AACA,aAAK,iBAAiB,OAAO,YAAY;AAAA,MAC3C;AAEA,YAAM,aAAa,IAAI,IAAI,OAAO;AAClC,iBAAW,IAAI,KAAK,KAAK;AAEzB,WAAK,IAAI,QAAQ;AAEjB,YAAM,UAAUV,SAAQ,GAAG,MAAM,QAAQ,CAAC;AAC1C,WAAK,iBAAiB,IAAI,OAAO,OAAO;AAExC,aAAO,MAAM,KAAK,WAAW,KAAK,KAAK;AAAA,IACzC;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAO,aAAa,CAAC,KAAuB,UAAa;AACvD,YAAM,UAAU,KAAK,IAAI,KAAK;AAE9B,UAAI,QAAQ,IAAI,GAAG,MAAM,OAAO;AAC9B;AAAA,MACF;AAEA,YAAM,UAAU,KAAK,iBAAiB,IAAI,KAAK;AAC/C;AACA,WAAK,iBAAiB,OAAO,KAAK;AAElC,YAAM,aAAa,IAAI,IAAI,OAAO;AAClC,iBAAW,OAAO,GAAG;AAErB,WAAK,IAAI,QAAQ;AAAA,IACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA7EA,CAAQ,OAAO,QAAQ,IAAI;AACzB,WAAO,KAAK,IAAI,KAAK,EAAE,OAAO;AAAA,EAChC;AAAA,EAEA,IAAW,QAAQ;AACjB,WAAO,KAAK,IAAI,MAAM,OAAO;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,IAAI,YAAuC;AAChD,WAAO,KAAK,IAAI,MAAM,IAAI,UAAU;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,IAAI,YAA6C;AACtD,WAAO,KAAK,IAAI,MAAM,IAAI,UAAU;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA,EA0DO,UAAU;AACf,eAAW,SAAS,MAAM;AACxB,YAAM,UAAU,KAAK,iBAAiB,IAAI,KAAK;AAC/C;AACA,YAAM,QAAQ;AAAA,IAChB;AAEA,SAAK,IAAI,QAAQ,oBAAI,IAAI;AAAA,EAC3B;AACF;;;AC7GA,SAAQ,SAAS,YAAAG,iBAAe;AAAhC,mEAAAE,QAAA;AAgBO,IAAM,YAAN,eAGG,aAcR,kBAACF,YAGD,aAACA,YAGD,eAACA,YAMD,qBAAC,UA1BO,IAAa;AAAA,EACrB,YACE,IACA,SACA;AAFA,iBAAC,aAAW,MAAM,QArBtB,IAqBI,IAA8B,kBAA9B,IAA8B,CAA7B,aAAW,QAAM;AAGlB,UAAM,OAAO,OAAO;AARjB,sBAAAE,QAAA;AAkBL,uBAAgB,YAAhB,kBAAAA,QAAA,6BAAAA,QAAA;AAGA,uBAAgB,OAAhB,kBAAAA,QAAA,8BAAAA,QAAA;AAGA,uBAAgB,SAA0B,kBAA1CA,QAAA,UAA0C,UAA1C,kBAAAA,QAAA;AAdE,SAAK,OAAO;AACZ,SAAK,UAAU;AACf,SAAK,YAAY;AAAA,EACnB;AAAA,EAiBA,IAAW,eAAe;AA9C5B;AA+CI,aAAO,gBAAK,YAAL,mBAAc,cAAc,WAA5B,mBAAoC,QAAO,KAAK;AAAA,EACzD;AACF;AAjCOA,SAAA;AAkBW;AAGA;AAGA;AANhB,kBAAAA,QAAA,GAAgB,aADhB,gBAjBW,WAkBK;AAGhB,kBAAAA,QAAA,GAAgB,QADhB,WApBW,WAqBK;AAGhB,kBAAAA,QAAA,GAAgB,UADhB,aAvBW,WAwBK;AAMhB,kBAAAA,QAAA,GAAW,gBADX,mBA7BW;AAAN,oBAAAA,QAAM;;;AChBb,SAAQ,WAAAM,UAAkB,YAAAR,iBAA4B;AAAtD,mFAAAS,YAAA,aAAAC,KAAAR,QAAA,SAAAS,QAAA;AAmBO,IAAM,YAAN,eAGGD,MAAA,QAgBR,eAACV,YAUDS,aAAA,CAACT,YA+BD,0BAACA,YAGD,0BAACA,YAGD,cAACA,YAGD,qBAACQ,WAlEOE,KAAa;AAAA,EACrB,YACE,IACA,SACA;AAFA,iBAAC,UAAQ,mBAAmB,mBAAmB,KAxBnD,IAwBI,IAAwD,kBAAxD,IAAwD,CAAvD,UAAQ,qBAAmB,qBAAmB;AAG/C,UAAM,OAAO,OAAO;AARjB,sBAAAR,QAAA;AAoBL,uBAAgB,SAAhB,kBAAAA,QAAA,6BAAAA,QAAA;AAUA,uBAAgBS,QAAhB,kBAAAT,QAAA,8BAAAA,QAAA;AA+BA,uBAAgB,oBAAhB,kBAAAA,QAAA,8BAAAA,QAAA;AAGA,uBAAgB,oBAAhB,kBAAAA,QAAA,8BAAAA,QAAA;AAGA,uBAAgB,QAAhB,kBAAAA,QAAA,8BAAAA,QAAA;AAzDE,SAAK,SAAS;AACd,SAAK,oBAAoB;AACzB,SAAK,oBAAoB;AACzB,SAAK,OAAO;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAwBO,QAAQ,WAA+B;AAC5C,UAAM,EAAC,OAAM,IAAI;AAEjB,QAAI,CAAC,QAAQ;AACX,aAAO;AAAA,IACT;AAEA,QAAI,OAAO,WAAW,YAAY;AAChC,aAAO,OAAO,SAAS;AAAA,IACzB;AAEA,QAAI,CAAC,UAAU,MAAM;AACnB,aAAO;AAAA,IACT;AAEA,QAAI,MAAM,QAAQ,MAAM,GAAG;AACzB,aAAO,OAAO,SAAS,UAAU,IAAI;AAAA,IACvC;AAEA,WAAO,UAAU,SAAS;AAAA,EAC5B;AAAA,EAYA,IAAW,eAAe;AAzF5B;AA0FI,aAAO,gBAAK,YAAL,mBAAc,cAAc,WAA5B,mBAAoC,QAAO,KAAK;AAAA,EACzD;AACF;AAzEOA,SAAA,iBAAAQ;AAoBW;AAUAC,SAAA;AA+BA;AAGA;AAGA;AA/ChB,kBAAAT,QAAA,GAAgB,UADhB,aAnBW,WAoBK;AAUhB,kBAAAA,QAAA,GAAgB,QADhBO,YA7BW,WA8BKE;AA+BhB,kBAAAT,QAAA,GAAgB,qBADhB,wBA5DW,WA6DK;AAGhB,kBAAAA,QAAA,GAAgB,qBADhB,wBA/DW,WAgEK;AAGhB,kBAAAA,QAAA,GAAgB,SADhB,YAlEW,WAmEK;AAGhB,kBAAAA,QAAA,GAAW,gBADX,mBArEW;AAAN,oBAAAA,QAAM;;;ACNN,IAAe,SAAf,cAGG,OAAa;AAAA,EACrB,YACS,SACA,SACP;AACA,UAAM,SAAS,OAAO;AAHf;AACA;AAAA,EAGT;AAQF;;;AClBO,IAAM,WAAN,cAGG,OAAa;AAAA,EACrB,YACS,SACA,SACP;AACA,UAAM,SAAS,OAAO;AAHf;AACA;AAAA,EAGT;AAAA,EAEO,MAAM,WAA4C;AACvD,WAAO,UAAU;AAAA,EACnB;AACF;;;ACJO,IAAM,mBAAN,MAIL;AAAA,EACA,YAAY,SAAY;AAMxB,SAAO,aAAa,IAAI,eAAkB;AAC1C,SAAO,aAAa,IAAI,eAAkB;AANxC,SAAK,UAAU,IAAI,eAAwC,OAAO;AAClE,SAAK,UAAU,IAAI,eAAwC,OAAO;AAClE,SAAK,YAAY,IAAI,eAA0C,OAAO;AAAA,EACxE;AAAA,EAcO,SAAS,OAAY,SAA+B;AACzD,QAAI,iBAAiB,WAAW;AAC9B,aAAO,KAAK,WAAW,SAAS,MAAM,IAAI,KAAU;AAAA,IACtD;AAEA,QAAI,iBAAiB,WAAW;AAC9B,aAAO,KAAK,WAAW,SAAS,MAAM,IAAI,KAAU;AAAA,IACtD;AAEA,QAAI,MAAM,qBAAqB,UAAU;AACvC,aAAO,KAAK,UAAU,SAAS,OAAO,OAAO;AAAA,IAC/C;AAEA,QAAI,MAAM,qBAAqB,QAAQ;AACrC,aAAO,KAAK,QAAQ,SAAS,OAAO,OAAO;AAAA,IAC7C;AAEA,QAAI,MAAM,qBAAqB,QAAQ;AACrC,aAAO,KAAK,QAAQ,SAAS,OAAO,OAAO;AAAA,IAC7C;AAEA,UAAM,IAAI,MAAM,uBAAuB;AAAA,EACzC;AAAA,EAQO,WAAW,OAAY;AAC5B,QAAI,iBAAiB,QAAQ;AAC3B,UAAI,iBAAiB,WAAW;AAC9B,eAAO,KAAK,WAAW,WAAW,MAAM,IAAI,KAAU;AAAA,MACxD;AAEA,UAAI,iBAAiB,WAAW;AAC9B,eAAO,KAAK,WAAW,WAAW,MAAM,IAAI,KAAU;AAAA,MACxD;AAGA,aAAO,MAAM;AAAA,MAAC;AAAA,IAChB;AAEA,QAAI,MAAM,qBAAqB,UAAU;AACvC,aAAO,KAAK,UAAU,WAAW,KAAK;AAAA,IACxC;AAEA,QAAI,MAAM,qBAAqB,QAAQ;AACrC,aAAO,KAAK,QAAQ,WAAW,KAAK;AAAA,IACtC;AAEA,QAAI,MAAM,qBAAqB,QAAQ;AACrC,aAAO,KAAK,QAAQ,WAAW,KAAK;AAAA,IACtC;AAEA,UAAM,IAAI,MAAM,uBAAuB;AAAA,EACzC;AAAA,EAEA,UAAU;AACR,SAAK,WAAW,QAAQ;AACxB,SAAK,WAAW,QAAQ;AACxB,SAAK,QAAQ,QAAQ;AACrB,SAAK,QAAQ,QAAQ;AACrB,SAAK,UAAU,QAAQ;AAAA,EACzB;AACF;;;AC/GA,SAAQ,gBAA2B;AAEnC,SAAQ,OAAO,UAAU,UAAAU,SAAQ,UAAAN,eAAa;AAavC,IAAK,SAAL,kBAAKO,YAAL;AACL,EAAAA,QAAA,UAAO;AACP,EAAAA,QAAA,kBAAe;AACf,EAAAA,QAAA,cAAW;AACX,EAAAA,QAAA,aAAU;AAJA,SAAAA;AAAA,GAAA;AA4CL,SAAS,qBAId,SAAY;AACZ,QAAM;AAAA,IACJ,UAAU,EAAC,YAAY,WAAU;AAAA,IACjC;AAAA,EACF,IAAI;AACJ,QAAM,SAASP,QAAe,iBAAW;AACzC,QAAM,QAAQ;AAAA,IACZ,SAASA,QAAqB,IAAI;AAAA,IAClC,SAASA,QAAqB,IAAI;AAAA,EACpC;AACA,QAAM,WAAWA,QAAgB,KAAK;AACtC,QAAM,WAAW,IAAI,SAAS,EAAC,GAAG,GAAG,GAAG,EAAC,CAAC;AAC1C,QAAM,iBAAiBA,QAAqB,IAAI;AAChD,QAAM,mBAAmBA,QAAgC,IAAI;AAC7D,QAAM,mBAAmBA,QAAgC,IAAI;AAC7D,QAAM,WAAW,SAAS,MAAM,OAAO,UAAU,yBAAe;AAChE,QAAM,cAAc,SAAS,MAAM,OAAO,UAAU,iBAAW;AAC/D,QAAM,eAAe,SAAS,MAAM,OAAO,UAAU,iCAAmB;AACxE,QAAM,OAAO,SAAS,MAAM,OAAO,UAAU,iBAAW;AACxD,QAAM,UAAU,SAAS,MAAM,OAAO,UAAU,uBAAc;AAC9D,QAAM,YAAYA,QAAgB,IAAI;AACtC,MAAI;AACJ,QAAM,SAAS,SAAmB,MAAM;AArF1C;AAsFI,UAAM,aAAa,iBAAiB;AAEpC,QAAI,cAAc,KAAM,QAAO;AAE/B,UAAM,QAAQ,WAAW,IAAI,UAAU;AAEvC,QAAI,OAAO;AAET,uBAAiB;AAAA,IACnB;AAEA,YAAO,6BAAS,mBAAT,YAA2B;AAAA,EACpC,CAAC;AACD,QAAM,SAAS,SAAmB,MAAM;AAnG1C;AAoGI,UAAM,aAAa,iBAAiB;AACpC,WAAO,cAAc,QAAO,gBAAW,IAAI,UAAU,MAAzB,YAA8B,OAAO;AAAA,EACnE,CAAC;AAED,QAAM,YAAYA,QAAmB,CAAC,CAAC;AAEvC,EAAAM,QAAO,MAAM;AA1Gf,gBAAAF;AA2GI,UAAM,mBAAmB,UAAU,KAAK;AAExC,QAAI,qBAAqB,QAAQ,WAAW;AAC1C,uBAAiB,QAAQ,CAAC,aAAa,SAAS,QAAQ,CAAC;AAAA,IAC3D;AAEA,cAAU,SACRA,OAAA,kBAAO,UAAP,mBAAc,cAAd,mBAAyB,IAAI,CAAC,aAAa;AACzC,YAAM,EAAC,QAAQ,QAAO,IAAI,WAAW,QAAQ;AAC7C,aAAO,IAAI,OAAO,SAAS,OAAO;AAAA,IACpC,OAHA,OAAAA,MAGM,QAAQ;AAAA,EAClB,CAAC;AAED,QAAM,YAAY,SAAS,MAAM;AAC/B,UAAM,EAAC,GAAG,EAAC,IAAI,SAAS;AAExB,QAAII,aAAY,EAAC,GAAG,EAAC;AACrB,UAAM,eAAe,MAAM,QAAQ,KAAK;AACxC,UAAM,eAAe,MAAM,QAAQ,KAAK;AACxC,UAAMC,aAAoD;AAAA,MACxD,gBAAgB,eAAe,KAAK;AAAA,MACpC,UAAU,SAAS,KAAK;AAAA,MACxB,QAAQ,OAAO,KAAK;AAAA,MACpB,QAAQ,OAAO,KAAK;AAAA,MACpB,QAAQ;AAAA,QACN,SAAS,OAAO,KAAK;AAAA,QACrB,MAAM,KAAK,KAAK;AAAA,QAChB,cAAc,aAAa,KAAK;AAAA,QAChC,aAAa,YAAY,KAAK;AAAA,QAC9B,UAAU,SAAS,KAAK;AAAA,QACxB,WAAW,UAAU,KAAK;AAAA,QAC1B,SAAS,QAAQ,KAAK;AAAA,MACxB;AAAA,MACA,OACE,gBAAgB,eACZ,EAAC,SAAS,cAAc,SAAS,aAAY,IAC7C;AAAA,MACN;AAAA,IACF;AAEA,eAAW,YAAY,UAAU,OAAO;AACtC,MAAAD,aAAY,SAAS,MAAM,iCAAIC,aAAJ,EAAe,WAAAD,WAAS,EAAC;AAAA,IACtD;AAEA,WAAOA;AAAA,EACT,CAAC;AAED,QAAM,YAAiC;AAAA,IACrC,IAAI,iBAAiB;AACnB,aAAO,eAAe;AAAA,IACxB;AAAA,IACA,IAAI,WAAW;AACb,aAAO,SAAS;AAAA,IAClB;AAAA,IACA,IAAI,SAAS;AACX,aAAO,OAAO;AAAA,IAChB;AAAA,IACA,IAAI,SAAS;AACX,aAAO,OAAO;AAAA,IAChB;AAAA,IACA,QAAQ;AAAA,MACN,IAAI,UAAU;AACZ,eAAO,OAAO;AAAA,MAChB;AAAA,MACA,IAAI,OAAO;AACT,eAAO,KAAK;AAAA,MACd;AAAA,MACA,IAAI,eAAe;AACjB,eAAO,aAAa;AAAA,MACtB;AAAA,MACA,IAAI,cAAc;AAChB,eAAO,YAAY;AAAA,MACrB;AAAA,MACA,IAAI,WAAW;AACb,eAAO,SAAS;AAAA,MAClB;AAAA,MACA,IAAI,YAAY;AACd,eAAO,UAAU;AAAA,MACnB;AAAA,MACA,IAAI,UAAU;AACZ,eAAO,QAAQ;AAAA,MACjB;AAAA,IACF;AAAA,IACA,IAAI,QAAgC;AAClC,YAAM,UAAU,MAAM,QAAQ;AAC9B,YAAM,UAAU,MAAM,QAAQ;AAE9B,aAAO,WAAW,UAAU,EAAC,SAAS,QAAO,IAAI;AAAA,IACnD;AAAA,IACA,IAAI,MAAM,OAAqB;AApMnC;AAqMM,UAAI,WAAS,WAAM,QAAQ,KAAK,MAAnB,mBAAsB,OAAO,SAAQ;AAChD;AAAA,MACF;AAEA,YAAM,UAAU,MAAM,QAAQ,KAAK;AAEnC,UAAI,CAAC,SAAS;AACZ,cAAM,QAAQ,QAAQ;AAAA,MACxB;AAEA,YAAM,QAAQ,QAAQ;AAAA,IACxB;AAAA,IACA,IAAI,YAAY;AACd,aAAO,UAAU;AAAA,IACnB;AAAA,IACA;AAAA,EACF;AAEA,QAAM,QAAQ,MAAM;AAClB,UAAM,MAAM;AACV,aAAO,QAAQ;AACf,uBAAiB,QAAQ;AACzB,uBAAiB,QAAQ;AACzB,YAAM,QAAQ,QAAQ;AACtB,YAAM,QAAQ,QAAQ;AACtB,eAAS,MAAM,EAAC,GAAG,GAAG,GAAG,EAAC,CAAC;AAC3B,gBAAU,QAAQ,CAAC;AAAA,IACrB,CAAC;AAAA,EACH;AAEA,SAAO;AAAA,IACL;AAAA,IACA,SAAS;AAAA,MACP,cAAc,YAA8B;AAC1C,yBAAiB,QAAQ;AAAA,MAC3B;AAAA,MACA,cACE,YACkB;AAClB,cAAM,KAAK,kCAAc;AAEzB,YAAI,iBAAiB,KAAK,MAAM,IAAI;AAClC,iBAAO,QAAQ,QAAQ,KAAK;AAAA,QAC9B;AAEA,yBAAiB,QAAQ;AAEzB,cAAM,QAAQ,mBAAmB;AAAA,UAC/B,WAAW,SAAS,SAAS;AAAA,QAC/B,CAAC;AAED,YAAI,OAAO,KAAK,MAAM,2BAAiB;AACrC,kBAAQ,SAAS,YAAY,KAAK;AAAA,QACpC;AAEA,eAAO,QAAQ,SAAS,UAAU,KAAK,MAAM,MAAM,gBAAgB;AAAA,MACrE;AAAA,MACA,MAAM,EAAC,OAAO,YAAW,GAA6C;AACpE,cAAM,iBAAiB,OAAO,KAAK;AAEnC,YAAI,CAAC,gBAAgB;AACnB,gBAAM,IAAI;AAAA,YACR;AAAA,UACF;AAAA,QACF;AAEA,cAAM,MAAM;AACV,gBAAM,QAAQ,QAAQ;AACtB,gBAAM,QAAQ,QAAQ;AACtB,oBAAU,QAAQ;AAClB,mBAAS,QAAQ;AACjB,yBAAe,QAAQ;AACvB,mBAAS,MAAM,WAAW;AAAA,QAC5B,CAAC;AAED,cAAM,mBAAmB,mBAAmB;AAAA,UAC1C,WAAW,SAAS,SAAS;AAAA,QAC/B,CAAC;AAED,gBAAQ,SAAS,mBAAmB,gBAAgB;AAEpD,gBAAQ,SAAS,UAAU,KAAK,MAAM;AACpC,cAAI,iBAAiB,kBAAkB;AACrC,kBAAM;AACN;AAAA,UACF;AAEA,iBAAO,QAAQ;AAEf,gCAAsB,MAAM;AAC1B,mBAAO,QAAQ;AAEf,oBAAQ,SAAS,aAAa;AAAA,cAC5B,WAAW,SAAS,SAAS;AAAA,cAC7B,YAAY;AAAA,YACd,CAAC;AAAA,UACH,CAAC;AAAA,QACH,CAAC;AAAA,MACH;AAAA,MACA,KAAK;AAAA,QACH;AAAA,QACA;AAAA,QACA,aAAa;AAAA,MACf,GAE6D;AAC3D,YAAI,CAAC,SAAS,KAAK,GAAG;AACpB;AAAA,QACF;AAEA,cAAM,QAAQ;AAAA,UACZ;AAAA,YACE,WAAW,SAAS,SAAS;AAAA,YAC7B;AAAA,YACA;AAAA,UACF;AAAA,UACA;AAAA,QACF;AAEA,gBAAQ,SAAS,YAAY,KAAK;AAElC,uBAAe,MAAM;AACnB,cAAI,MAAM,kBAAkB;AAC1B;AAAA,UACF;AAEA,gBAAM,cAAc,kBAAM;AAAA,YACxB,GAAG,SAAS,QAAQ,IAAI,GAAG;AAAA,YAC3B,GAAG,SAAS,QAAQ,IAAI,GAAG;AAAA,UAC7B;AAEA,mBAAS,OAAO,WAAW;AAAA,QAC7B,CAAC;AAAA,MACH;AAAA,MACA,KAAK,EAAC,UAAU,gBAAgB,MAAK,IAA0B,CAAC,GAAG;AACjE,YAAI;AACJ,cAAM,UAAU,MAAM;AACpB,gBAAM,SAAS;AAAA,YACb,QAAQ,MAAM;AAAA,YAAC;AAAA,YACf,OAAO,MAAM;AAAA,YAAC;AAAA,UAChB;AAEA,oBAAU,IAAI,QAAc,CAAC,SAAS,WAAW;AAC/C,mBAAO,SAAS;AAChB,mBAAO,QAAQ;AAAA,UACjB,CAAC;AAED,iBAAO;AAAA,QACT;AACA,cAAM,MAAM,MAAM;AAEhB,kBAAQ,SAAS,UAAU,KAAK,MAAM;AACpC,mBAAO,QAAQ;AACf,oBAAQ,SAAS,UAAU,KAAK,KAAK;AAAA,UACvC,CAAC;AAAA,QACH;AAEA,cAAM,MAAM;AACV,oBAAU,QAAQ;AAClB,mBAAS,QAAQ;AAAA,QACnB,CAAC;AAED,gBAAQ,SAAS,WAAW;AAAA,UAC1B,WAAW,SAAS,SAAS;AAAA,UAC7B,UAAU;AAAA,UACV;AAAA,QACF,CAAC;AAED,YAAI,SAAS;AACX,kBAAQ,KAAK,GAAG,EAAE,MAAM,KAAK;AAAA,QAC/B,OAAO;AACL,cAAI;AAAA,QACN;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAEA,SAAS,SAAwC,KAAW;AAC1D,SAAO,mBACF;AAEP;;;ACvXO,IAAM,kBAA4B;AAAA,EACvC,IAAI,YAAY;AACd,WAAO,QAAQ,QAAQ;AAAA,EACzB;AACF;;;ACcO,IAAM,kBAAN,MAAgE;AAAA,EAQrE,YAAY,QAAoC;AAG9C,UAAM;AAAA,MACJ,UAAU,CAAC;AAAA,MACX,UAAU,CAAC;AAAA,MACX,YAAY,CAAC;AAAA,MACb,WAAW;AAAA,IACb,IAAI,0BAAU,CAAC;AACf,UAAM,UAAU,IAAI,gBAAyB,IAAI;AACjD,UAAM,WAAW,IAAI,iBAA0B,IAAI;AAEnD,SAAK,WAAW;AAChB,SAAK,UAAU;AACf,SAAK,WAAW;AAEhB,UAAM,EAAC,SAAS,UAAS,IAAI,qBAA8B,IAAI;AAE/D,SAAK,UAAU;AACf,SAAK,gBAAgB;AACrB,SAAK,oBAAoB,IAAI,kBAA2B,IAAI;AAC5D,SAAK,UAAU,CAAC,mBAAmB,GAAG,OAAO;AAC7C,SAAK,YAAY;AACjB,SAAK,UAAU;AACf,SAAK,UAAU,KAAK,QAAQ,KAAK,IAAI;AAAA,EACvC;AAAA,EAEA,IAAI,UAAyB;AAC3B,WAAO,KAAK,SAAS,QAAQ;AAAA,EAC/B;AAAA,EAEA,IAAI,QAAQ,SAAuB;AACjC,SAAK,SAAS,QAAQ,SAAS;AAAA,EACjC;AAAA,EAEA,IAAI,YAA6B;AAC/B,WAAO,KAAK,SAAS,UAAU;AAAA,EACjC;AAAA,EAEA,IAAI,UAAU,WAA2B;AACvC,SAAK,SAAS,UAAU,SAAS;AAAA,EACnC;AAAA,EAEA,IAAI,UAAyB;AAC3B,WAAO,KAAK,SAAS,QAAQ;AAAA,EAC/B;AAAA,EAEA,IAAI,QAAQ,SAAuB;AACjC,SAAK,SAAS,QAAQ,SAAS;AAAA,EACjC;AAAA,EAEO,UAAU;AACf,SAAK,SAAS,QAAQ;AACtB,SAAK,kBAAkB,QAAQ;AAAA,EACjC;AACF","sourcesContent":["import {signal, untracked, type Signal, effects} from '@dnd-kit/state';\nimport type {Coordinates} from '@dnd-kit/geometry';\n\nimport type {DragDropManager} from '../manager/index.ts';\nimport type {Draggable, Droppable} from '../entities/index.ts';\nimport {Plugin} from '../plugins/index.ts';\nimport type {Collision, CollisionDetector, Collisions} from './types.ts';\nimport {sortCollisions} from './utilities.ts';\n\nconst DEFAULT_VALUE: Collisions = [];\n\nexport class CollisionObserver<\n  T extends Draggable = Draggable,\n  U extends Droppable = Droppable,\n  V extends DragDropManager<T, U> = DragDropManager<T, U>,\n> extends Plugin<V> {\n  constructor(manager: V) {\n    super(manager);\n\n    this.computeCollisions = this.computeCollisions.bind(this);\n    this.#collisions = signal(DEFAULT_VALUE);\n\n    this.destroy = effects(\n      () => {\n        const collisions = this.computeCollisions();\n        const coordinates = untracked(\n          () => this.manager.dragOperation.position.current\n        );\n        const previousCoordinates = this.#previousCoordinates;\n\n        this.#previousCoordinates = coordinates;\n\n        if (\n          previousCoordinates &&\n          coordinates.x == previousCoordinates.x &&\n          coordinates.y == previousCoordinates.y\n        ) {\n          return;\n        }\n\n        this.#collisions.value = collisions;\n      },\n      () => {\n        const {dragOperation} = this.manager;\n\n        if (dragOperation.status.initialized) {\n          this.forceUpdate();\n        }\n      }\n    );\n  }\n\n  #previousCoordinates: Coordinates | undefined;\n\n  public forceUpdate(immediate = true) {\n    untracked(() => {\n      if (immediate) {\n        this.#collisions.value = this.computeCollisions();\n      } else {\n        this.#previousCoordinates = undefined;\n      }\n    });\n  }\n\n  public computeCollisions(\n    entries?: Droppable[],\n    collisionDetector?: CollisionDetector\n  ) {\n    const {registry, dragOperation} = this.manager;\n    const {source, shape, status} = dragOperation;\n\n    if (!status.initialized || !shape) {\n      return DEFAULT_VALUE;\n    }\n\n    const collisions: Collision[] = [];\n\n    for (const entry of entries ?? registry.droppables) {\n      if (entry.disabled) {\n        continue;\n      }\n\n      if (source && !entry.accepts(source)) {\n        continue;\n      }\n\n      const detectCollision = collisionDetector ?? entry.collisionDetector;\n\n      if (!detectCollision) {\n        continue;\n      }\n\n      entry.shape;\n      const collision = untracked(() =>\n        detectCollision({\n          droppable: entry,\n          dragOperation,\n        })\n      );\n\n      if (collision) {\n        if (entry.collisionPriority != null) {\n          collision.priority = entry.collisionPriority;\n        }\n\n        collisions.push(collision);\n      }\n    }\n\n    collisions.sort(sortCollisions);\n\n    return collisions;\n  }\n\n  public get collisions() {\n    return this.#collisions.value;\n  }\n\n  #collisions: Signal<Collisions>;\n}\n","import {reactive, untracked} from '@dnd-kit/state';\n\nimport type {DragDropManager} from '../manager/index.ts';\nimport type {PluginOptions} from './types.ts';\nimport {configure} from './utilities.ts';\n\n/**\n * An abstract plugin class that can be extended to implement custom\n * functionality that augments the `DragDropManager`'s core capabilities.\n */\nexport abstract class Plugin<\n  T extends DragDropManager<any, any> = DragDropManager<any, any>,\n  U extends PluginOptions = PluginOptions,\n> {\n  constructor(\n    public manager: T,\n    public options?: U\n  ) {}\n\n  /**\n   * Whether the plugin instance is disabled.\n   * Triggers effects when accessed.\n   */\n  @reactive\n  public accessor disabled: boolean = false;\n\n  /**\n   * Enable a disabled plugin instance.\n   * Triggers effects.\n   */\n  public enable() {\n    this.disabled = false;\n  }\n\n  /**\n   * Disable an enabled plugin instance.\n   * Triggers effects.\n   */\n  public disable() {\n    this.disabled = true;\n  }\n\n  /**\n   * Whether the plugin instance is disabled.\n   * Does not trigger effects when accessed.\n   */\n  public isDisabled() {\n    return untracked(() => {\n      return this.disabled;\n    });\n  }\n\n  /**\n   * Configure a plugin instance with new options.\n   */\n  public configure(options?: U) {\n    this.options = options;\n  }\n\n  /**\n   * Destroy a plugin instance.\n   */\n  public destroy() {\n    /*\n     * Each plugin is responsible for implementing its own\n     * destroy method to clean up effects and listeners\n     */\n  }\n\n  /**\n   * Configure a plugin constructor with options.\n   * This method is used to configure the options that the\n   * plugin constructor will use to create plugin instances.\n   */\n  static configure(options: PluginOptions) {\n    return configure(this as any, options);\n  }\n}\n\nexport class CorePlugin<\n  T extends DragDropManager<any, any> = DragDropManager<any, any>,\n  U extends PluginOptions = PluginOptions,\n> extends Plugin<T, U> {}\n","import type {\n  PluginConstructor,\n  PluginOptions,\n  PluginDescriptor,\n  InferPluginOptions,\n} from './types.ts';\n\nexport function configure<\n  T extends PluginConstructor<any, any, any>,\n  V extends PluginOptions = InferPluginOptions<T>,\n>(plugin: T, options: V): PluginDescriptor<any, any, T> {\n  return {\n    plugin,\n    options,\n  };\n}\n\nexport function configurator<T extends PluginConstructor<any, any, any>>(\n  plugin: T\n) {\n  return (options: InferPluginOptions<T>): PluginDescriptor<any, any, T> => {\n    return configure(plugin, options);\n  };\n}\n\nexport function descriptor<T extends PluginConstructor<any, any, any>>(\n  plugin: T | PluginDescriptor<any, any, T>\n): PluginDescriptor<any, any, T> {\n  if (typeof plugin === 'function') {\n    return {\n      plugin,\n      options: undefined,\n    };\n  }\n\n  return plugin;\n}\n","import {DragDropManager} from '../manager/index.ts';\nimport {CorePlugin, type Plugin} from './plugin.ts';\nimport type {\n  InferPluginOptions,\n  PluginDescriptor,\n  PluginConstructor,\n  Plugins,\n} from './types.ts';\nimport {descriptor} from './utilities.ts';\n\nexport class PluginRegistry<\n  T extends DragDropManager<any, any>,\n  W extends PluginConstructor<T> = PluginConstructor<T>,\n  U extends Plugin<T> = InstanceType<W>,\n> {\n  private instances: Map<W, U> = new Map();\n\n  constructor(private manager: T) {}\n\n  public get values(): U[] {\n    return Array.from(this.instances.values());\n  }\n\n  #previousValues: PluginConstructor<T>[] = [];\n\n  public set values(entries: Plugins<T>) {\n    const descriptors = entries\n      .map(descriptor)\n      .reduceRight<PluginDescriptor<T>[]>((acc, descriptor) => {\n        if (acc.some(({plugin}) => plugin === descriptor.plugin)) {\n          // Filter out duplicate plugins\n          return acc;\n        }\n\n        return [descriptor, ...acc];\n      }, []);\n    const constructors = descriptors.map(({plugin}) => plugin);\n\n    for (const plugin of this.#previousValues) {\n      if (!constructors.includes(plugin)) {\n        if (plugin.prototype instanceof CorePlugin) {\n          continue;\n        }\n\n        this.unregister(plugin as W);\n      }\n    }\n\n    for (const {plugin, options} of descriptors) {\n      this.register(plugin as W, options as InferPluginOptions<W>);\n    }\n\n    this.#previousValues = constructors;\n  }\n\n  public get<X extends W>(plugin: X): InstanceType<X> | undefined {\n    const instance = this.instances.get(plugin);\n\n    return instance as any;\n  }\n\n  public register<X extends W>(\n    plugin: X,\n    options?: InferPluginOptions<X>\n  ): InstanceType<X> {\n    const existingInstance = this.instances.get(plugin);\n\n    if (existingInstance) {\n      return existingInstance as InstanceType<X>;\n    }\n\n    const instance = new plugin(this.manager, options) as U;\n\n    this.instances.set(plugin, instance);\n\n    return instance as InstanceType<X>;\n  }\n\n  public unregister<X extends W>(plugin: X) {\n    const instance = this.instances.get(plugin);\n\n    if (instance) {\n      instance.destroy();\n      this.instances.delete(plugin);\n    }\n  }\n\n  public destroy() {\n    for (const plugin of this.instances.values()) {\n      plugin.destroy();\n    }\n\n    this.instances.clear();\n  }\n}\n","import {Collision} from './types.ts';\n\n/**\n * Sort collisions from greatest to smallest priority\n * Collisions of equal priority are sorted from greatest to smallest value\n */\nexport function sortCollisions(a: Collision, b: Collision) {\n  if (a.priority === b.priority) {\n    if (a.type === b.type) {\n      return b.value - a.value;\n    }\n\n    return b.type - a.type;\n  }\n\n  return b.priority - a.priority;\n}\n","import {effect, effects, untracked} from '@dnd-kit/state';\n\nimport {DragDropManager} from '../manager/index.ts';\nimport {CorePlugin} from '../plugins/index.ts';\nimport {defaultPreventable} from '../manager/events.ts';\n\nimport type {Collision} from './types.ts';\n\nexport class CollisionNotifier extends CorePlugin {\n  constructor(manager: DragDropManager<any, any>) {\n    super(manager);\n\n    const isEqual = (a: Collision[], b: Collision[]) =>\n      a.map(({id}) => id).join('') === b.map(({id}) => id).join('');\n\n    let previousCollisions: Collision[] = [];\n\n    this.destroy = effects(\n      () => {\n        const {dragOperation, collisionObserver} = manager;\n\n        if (dragOperation.status.initializing) {\n          previousCollisions = [];\n          collisionObserver.enable();\n        }\n      },\n      () => {\n        const {collisionObserver, monitor} = manager;\n        const {collisions} = collisionObserver;\n\n        if (collisionObserver.isDisabled()) {\n          return;\n        }\n\n        const event = defaultPreventable({\n          collisions,\n        });\n\n        monitor.dispatch('collision', event);\n\n        if (event.defaultPrevented) {\n          return;\n        }\n\n        if (isEqual(collisions, previousCollisions)) {\n          return;\n        } else {\n          previousCollisions = collisions;\n        }\n\n        const [firstCollision] = collisions;\n\n        untracked(() => {\n          if (firstCollision?.id !== manager.dragOperation.target?.id) {\n            collisionObserver.disable();\n\n            manager.actions.setDropTarget(firstCollision?.id).then(() => {\n              collisionObserver.enable();\n            });\n          }\n        });\n      }\n    );\n  }\n}\n","import type {Coordinates} from '@dnd-kit/geometry';\n\nimport type {Draggable, Droppable} from '../entities/index.ts';\nimport type {Collisions} from '../collision/index.ts';\nimport type {DragDropManager} from './manager.ts';\nimport type {DragOperation} from './dragOperation.ts';\n\nexport type Events = Record<string, (...args: any[]) => void>;\n\nexport type Preventable<T> = T & {\n  cancelable: boolean;\n  defaultPrevented: boolean;\n  preventDefault(): void;\n};\n\nclass Monitor<T extends Events> {\n  private registry = new Map<keyof T, Set<T[keyof T]>>();\n\n  public addEventListener<U extends keyof T>(name: U, handler: T[U]) {\n    const {registry} = this;\n    const listeners = new Set(registry.get(name));\n\n    listeners.add(handler);\n    registry.set(name, listeners);\n\n    return () => this.removeEventListener(name, handler);\n  }\n\n  public removeEventListener(name: keyof T, handler: T[keyof T]) {\n    const {registry} = this;\n    const listeners = new Set(registry.get(name));\n\n    listeners.delete(handler);\n    registry.set(name, listeners);\n  }\n\n  protected dispatch<U extends keyof T>(name: U, ...args: any[]) {\n    const {registry} = this;\n    const listeners = registry.get(name);\n\n    if (!listeners) {\n      return;\n    }\n\n    for (const listener of listeners) {\n      listener(...args);\n    }\n  }\n}\n\nexport type DragDropEvents<\n  T extends Draggable,\n  U extends Droppable,\n  V extends DragDropManager<T, U>,\n> = {\n  collision(\n    event: Preventable<{\n      collisions: Collisions;\n    }>,\n    manager: V\n  ): void;\n  beforedragstart(\n    event: Preventable<{operation: DragOperation<T, U>}>,\n    manager: V\n  ): void;\n  dragstart(\n    event: {\n      cancelable: false;\n      operation: DragOperation<T, U>;\n    },\n    manager: V\n  ): void;\n  dragmove(\n    event: Preventable<{\n      operation: DragOperation<T, U>;\n      to?: Coordinates;\n      by?: Coordinates;\n    }>,\n    manager: V\n  ): void;\n  dragover(\n    event: Preventable<{\n      operation: DragOperation<T, U>;\n    }>,\n    manager: V\n  ): void;\n  dragend(\n    event: {\n      operation: DragOperation<T, U>;\n      canceled: boolean;\n      suspend(): {resume(): void; abort(): void};\n    },\n    manager: V\n  ): void;\n};\n\nexport class DragDropMonitor<\n  T extends Draggable,\n  U extends Droppable,\n  V extends DragDropManager<T, U>,\n> extends Monitor<DragDropEvents<T, U, V>> {\n  constructor(private manager: V) {\n    super();\n  }\n\n  public dispatch<Key extends keyof DragDropEvents<T, U, V>>(\n    type: Key,\n    event: Parameters<DragDropEvents<T, U, V>[Key]>[0]\n  ) {\n    const args = [event, this.manager] as any;\n\n    super.dispatch(type, ...args);\n  }\n}\n\nexport function defaultPreventable<T>(\n  event: T,\n  cancelable = true\n): Preventable<T> {\n  let defaultPrevented = false;\n\n  return {\n    ...event,\n    cancelable,\n    get defaultPrevented() {\n      return defaultPrevented;\n    },\n    preventDefault() {\n      if (!cancelable) {\n        return;\n      }\n\n      defaultPrevented = true;\n    },\n  };\n}\n","import type {DragOperation} from '../manager/index.ts';\nimport type {\n  Draggable,\n  Droppable,\n  UniqueIdentifier,\n} from '../entities/index.ts';\n\nexport enum CollisionPriority {\n  Lowest,\n  Low,\n  Normal,\n  High,\n  Highest,\n}\n\nexport enum CollisionType {\n  Collision,\n  ShapeIntersection,\n  PointerIntersection,\n}\n\nexport interface Collision {\n  id: UniqueIdentifier;\n  priority: CollisionPriority | number;\n  type: CollisionType;\n  value: number;\n}\n\nexport type Collisions = Collision[];\n\nexport interface CollisionDetectorInput<\n  T extends Draggable = Draggable,\n  U extends Droppable = Droppable,\n> {\n  droppable: U;\n  dragOperation: DragOperation<T, U>;\n}\n\nexport type CollisionDetector = <\n  T extends Draggable = Draggable,\n  U extends Droppable = Droppable,\n>(\n  input: CollisionDetectorInput<T, U>\n) => Collision | null;\n","import {CleanupFunction, reactive, type Effect} from '@dnd-kit/state';\n\nimport {DragDropManager} from '../../manager/index.ts';\nimport type {Data, UniqueIdentifier} from './types.ts';\n\nexport interface Input<T extends Data = Data> {\n  id: UniqueIdentifier;\n  data?: T;\n  disabled?: boolean;\n  effects?(): Effect[];\n}\n\n/**\n * The `Entity` class is an abstract representation of a distinct unit in the drag and drop system.\n * It is a base class that other concrete classes like `Draggable` and `Droppable` can extend.\n *\n * @template T - The type of data associated with the entity.\n */\nexport class Entity<\n  T extends Data = Data,\n  U extends DragDropManager<any, any> = DragDropManager<any, any>,\n> {\n  /**\n   * Creates a new instance of the `Entity` class.\n   *\n   * @param input - An object containing the initial properties of the entity.\n   * @param manager - The manager that controls the drag and drop operations.\n   */\n  constructor(input: Input<T>, manager: U | undefined) {\n    const {effects, id, data = {}, disabled = false} = input;\n\n    let previousId = id;\n\n    this.manager = manager;\n    this.id = id;\n    this.data = data;\n    this.disabled = disabled;\n    this.effects = () => [\n      () => {\n        // Re-run this effect whenever the `id` changes\n        const {id, manager} = this;\n\n        if (id === previousId) {\n          return;\n        }\n\n        manager?.registry.register(this);\n\n        return () => manager?.registry.unregister(this);\n      },\n      ...(effects?.() ?? []),\n    ];\n    this.destroy = this.destroy.bind(this);\n\n    if (manager) {\n      queueMicrotask(() => {\n        this.manager?.registry.register(this);\n      });\n    }\n  }\n\n  /**\n   * The manager that controls the drag and drop operations.\n   */\n  @reactive\n  public accessor manager: U | undefined;\n\n  /**\n   * The unique identifier of the entity.\n   */\n  @reactive\n  public accessor id: UniqueIdentifier;\n\n  /**\n   * The data associated with the entity.\n   */\n  @reactive\n  public accessor data: Data;\n\n  /**\n   * A boolean indicating whether the entity is disabled.\n   */\n  @reactive\n  public accessor disabled: boolean;\n\n  /**\n   * An array of effects that are applied to the entity.\n   */\n  public effects: () => Effect[];\n\n  /**\n   * A method that registers the entity with the manager.\n   * @returns CleanupFunction | void\n   */\n  public register(): CleanupFunction | void {\n    return this.manager?.registry.register(this);\n  }\n\n  /**\n   * A method that unregisters the entity from the manager.\n   * @returns void\n   */\n  public unregister(): void {\n    this.manager?.registry.unregister(this);\n  }\n\n  /**\n   * A method that cleans up the entity when it is no longer needed.\n   * @returns void\n   */\n  public destroy(): void {\n    this.manager?.registry.unregister(this);\n  }\n}\n","import {effects, signal} from '@dnd-kit/state';\n\nimport type {Entity} from './entity.ts';\nimport type {UniqueIdentifier} from './types.ts';\n\n/**\n * Reactive class representing a registry for entities.\n * @template T - The type of entries that the registry manages,\n * for example, `Draggable` or `Droppable` entities.\n */\nexport class EntityRegistry<T extends Entity> {\n  private map = signal<Map<UniqueIdentifier, T>>(new Map());\n  private cleanupFunctions = new WeakMap<T, () => void>();\n\n  /**\n   * Iterator for the EntityRegistry class.\n   * @returns An iterator for the values in the map.\n   */\n  public [Symbol.iterator]() {\n    return this.map.peek().values();\n  }\n\n  public get value() {\n    return this.map.value.values();\n  }\n\n  /**\n   * Checks if a entity with the given identifier exists in the registry.\n   * @param identifier - The unique identifier of the entity.\n   * @returns True if the entity exists, false otherwise.\n   */\n  public has(identifier: UniqueIdentifier): boolean {\n    return this.map.value.has(identifier);\n  }\n\n  /**\n   * Retrieves a entity from the registry using its identifier.\n   * @param identifier - The unique identifier of the entity.\n   * @returns The entity if it exists, undefined otherwise.\n   */\n  public get(identifier: UniqueIdentifier): T | undefined {\n    return this.map.value.get(identifier);\n  }\n\n  /**\n   * Registers a entity in the registry.\n   * @param key - The unique identifier of the entity.\n   * @param value - The entity to register.\n   * @returns A function that unregisters the entity.\n   */\n  public register = (key: UniqueIdentifier, value: T) => {\n    const current = this.map.peek();\n    const currentValue = current.get(key);\n\n    if (currentValue === value) {\n      return;\n    }\n\n    if (currentValue) {\n      const cleanup = this.cleanupFunctions.get(currentValue);\n      cleanup?.();\n      this.cleanupFunctions.delete(currentValue);\n    }\n\n    const updatedMap = new Map(current);\n    updatedMap.set(key, value);\n\n    this.map.value = updatedMap;\n\n    const cleanup = effects(...value.effects());\n    this.cleanupFunctions.set(value, cleanup);\n\n    return () => this.unregister(key, value);\n  };\n\n  /**\n   * Unregisters an entity from the registry.\n   * @param key - The unique identifier of the entity.\n   * @param value - The entity instance to unregister.\n   */\n  public unregister = (key: UniqueIdentifier, value: T) => {\n    const current = this.map.peek();\n\n    if (current.get(key) !== value) {\n      return;\n    }\n\n    const cleanup = this.cleanupFunctions.get(value);\n    cleanup?.();\n    this.cleanupFunctions.delete(value);\n\n    const updatedMap = new Map(current);\n    updatedMap.delete(key);\n\n    this.map.value = updatedMap;\n  };\n\n  /**\n   * Destroys all entries in the registry and clears the registry.\n   */\n  public destroy() {\n    for (const entry of this) {\n      const cleanup = this.cleanupFunctions.get(entry);\n      cleanup?.();\n      entry.destroy();\n    }\n\n    this.map.value = new Map();\n  }\n}\n","import {derived, reactive} from '@dnd-kit/state';\n\nimport {Entity} from '../entity/index.ts';\nimport type {EntityInput, Data, Type} from '../entity/index.ts';\nimport type {Modifiers} from '../../modifiers/index.ts';\nimport type {DragDropManager} from '../../manager/index.ts';\nimport type {Sensors} from '../../sensors/sensor.ts';\n\nexport interface Input<T extends Data = Data> extends EntityInput<T> {\n  type?: Type;\n  modifiers?: Modifiers;\n  sensors?: Sensors;\n}\n\nexport type DraggableStatus = 'idle' | 'dragging' | 'dropping';\n\nexport class Draggable<\n  T extends Data = Data,\n  U extends DragDropManager<any, any> = DragDropManager<any, any>,\n> extends Entity<T, U> {\n  constructor(\n    {modifiers, type, sensors, ...input}: Input<T>,\n    manager: U | undefined\n  ) {\n    super(input, manager);\n\n    this.type = type;\n    this.sensors = sensors;\n    this.modifiers = modifiers;\n  }\n\n  public sensors: Sensors | undefined;\n\n  @reactive\n  public accessor modifiers: Modifiers | undefined;\n\n  @reactive\n  public accessor type: Type | undefined;\n\n  @reactive\n  public accessor status: DraggableStatus = 'idle';\n\n  /**\n   * A boolean indicating whether the draggable item is the source of a drag operation.\n   */\n  @derived\n  public get isDragSource() {\n    return this.manager?.dragOperation.source?.id === this.id;\n  }\n}\n","import {derived, effects, reactive, type Effect} from '@dnd-kit/state';\nimport type {Shape} from '@dnd-kit/geometry';\n\nimport {Entity} from '../entity/index.ts';\nimport type {EntityInput, Data, Type} from '../entity/index.ts';\nimport {\n  CollisionPriority,\n  type CollisionDetector,\n} from '../../collision/index.ts';\nimport type {DragDropManager} from '../../manager/index.ts';\nimport {Draggable} from '../draggable/draggable.ts';\n\nexport interface Input<T extends Data = Data> extends EntityInput<T> {\n  accept?: Type | Type[] | ((source: Draggable) => boolean);\n  collisionPriority?: CollisionPriority | number;\n  collisionDetector: CollisionDetector;\n  type?: Type;\n}\n\nexport class Droppable<\n  T extends Data = Data,\n  U extends DragDropManager<any, any> = DragDropManager<any, any>,\n> extends Entity<T, U> {\n  constructor(\n    {accept, collisionDetector, collisionPriority, type, ...input}: Input<T>,\n    manager: U | undefined\n  ) {\n    super(input, manager);\n\n    this.accept = accept;\n    this.collisionDetector = collisionDetector;\n    this.collisionPriority = collisionPriority;\n    this.type = type;\n  }\n\n  /**\n   * An array of types that are compatible with the droppable.\n   */\n  @reactive\n  public accessor accept:\n    | Type\n    | Type[]\n    | ((draggable: Draggable) => boolean)\n    | undefined;\n\n  /**\n   * The type of the droppable.\n   */\n  @reactive\n  public accessor type: Type | undefined;\n\n  /**\n   * Checks whether or not the droppable accepts a given draggable.\n   *\n   * @param {Draggable} draggable\n   * @returns {boolean}\n   */\n  public accepts(draggable: Draggable): boolean {\n    const {accept} = this;\n\n    if (!accept) {\n      return true;\n    }\n\n    if (typeof accept === 'function') {\n      return accept(draggable);\n    }\n\n    if (!draggable.type) {\n      return false;\n    }\n\n    if (Array.isArray(accept)) {\n      return accept.includes(draggable.type);\n    }\n\n    return draggable.type === accept;\n  }\n\n  @reactive\n  public accessor collisionDetector: CollisionDetector;\n\n  @reactive\n  public accessor collisionPriority: CollisionPriority | number | undefined;\n\n  @reactive\n  public accessor shape: Shape | undefined;\n\n  @derived\n  public get isDropTarget() {\n    return this.manager?.dragOperation.target?.id === this.id;\n  }\n}\n","import {CleanupFunction} from '@dnd-kit/state';\n\nimport type {DragDropManager} from '../manager/index.ts';\nimport type {Draggable, Droppable} from '../entities/index.ts';\nimport {\n  Plugin,\n  type PluginConstructor,\n  type PluginDescriptor,\n  type PluginOptions,\n} from '../plugins/index.ts';\n\nexport type SensorOptions = PluginOptions;\n\nexport abstract class Sensor<\n  T extends DragDropManager<any, any> = DragDropManager<Draggable, Droppable>,\n  U extends SensorOptions = SensorOptions,\n> extends Plugin<T, U> {\n  constructor(\n    public manager: T,\n    public options?: U\n  ) {\n    super(manager, options);\n  }\n\n  /**\n   * Bind the sensor to a draggable source, and optionally pass\n   * in sensor options to override the default sensor options\n   * for this draggable source only.\n   */\n  public abstract bind(source: Draggable, options?: U): CleanupFunction;\n}\n\nexport type SensorConstructor<\n  T extends DragDropManager<any, any> = DragDropManager<any, any>,\n> = PluginConstructor<T, Sensor<T>>;\n\nexport type SensorDescriptor<\n  T extends DragDropManager<any, any> = DragDropManager<any, any>,\n> = PluginDescriptor<T, Sensor<T>, SensorConstructor<T>>;\n\nexport type Sensors<\n  T extends DragDropManager<any, any> = DragDropManager<any, any>,\n> = (SensorConstructor<T> | SensorDescriptor<T>)[];\n","import type {Coordinates} from '@dnd-kit/geometry';\n\nimport {\n  Plugin,\n  type PluginOptions,\n  type PluginConstructor,\n  type PluginDescriptor,\n} from '../plugins/index.ts';\nimport type {DragDropManager} from '../manager/index.ts';\n\nexport type ModifierOptions = PluginOptions;\n\nexport class Modifier<\n  T extends DragDropManager<any, any> = DragDropManager<any, any>,\n  U extends ModifierOptions = ModifierOptions,\n> extends Plugin<T, U> {\n  constructor(\n    public manager: T,\n    public options?: U\n  ) {\n    super(manager, options);\n  }\n\n  public apply(operation: T['dragOperation']): Coordinates {\n    return operation.transform;\n  }\n}\n\nexport type ModifierConstructor<\n  T extends DragDropManager<any, any> = DragDropManager<any, any>,\n> = PluginConstructor<T, Modifier<T, any>>;\n\nexport type ModifierDescriptor<\n  T extends DragDropManager<any, any> = DragDropManager<any, any>,\n> = PluginDescriptor<T, Modifier<T, any>, ModifierConstructor<T>>;\n\nexport type Modifiers<\n  T extends DragDropManager<any, any> = DragDropManager<any, any>,\n> = (ModifierConstructor<T> | ModifierDescriptor<T>)[];\n","import type {CleanupFunction} from '@dnd-kit/state';\n\nimport {\n  Draggable,\n  Droppable,\n  Entity,\n  EntityRegistry,\n} from '../entities/index.ts';\nimport {\n  PluginRegistry,\n  Plugin,\n  type PluginConstructor,\n  PluginOptions,\n} from '../plugins/index.ts';\nimport {\n  Sensor,\n  SensorOptions,\n  type SensorConstructor,\n} from '../sensors/index.ts';\nimport {Modifier, type ModifierConstructor} from '../modifiers/index.ts';\nimport type {DragDropManager} from './manager.ts';\n\nexport class DragDropRegistry<\n  T extends Draggable,\n  U extends Droppable,\n  V extends DragDropManager<T, U>,\n> {\n  constructor(manager: V) {\n    this.plugins = new PluginRegistry<V, PluginConstructor<V>>(manager);\n    this.sensors = new PluginRegistry<V, SensorConstructor<V>>(manager);\n    this.modifiers = new PluginRegistry<V, ModifierConstructor<V>>(manager);\n  }\n\n  public draggables = new EntityRegistry<T>();\n  public droppables = new EntityRegistry<U>();\n  public plugins: PluginRegistry<V, PluginConstructor<V>>;\n  public sensors: PluginRegistry<V, SensorConstructor<V>>;\n  public modifiers: PluginRegistry<V, ModifierConstructor<V>>;\n\n  public register(input: Entity): () => void;\n  public register(input: Draggable): () => void;\n  public register(input: Droppable): () => void;\n  public register(input: SensorConstructor, options?: SensorOptions): Sensor;\n  public register(input: ModifierConstructor): Modifier;\n  public register(input: PluginConstructor, options?: PluginOptions): Plugin;\n  public register(input: any, options?: Record<string, any>) {\n    if (input instanceof Draggable) {\n      return this.draggables.register(input.id, input as T);\n    }\n\n    if (input instanceof Droppable) {\n      return this.droppables.register(input.id, input as U);\n    }\n\n    if (input.prototype instanceof Modifier) {\n      return this.modifiers.register(input, options);\n    }\n\n    if (input.prototype instanceof Sensor) {\n      return this.sensors.register(input, options);\n    }\n\n    if (input.prototype instanceof Plugin) {\n      return this.plugins.register(input, options);\n    }\n\n    throw new Error('Invalid instance type');\n  }\n\n  public unregister(input: Entity): CleanupFunction;\n  public unregister(input: Draggable): CleanupFunction;\n  public unregister(input: Droppable): CleanupFunction;\n  public unregister(input: SensorConstructor): CleanupFunction;\n  public unregister(input: ModifierConstructor): CleanupFunction;\n  public unregister(input: PluginConstructor): CleanupFunction;\n  public unregister(input: any) {\n    if (input instanceof Entity) {\n      if (input instanceof Draggable) {\n        return this.draggables.unregister(input.id, input as T);\n      }\n\n      if (input instanceof Droppable) {\n        return this.droppables.unregister(input.id, input as U);\n      }\n\n      // no-op\n      return () => {};\n    }\n\n    if (input.prototype instanceof Modifier) {\n      return this.modifiers.unregister(input);\n    }\n\n    if (input.prototype instanceof Sensor) {\n      return this.sensors.unregister(input);\n    }\n\n    if (input.prototype instanceof Plugin) {\n      return this.plugins.unregister(input);\n    }\n\n    throw new Error('Invalid instance type');\n  }\n\n  destroy() {\n    this.draggables.destroy();\n    this.droppables.destroy();\n    this.plugins.destroy();\n    this.sensors.destroy();\n    this.modifiers.destroy();\n  }\n}\n","import {Position, type Shape} from '@dnd-kit/geometry';\nimport type {Coordinates} from '@dnd-kit/geometry';\nimport {batch, computed, effect, signal} from '@dnd-kit/state';\n\nimport type {\n  Draggable,\n  Droppable,\n  UniqueIdentifier,\n} from '../entities/index.ts';\nimport type {Modifier} from '../modifiers/index.ts';\nimport {descriptor} from '../plugins/index.ts';\n\nimport type {DragDropManager} from './manager.ts';\nimport {defaultPreventable} from './events.ts';\n\nexport enum Status {\n  Idle = 'idle',\n  Initializing = 'initializing',\n  Dragging = 'dragging',\n  Dropped = 'dropped',\n}\n\nexport type Serializable = {\n  [key: string]: string | number | null | Serializable | Serializable[];\n};\n\nexport interface DragOperation<\n  T extends Draggable = Draggable,\n  U extends Droppable = Droppable,\n> {\n  activatorEvent: Event | null;\n  canceled: boolean;\n  position: Position;\n  transform: Coordinates;\n  status: {\n    current: Status;\n    initialized: boolean;\n    initializing: boolean;\n    dragging: boolean;\n    dragended: boolean;\n    dropped: boolean;\n    idle: boolean;\n  };\n  get shape(): {\n    initial: Shape;\n    current: Shape;\n  } | null;\n  set shape(value: Shape | null);\n  source: T | null;\n  target: U | null;\n  data?: Serializable;\n}\n\nexport type DragActions<\n  T extends Draggable,\n  U extends Droppable,\n  V extends DragDropManager<T, U>,\n> = ReturnType<typeof DragOperationManager<T, U, V>>['actions'];\n\nexport function DragOperationManager<\n  T extends Draggable,\n  U extends Droppable,\n  V extends DragDropManager<T, U>,\n>(manager: V) {\n  const {\n    registry: {draggables, droppables},\n    monitor,\n  } = manager;\n  const status = signal<Status>(Status.Idle);\n  const shape = {\n    initial: signal<Shape | null>(null),\n    current: signal<Shape | null>(null),\n  };\n  const canceled = signal<boolean>(false);\n  const position = new Position({x: 0, y: 0});\n  const activatorEvent = signal<Event | null>(null);\n  const sourceIdentifier = signal<UniqueIdentifier | null>(null);\n  const targetIdentifier = signal<UniqueIdentifier | null>(null);\n  const dragging = computed(() => status.value === Status.Dragging);\n  const initialized = computed(() => status.value !== Status.Idle);\n  const initializing = computed(() => status.value === Status.Initializing);\n  const idle = computed(() => status.value === Status.Idle);\n  const dropped = computed(() => status.value === Status.Dropped);\n  const dragended = signal<boolean>(true);\n  let previousSource: T | undefined;\n  const source = computed<T | null>(() => {\n    const identifier = sourceIdentifier.value;\n\n    if (identifier == null) return null;\n\n    const value = draggables.get(identifier);\n\n    if (value) {\n      // It's possible for the source to unmount during the drag operation\n      previousSource = value;\n    }\n\n    return value ?? previousSource ?? null;\n  });\n  const target = computed<U | null>(() => {\n    const identifier = targetIdentifier.value;\n    return identifier != null ? droppables.get(identifier) ?? null : null;\n  });\n\n  const modifiers = signal<Modifier[]>([]);\n\n  effect(() => {\n    const currentModifiers = modifiers.peek();\n\n    if (currentModifiers !== manager.modifiers) {\n      currentModifiers.forEach((modifier) => modifier.destroy());\n    }\n\n    modifiers.value =\n      source.value?.modifiers?.map((modifier) => {\n        const {plugin, options} = descriptor(modifier);\n        return new plugin(manager, options);\n      }) ?? manager.modifiers;\n  });\n\n  const transform = computed(() => {\n    const {x, y} = position.delta;\n\n    let transform = {x, y};\n    const initialShape = shape.initial.peek();\n    const currentShape = shape.current.peek();\n    const operation: Omit<DragOperation<T, U>, 'transform'> = {\n      activatorEvent: activatorEvent.peek(),\n      canceled: canceled.peek(),\n      source: source.peek(),\n      target: target.peek(),\n      status: {\n        current: status.peek(),\n        idle: idle.peek(),\n        initializing: initializing.peek(),\n        initialized: initialized.peek(),\n        dragging: dragging.peek(),\n        dragended: dragended.peek(),\n        dropped: dropped.peek(),\n      },\n      shape:\n        initialShape && currentShape\n          ? {initial: initialShape, current: currentShape}\n          : null,\n      position,\n    };\n\n    for (const modifier of modifiers.value) {\n      transform = modifier.apply({...operation, transform});\n    }\n\n    return transform;\n  });\n\n  const operation: DragOperation<T, U> = {\n    get activatorEvent() {\n      return activatorEvent.value;\n    },\n    get canceled() {\n      return canceled.value;\n    },\n    get source() {\n      return source.value;\n    },\n    get target() {\n      return target.value;\n    },\n    status: {\n      get current() {\n        return status.value;\n      },\n      get idle() {\n        return idle.value;\n      },\n      get initializing() {\n        return initializing.value;\n      },\n      get initialized() {\n        return initialized.value;\n      },\n      get dragging() {\n        return dragging.value;\n      },\n      get dragended() {\n        return dragended.value;\n      },\n      get dropped() {\n        return dropped.value;\n      },\n    },\n    get shape(): DragOperation['shape'] {\n      const initial = shape.initial.value;\n      const current = shape.current.value;\n\n      return initial && current ? {initial, current} : null;\n    },\n    set shape(value: Shape | null) {\n      if (value && shape.current.peek()?.equals(value)) {\n        return;\n      }\n\n      const initial = shape.initial.peek();\n\n      if (!initial) {\n        shape.initial.value = value;\n      }\n\n      shape.current.value = value;\n    },\n    get transform() {\n      return transform.value;\n    },\n    position,\n  };\n\n  const reset = () => {\n    batch(() => {\n      status.value = Status.Idle;\n      sourceIdentifier.value = null;\n      targetIdentifier.value = null;\n      shape.current.value = null;\n      shape.initial.value = null;\n      position.reset({x: 0, y: 0});\n      modifiers.value = [];\n    });\n  };\n\n  return {\n    operation,\n    actions: {\n      setDragSource(identifier: UniqueIdentifier) {\n        sourceIdentifier.value = identifier;\n      },\n      setDropTarget(\n        identifier: UniqueIdentifier | null | undefined\n      ): Promise<boolean> {\n        const id = identifier ?? null;\n\n        if (targetIdentifier.peek() === id) {\n          return Promise.resolve(false);\n        }\n\n        targetIdentifier.value = id;\n\n        const event = defaultPreventable({\n          operation: snapshot(operation),\n        });\n\n        if (status.peek() === Status.Dragging) {\n          monitor.dispatch('dragover', event);\n        }\n\n        return manager.renderer.rendering.then(() => event.defaultPrevented);\n      },\n      start({event, coordinates}: {event: Event; coordinates: Coordinates}) {\n        const sourceInstance = source.peek();\n\n        if (!sourceInstance) {\n          throw new Error(\n            'Cannot start a drag operation without a drag source'\n          );\n        }\n\n        batch(() => {\n          shape.initial.value = null;\n          shape.current.value = null;\n          dragended.value = false;\n          canceled.value = false;\n          activatorEvent.value = event;\n          position.reset(coordinates);\n        });\n\n        const beforeStartEvent = defaultPreventable({\n          operation: snapshot(operation),\n        });\n\n        monitor.dispatch('beforedragstart', beforeStartEvent);\n\n        manager.renderer.rendering.then(() => {\n          if (beforeStartEvent.defaultPrevented) {\n            reset();\n            return;\n          }\n\n          status.value = Status.Initializing;\n\n          requestAnimationFrame(() => {\n            status.value = Status.Dragging;\n\n            monitor.dispatch('dragstart', {\n              operation: snapshot(operation),\n              cancelable: false,\n            });\n          });\n        });\n      },\n      move({\n        by,\n        to,\n        cancelable = true,\n      }:\n        | {by: Coordinates; to?: undefined; cancelable?: boolean}\n        | {by?: undefined; to: Coordinates; cancelable?: boolean}) {\n        if (!dragging.peek()) {\n          return;\n        }\n\n        const event = defaultPreventable(\n          {\n            operation: snapshot(operation),\n            by,\n            to,\n          },\n          cancelable\n        );\n\n        monitor.dispatch('dragmove', event);\n\n        queueMicrotask(() => {\n          if (event.defaultPrevented) {\n            return;\n          }\n\n          const coordinates = to ?? {\n            x: position.current.x + by.x,\n            y: position.current.y + by.y,\n          };\n\n          position.update(coordinates);\n        });\n      },\n      stop({canceled: eventCanceled = false}: {canceled?: boolean} = {}) {\n        let promise: Promise<void> | undefined;\n        const suspend = () => {\n          const output = {\n            resume: () => {},\n            abort: () => {},\n          };\n\n          promise = new Promise<void>((resolve, reject) => {\n            output.resume = resolve;\n            output.abort = reject;\n          });\n\n          return output;\n        };\n        const end = () => {\n          /* Wait for the renderer to finish rendering before finalizing the drag operation */\n          manager.renderer.rendering.then(() => {\n            status.value = Status.Dropped;\n            manager.renderer.rendering.then(reset);\n          });\n        };\n\n        batch(() => {\n          dragended.value = true;\n          canceled.value = eventCanceled;\n        });\n\n        monitor.dispatch('dragend', {\n          operation: snapshot(operation),\n          canceled: eventCanceled,\n          suspend,\n        });\n\n        if (promise) {\n          promise.then(end).catch(reset);\n        } else {\n          end();\n        }\n      },\n    },\n  };\n}\n\nfunction snapshot<T extends Record<string, any>>(obj: T): T {\n  return {\n    ...obj,\n  };\n}\n","export interface Renderer {\n  get rendering(): Promise<void>;\n}\n\nexport const defaultRenderer: Renderer = {\n  get rendering() {\n    return Promise.resolve();\n  },\n};\n","import type {Draggable, Droppable} from '../entities/index.ts';\nimport {CollisionObserver, CollisionNotifier} from '../collision/index.ts';\nimport type {Plugins, Plugin} from '../plugins/index.ts';\nimport type {Sensor, Sensors} from '../sensors/index.ts';\nimport type {Modifier, Modifiers} from '../modifiers/index.ts';\n\nimport {DragDropRegistry} from './registry.ts';\nimport {\n  DragOperationManager,\n  type DragOperation,\n  type DragActions,\n} from './dragOperation.ts';\nimport {DragDropMonitor} from './events.ts';\nimport {defaultRenderer, type Renderer} from './renderer.ts';\n\nexport type DragDropManagerInput<T extends DragDropManager<any, any>> = {\n  plugins?: Plugins<T>;\n  sensors?: Sensors<T>;\n  modifiers?: Modifiers<T>;\n  renderer?: Renderer;\n};\n\nexport class DragDropManager<T extends Draggable, U extends Droppable> {\n  public actions: DragActions<T, U, DragDropManager<T, U>>;\n  public collisionObserver: CollisionObserver<T, U>;\n  public dragOperation: DragOperation<T, U>;\n  public monitor: DragDropMonitor<T, U, DragDropManager<T, U>>;\n  public registry: DragDropRegistry<T, U, DragDropManager<T, U>>;\n  public renderer: Renderer;\n\n  constructor(config?: DragDropManagerInput<any>) {\n    type V = DragDropManager<T, U>;\n\n    const {\n      plugins = [],\n      sensors = [],\n      modifiers = [],\n      renderer = defaultRenderer,\n    } = config ?? {};\n    const monitor = new DragDropMonitor<T, U, V>(this);\n    const registry = new DragDropRegistry<T, U, V>(this);\n\n    this.registry = registry;\n    this.monitor = monitor;\n    this.renderer = renderer;\n\n    const {actions, operation} = DragOperationManager<T, U, V>(this);\n\n    this.actions = actions;\n    this.dragOperation = operation;\n    this.collisionObserver = new CollisionObserver<T, U, V>(this);\n    this.plugins = [CollisionNotifier, ...plugins];\n    this.modifiers = modifiers;\n    this.sensors = sensors;\n    this.destroy = this.destroy.bind(this);\n  }\n\n  get plugins(): Plugin<any>[] {\n    return this.registry.plugins.values;\n  }\n\n  set plugins(plugins: Plugins<any>) {\n    this.registry.plugins.values = plugins;\n  }\n\n  get modifiers(): Modifier<any>[] {\n    return this.registry.modifiers.values;\n  }\n\n  set modifiers(modifiers: Modifiers<any>) {\n    this.registry.modifiers.values = modifiers;\n  }\n\n  get sensors(): Sensor<any>[] {\n    return this.registry.sensors.values;\n  }\n\n  set sensors(sensors: Sensors<any>) {\n    this.registry.sensors.values = sensors;\n  }\n\n  public destroy() {\n    this.registry.destroy();\n    this.collisionObserver.destroy();\n  }\n}\n"]}