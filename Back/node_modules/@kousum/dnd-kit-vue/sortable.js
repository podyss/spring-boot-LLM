import { batch, deepEqual } from '@dnd-kit/state';
import { Sortable, defaultSortableTransition } from '@dnd-kit/dom/sortable';
import { useDragDropManager, useInstance } from '@kousum/dnd-kit-vue';
import { useComputed, useOnValueChange, useIsomorphicLayoutEffect, useImmediateEffect } from '@kousum/dnd-kit-vue/hooks';
import { currentValue } from '@kousum/dnd-kit-vue/utilities';

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
function useSortable(input) {
  const {
    accept,
    collisionDetector,
    collisionPriority,
    data,
    disabled,
    feedback,
    sensors,
    transition = defaultSortableTransition,
    type
  } = input;
  const manager = useDragDropManager();
  const id = currentValue(input.id);
  const group = currentValue(input.group);
  const index = currentValue(input.index);
  const handle = currentValue(input.handle);
  const element = currentValue(input.element);
  const target = currentValue(input.target);
  const sortable = useInstance((manager2) => {
    return new Sortable(
      __spreadProps(__spreadValues({}, input), {
        handle: handle.value,
        element: element.value,
        target: target.value,
        index: index.value,
        group: group.value,
        id: id.value,
        feedback
      }),
      manager2
    );
  });
  const isDropTarget = useComputed(() => sortable.value.isDropTarget);
  const isDragSource = useComputed(() => sortable.value.isDragSource);
  const status = useComputed(() => sortable.value.status);
  useOnValueChange(() => id.value, () => sortable.value.id = id.value);
  useIsomorphicLayoutEffect(() => {
    batch(() => {
      sortable.value.group = group.value;
      sortable.value.index = index.value;
    });
  }, [() => group.value, () => index.value]);
  useOnValueChange(() => type, () => sortable.value.type = type);
  useOnValueChange(
    () => accept,
    () => sortable.value.accept = accept,
    void 0,
    deepEqual
  );
  useOnValueChange(() => data, () => data && (sortable.value.data = data));
  useOnValueChange(
    () => index.value,
    () => {
      var _a;
      if (((_a = manager.value) == null ? void 0 : _a.dragOperation.status.idle) && (transition == null ? void 0 : transition.idle)) {
        sortable.value.refreshShape();
      }
    },
    useImmediateEffect
  );
  useOnValueChange(() => handle.value, () => sortable.value.handle = handle.value);
  useOnValueChange(() => element.value, () => sortable.value.element = element.value);
  useOnValueChange(() => target.value, () => sortable.value.target = target.value);
  useOnValueChange(() => disabled, () => sortable.value.disabled = disabled === true);
  useOnValueChange(() => sensors, () => sortable.value.sensors = sensors);
  useOnValueChange(
    () => collisionDetector,
    () => sortable.value.collisionDetector = collisionDetector
  );
  useOnValueChange(
    () => collisionPriority,
    () => sortable.value.collisionPriority = collisionPriority
  );
  useOnValueChange(() => feedback, () => sortable.value.feedback = feedback != null ? feedback : "default");
  useOnValueChange(() => transition, () => sortable.value.transition = transition);
  return {
    isDragSource,
    isDropTarget,
    status,
    handleRef: (element2) => {
      sortable.value.handle = element2 != null ? element2 : void 0;
    },
    ref: (element2) => {
      var _a;
      if (!element2 && ((_a = sortable.value.element) == null ? void 0 : _a.isConnected) && !(manager == null ? void 0 : manager.value.dragOperation.status.idle)) {
        return;
      }
      sortable.value.element = element2 != null ? element2 : void 0;
    },
    sourceRef: (element2) => {
      var _a;
      if (!element2 && ((_a = sortable.value.element) == null ? void 0 : _a.isConnected) && !(manager == null ? void 0 : manager.value.dragOperation.status.idle)) {
        return;
      }
      sortable.value.source = element2 != null ? element2 : void 0;
    },
    targetRef: (element2) => {
      var _a;
      if (!element2 && ((_a = sortable.value.element) == null ? void 0 : _a.isConnected) && !(manager == null ? void 0 : manager.value.dragOperation.status.idle)) {
        return;
      }
      sortable.value.target = element2 != null ? element2 : void 0;
    }
  };
}

export { useSortable };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=sortable.js.map