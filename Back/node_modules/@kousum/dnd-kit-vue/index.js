import { DragDropManager, defaultPreset, Draggable, Droppable } from '@dnd-kit/dom';
import { useEffect, useOnValueChange, useConstant, useComputed } from '@kousum/dnd-kit-vue/hooks';
import { defineComponent, useSlots, shallowRef, watch, provide, h, inject, ref } from 'vue';
import { deepEqual } from '@dnd-kit/state';
import { currentValue } from '@kousum/dnd-kit-vue/utilities';

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function useConfigContext() {
  const context = inject("ConfigContext", shallowRef(defaultManager));
  return {
    context
  };
}
var Consumer = defineComponent({
  name: "ConfigContextConsumer",
  setup() {
    const slots = useSlots();
    const { context } = useConfigContext();
    return () => slots.default ? slots.default(context) : null;
  }
});
var vuePropsType = {
  value: Object
};
var Provider = defineComponent({
  props: __spreadValues({}, vuePropsType),
  name: "ConfigProviderProvider",
  setup(props, { slots }) {
    const ConfigContext = shallowRef(props.value);
    watch(
      () => props.value,
      () => {
        ConfigContext.value = props.value;
      },
      { deep: true }
    );
    provide("ConfigContext", ConfigContext);
    return () => slots.default ? slots.default() : null;
  }
});
var defaultManager = new DragDropManager();
var DragDropContext = {
  Provider,
  Consumer
};
function useRenderer() {
  const rendering = shallowRef();
  ref(0);
  const resolver = shallowRef();
  const renderer = useConstant(() => ({
    get rendering() {
      var _a;
      return (_a = rendering.value) != null ? _a : Promise.resolve();
    }
  }));
  function onResolve() {
    var _a;
    (_a = resolver.value) == null ? void 0 : _a.call(resolver);
    rendering.value = void 0;
  }
  return {
    onResolve,
    renderer,
    trackRendering(callback) {
      if (!rendering.value) {
        rendering.value = new Promise((resolve) => {
          resolver.value = resolve;
        });
      }
      callback();
      onResolve();
    }
  };
}
var DragDropProvider = defineComponent({
  props: {
    onCollision: Function,
    onBeforeDragStart: Function,
    onDragStart: Function,
    onDragMove: Function,
    onDragOver: Function,
    onDragEnd: Function,
    plugins: Object,
    modifiers: Object,
    sensors: Object,
    manager: Object,
    renderer: Object
    // actions: Object as PropType<any>,
    // collisionObserver: Object as PropType<any>,
    // dragOperation: Object as PropType<any>,
    // monitor: Object as PropType<any>,
    // registry: Object as PropType<any>,
  },
  name: "Test",
  setup(props, { attrs }) {
    var _a;
    const slots = useSlots();
    const { renderer, trackRendering, onResolve } = useRenderer();
    const manager = shallowRef(
      (_a = props.manager) != null ? _a : null
    );
    function setManager(v) {
      manager.value = v;
    }
    useEffect(() => {
      var _b;
      const _a2 = props, input = __objRest(_a2, [
        "onCollision",
        "onBeforeDragStart",
        "onDragStart",
        "onDragMove",
        "onDragOver",
        "onDragEnd"
      ]);
      const handleBeforeDragStart = props.onBeforeDragStart;
      const handleDragStart = props.onDragStart;
      const handleDragOver = props.onDragOver;
      const handleDragMove = props.onDragMove;
      const handleDragEnd = props.onDragEnd;
      const handleCollision = props.onCollision;
      const manager2 = (_b = props.manager) != null ? _b : new DragDropManager(input);
      manager2.renderer = renderer.value;
      manager2.monitor.addEventListener("beforedragstart", (event, manager3) => {
        const callback = handleBeforeDragStart;
        if (callback) {
          trackRendering(() => callback(event, manager3));
        }
      });
      manager2.monitor.addEventListener(
        "dragstart",
        (event, manager3) => handleDragStart == null ? void 0 : handleDragStart(event, manager3)
      );
      manager2.monitor.addEventListener("dragover", (event, manager3) => {
        const callback = handleDragOver;
        if (callback) {
          trackRendering(() => callback(event, manager3));
        }
      });
      manager2.monitor.addEventListener("dragmove", (event, manager3) => {
        const callback = handleDragMove;
        if (callback) {
          trackRendering(() => callback(event, manager3));
        }
      });
      manager2.monitor.addEventListener("dragend", (event, manager3) => {
        const callback = handleDragEnd;
        if (callback) {
          trackRendering(() => callback(event, manager3));
        }
      });
      manager2.monitor.addEventListener(
        "collision",
        (event, manager3) => handleCollision == null ? void 0 : handleCollision(event, manager3)
      );
      setManager(manager2);
      return manager2.destroy;
    }, [renderer]);
    useOnValueChange(
      () => props.plugins,
      () => {
        var _a2;
        return manager.value && (manager.value.plugins = (_a2 = props.plugins) != null ? _a2 : defaultPreset.plugins);
      }
    );
    useOnValueChange(
      () => props.sensors,
      () => {
        var _a2;
        return manager.value && (manager.value.sensors = (_a2 = props.sensors) != null ? _a2 : defaultPreset.sensors);
      }
    );
    useOnValueChange(
      () => props.modifiers,
      () => {
        var _a2;
        return manager.value && (manager.value.modifiers = (_a2 = props.modifiers) != null ? _a2 : []);
      }
    );
    return () => {
      return /* @__PURE__ */ h(DragDropContext.Provider, { value: manager.value }, {
        default: () => {
          var _a2;
          return (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
        }
      });
    };
  }
});
function useDragDropManager() {
  return inject("ConfigContext", shallowRef(defaultManager));
}
function useInstance(initializer) {
  var _a;
  const manager = (_a = useDragDropManager()) != null ? _a : void 0;
  const instance = shallowRef(initializer(manager.value === defaultManager ? void 0 : manager.value));
  useEffect(() => {
    instance.value.manager = manager.value;
    const unregister = instance.value.register();
    return unregister;
  }, [instance, manager]);
  return instance;
}

// src/core/draggable/useDraggable.ts
function useDraggable(input) {
  const { disabled, data, id, modifiers, sensors } = input;
  const handle = currentValue(input.handle);
  const element = currentValue(input.element);
  const draggable = useInstance(
    (manager) => new Draggable(
      __spreadProps(__spreadValues({}, input), {
        handle: handle.value,
        element: element.value
      }),
      manager
    )
  );
  const isDragSource = useComputed(() => draggable.value.isDragSource);
  const status = useComputed(() => draggable.value.status);
  useOnValueChange(() => id, () => draggable.value.id = id);
  useOnValueChange(() => handle.value, () => draggable.value.handle = handle.value);
  useOnValueChange(() => element.value, () => draggable.value.element = element.value);
  useOnValueChange(() => data, () => data && (draggable.value.data = data));
  useOnValueChange(() => disabled, () => draggable.value.disabled = disabled === true);
  useOnValueChange(() => sensors, () => draggable.value.sensors = sensors);
  useOnValueChange(
    () => modifiers,
    () => draggable.value.modifiers = modifiers,
    void 0,
    deepEqual
  );
  useOnValueChange(
    () => input.feedback,
    () => {
      var _a;
      return draggable.value.feedback = (_a = input.feedback) != null ? _a : "default";
    }
  );
  return {
    draggable,
    isDragSource,
    status,
    handleRef: (element2) => {
      draggable.value.handle = element2 != null ? element2 : void 0;
    },
    ref: (element2) => {
      var _a, _b;
      if (!element2 && ((_a = draggable.value.element) == null ? void 0 : _a.isConnected) && !((_b = draggable.value.manager) == null ? void 0 : _b.dragOperation.status.idle)) {
        return;
      }
      draggable.value.element = element2 != null ? element2 : void 0;
    }
  };
}
function useDroppable(input) {
  const { collisionDetector, data, disabled, id, accept, type } = input;
  const element = currentValue(input.element);
  const droppable = useInstance(
    (manager) => new Droppable(
      __spreadProps(__spreadValues({}, input), {
        element: element.value
      }),
      manager
    )
  );
  const isDropTarget = useComputed(() => droppable.value.isDropTarget);
  useOnValueChange(() => id, () => droppable.value.id = id);
  useOnValueChange(() => accept, () => droppable.value.id = id, void 0, deepEqual);
  useOnValueChange(() => collisionDetector, () => droppable.value.id = id);
  useOnValueChange(() => data, () => data && (droppable.value.data = data));
  useOnValueChange(() => disabled, () => droppable.value.disabled = disabled === true);
  useOnValueChange(() => element.value, () => droppable.value.element = element.value);
  useOnValueChange(() => type, () => droppable.value.id = id);
  return {
    isDropTarget,
    // isDropTarget: isDropTarget_,
    ref: (element2) => {
      var _a, _b;
      if (!element2 && ((_a = droppable.value.element) == null ? void 0 : _a.isConnected) && !((_b = droppable.value.manager) == null ? void 0 : _b.dragOperation.status.idle)) {
        return;
      }
      droppable.value.element = element2 != null ? element2 : void 0;
    },
    droppable
  };
}
function useDragOperation() {
  const manager = useDragDropManager();
  const source = useComputed(() => {
    var _a;
    return (_a = manager.value) == null ? void 0 : _a.dragOperation.source;
  }, [manager]);
  const target = useComputed(() => {
    var _a;
    return (_a = manager.value) == null ? void 0 : _a.dragOperation.target;
  }, [manager]);
  return {
    source,
    target
  };
}

export { DragDropProvider, useDragDropManager, useDragOperation, useDraggable, useDroppable, useInstance };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map