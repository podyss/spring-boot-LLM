import { onMounted, watch, shallowRef, computed as computed$1, unref, toRaw, getCurrentInstance, nextTick } from 'vue';
import { computed, effect } from '@dnd-kit/state';

var canUseDOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var useIsomorphicLayoutEffect = canUseDOM ? useEffect : useEffect;
function useEffect(call, sources) {
  onMounted(() => {
    call();
  });
  watch(sources, () => {
    call();
  });
}
function useConstant(initializer) {
  const ref = shallowRef();
  watch(initializer, (v) => {
    if (!ref.value) {
      ref.value = v;
    }
  }, { immediate: true });
  return ref;
}
function useSignal(signal, sync = () => false) {
  var _a, _b;
  let val = (_a = toRaw(signal.value)) == null ? void 0 : _a.peek();
  const read = shallowRef(false);
  const update = shallowRef(val);
  const currentInstance = getCurrentInstance();
  useIsomorphicLayoutEffect(
    () => effect(() => {
      var _a2, _b2, _c;
      let val2 = (_a2 = toRaw(signal.value)) == null ? void 0 : _a2.peek();
      if (!read.value) return;
      if (val2 !== (val2 = toRaw(signal.value).value)) {
        if (sync()) {
          (_b2 = currentInstance == null ? void 0 : currentInstance.proxy) == null ? void 0 : _b2.$forceUpdate();
          nextTick(() => update.value = val2);
        } else {
          update.value = val2;
          (_c = currentInstance == null ? void 0 : currentInstance.proxy) == null ? void 0 : _c.$forceUpdate();
        }
      }
    }),
    [() => signal, sync]
  );
  const effectValue = shallowRef((_b = signal.value) == null ? void 0 : _b.value);
  effect(() => {
    var _a2;
    effectValue.value = (_a2 = signal.value) == null ? void 0 : _a2.value;
  });
  return {
    get value() {
      read.value = true;
      return effectValue.value;
    }
  };
}
function useComputed(compute, dependencies = [], sync = () => false) {
  const $compute = shallowRef(compute);
  $compute.value = compute;
  const watchValue = shallowRef(computed(() => $compute.value()));
  watch(dependencies, () => {
    watchValue.value = computed(() => $compute.value());
  });
  const value = useSignal(
    watchValue,
    sync
  );
  return computed$1({
    // getter
    get() {
      return value.value;
    },
    // setter
    set(newValue) {
    }
  });
}

// src/hooks/useImmediateEffect.ts
function useImmediateEffect(callback, _) {
  callback();
}
function useLatest(value) {
  const valueRef = shallowRef(value);
  useIsomorphicLayoutEffect(() => {
    valueRef.value = value;
  }, [value]);
  return valueRef;
}
function useOnValueChange(valueFn, onChange, effect3 = useEffect, compare = Object.is, sources = []) {
  const tracked = shallowRef(valueFn());
  effect3(() => {
    const value = valueFn();
    const oldValue = unref(tracked);
    if (!compare(value, oldValue)) {
      tracked.value = value;
      onChange(value, oldValue);
    }
  }, [() => onChange, valueFn]);
}

export { useComputed, useConstant, useEffect, useImmediateEffect, useIsomorphicLayoutEffect, useLatest, useOnValueChange };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=hooks.js.map