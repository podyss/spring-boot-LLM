'use strict';

var vue = require('vue');
var state = require('@dnd-kit/state');

var canUseDOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var useIsomorphicLayoutEffect = canUseDOM ? useEffect : useEffect;
function useEffect(call, sources) {
  vue.onMounted(() => {
    call();
  });
  vue.watch(sources, () => {
    call();
  });
}
function useConstant(initializer) {
  const ref = vue.shallowRef();
  vue.watch(initializer, (v) => {
    if (!ref.value) {
      ref.value = v;
    }
  }, { immediate: true });
  return ref;
}
function useSignal(signal, sync = () => false) {
  var _a, _b;
  let val = (_a = vue.toRaw(signal.value)) == null ? void 0 : _a.peek();
  const read = vue.shallowRef(false);
  const update = vue.shallowRef(val);
  const currentInstance = vue.getCurrentInstance();
  useIsomorphicLayoutEffect(
    () => state.effect(() => {
      var _a2, _b2, _c;
      let val2 = (_a2 = vue.toRaw(signal.value)) == null ? void 0 : _a2.peek();
      if (!read.value) return;
      if (val2 !== (val2 = vue.toRaw(signal.value).value)) {
        if (sync()) {
          (_b2 = currentInstance == null ? void 0 : currentInstance.proxy) == null ? void 0 : _b2.$forceUpdate();
          vue.nextTick(() => update.value = val2);
        } else {
          update.value = val2;
          (_c = currentInstance == null ? void 0 : currentInstance.proxy) == null ? void 0 : _c.$forceUpdate();
        }
      }
    }),
    [() => signal, sync]
  );
  const effectValue = vue.shallowRef((_b = signal.value) == null ? void 0 : _b.value);
  state.effect(() => {
    var _a2;
    effectValue.value = (_a2 = signal.value) == null ? void 0 : _a2.value;
  });
  return {
    get value() {
      read.value = true;
      return effectValue.value;
    }
  };
}
function useComputed(compute, dependencies = [], sync = () => false) {
  const $compute = vue.shallowRef(compute);
  $compute.value = compute;
  const watchValue = vue.shallowRef(state.computed(() => $compute.value()));
  vue.watch(dependencies, () => {
    watchValue.value = state.computed(() => $compute.value());
  });
  const value = useSignal(
    watchValue,
    sync
  );
  return vue.computed({
    // getter
    get() {
      return value.value;
    },
    // setter
    set(newValue) {
    }
  });
}

// src/hooks/useImmediateEffect.ts
function useImmediateEffect(callback, _) {
  callback();
}
function useLatest(value) {
  const valueRef = vue.shallowRef(value);
  useIsomorphicLayoutEffect(() => {
    valueRef.value = value;
  }, [value]);
  return valueRef;
}
function useOnValueChange(valueFn, onChange, effect3 = useEffect, compare = Object.is, sources = []) {
  const tracked = vue.shallowRef(valueFn());
  effect3(() => {
    const value = valueFn();
    const oldValue = vue.unref(tracked);
    if (!compare(value, oldValue)) {
      tracked.value = value;
      onChange(value, oldValue);
    }
  }, [() => onChange, valueFn]);
}

exports.useComputed = useComputed;
exports.useConstant = useConstant;
exports.useEffect = useEffect;
exports.useImmediateEffect = useImmediateEffect;
exports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;
exports.useLatest = useLatest;
exports.useOnValueChange = useOnValueChange;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=hooks.cjs.map