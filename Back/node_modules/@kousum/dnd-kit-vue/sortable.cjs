'use strict';

var state = require('@dnd-kit/state');
var sortable = require('@dnd-kit/dom/sortable');
var dndKitVue = require('@kousum/dnd-kit-vue');
var hooks = require('@kousum/dnd-kit-vue/hooks');
var utilities = require('@kousum/dnd-kit-vue/utilities');

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
function useSortable(input) {
  const {
    accept,
    collisionDetector,
    collisionPriority,
    data,
    disabled,
    feedback,
    sensors,
    transition = sortable.defaultSortableTransition,
    type
  } = input;
  const manager = dndKitVue.useDragDropManager();
  const id = utilities.currentValue(input.id);
  const group = utilities.currentValue(input.group);
  const index = utilities.currentValue(input.index);
  const handle = utilities.currentValue(input.handle);
  const element = utilities.currentValue(input.element);
  const target = utilities.currentValue(input.target);
  const sortable$1 = dndKitVue.useInstance((manager2) => {
    return new sortable.Sortable(
      __spreadProps(__spreadValues({}, input), {
        handle: handle.value,
        element: element.value,
        target: target.value,
        index: index.value,
        group: group.value,
        id: id.value,
        feedback
      }),
      manager2
    );
  });
  const isDropTarget = hooks.useComputed(() => sortable$1.value.isDropTarget);
  const isDragSource = hooks.useComputed(() => sortable$1.value.isDragSource);
  const status = hooks.useComputed(() => sortable$1.value.status);
  hooks.useOnValueChange(() => id.value, () => sortable$1.value.id = id.value);
  hooks.useIsomorphicLayoutEffect(() => {
    state.batch(() => {
      sortable$1.value.group = group.value;
      sortable$1.value.index = index.value;
    });
  }, [() => group.value, () => index.value]);
  hooks.useOnValueChange(() => type, () => sortable$1.value.type = type);
  hooks.useOnValueChange(
    () => accept,
    () => sortable$1.value.accept = accept,
    void 0,
    state.deepEqual
  );
  hooks.useOnValueChange(() => data, () => data && (sortable$1.value.data = data));
  hooks.useOnValueChange(
    () => index.value,
    () => {
      var _a;
      if (((_a = manager.value) == null ? void 0 : _a.dragOperation.status.idle) && (transition == null ? void 0 : transition.idle)) {
        sortable$1.value.refreshShape();
      }
    },
    hooks.useImmediateEffect
  );
  hooks.useOnValueChange(() => handle.value, () => sortable$1.value.handle = handle.value);
  hooks.useOnValueChange(() => element.value, () => sortable$1.value.element = element.value);
  hooks.useOnValueChange(() => target.value, () => sortable$1.value.target = target.value);
  hooks.useOnValueChange(() => disabled, () => sortable$1.value.disabled = disabled === true);
  hooks.useOnValueChange(() => sensors, () => sortable$1.value.sensors = sensors);
  hooks.useOnValueChange(
    () => collisionDetector,
    () => sortable$1.value.collisionDetector = collisionDetector
  );
  hooks.useOnValueChange(
    () => collisionPriority,
    () => sortable$1.value.collisionPriority = collisionPriority
  );
  hooks.useOnValueChange(() => feedback, () => sortable$1.value.feedback = feedback != null ? feedback : "default");
  hooks.useOnValueChange(() => transition, () => sortable$1.value.transition = transition);
  return {
    isDragSource,
    isDropTarget,
    status,
    handleRef: (element2) => {
      sortable$1.value.handle = element2 != null ? element2 : void 0;
    },
    ref: (element2) => {
      var _a;
      if (!element2 && ((_a = sortable$1.value.element) == null ? void 0 : _a.isConnected) && !(manager == null ? void 0 : manager.value.dragOperation.status.idle)) {
        return;
      }
      sortable$1.value.element = element2 != null ? element2 : void 0;
    },
    sourceRef: (element2) => {
      var _a;
      if (!element2 && ((_a = sortable$1.value.element) == null ? void 0 : _a.isConnected) && !(manager == null ? void 0 : manager.value.dragOperation.status.idle)) {
        return;
      }
      sortable$1.value.source = element2 != null ? element2 : void 0;
    },
    targetRef: (element2) => {
      var _a;
      if (!element2 && ((_a = sortable$1.value.element) == null ? void 0 : _a.isConnected) && !(manager == null ? void 0 : manager.value.dragOperation.status.idle)) {
        return;
      }
      sortable$1.value.target = element2 != null ? element2 : void 0;
    }
  };
}

exports.useSortable = useSortable;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=sortable.cjs.map