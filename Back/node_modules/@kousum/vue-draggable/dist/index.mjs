import { defineComponent as Z, useSlots as _, reactive as K, getCurrentInstance as tt, onMounted as et, onBeforeUnmount as nt, cloneVNode as ot, watch as O, createVNode as dt, mergeProps as gt } from "vue";
const at = [Array, Object, String, Number, Boolean, Function], ht = Array, P = Boolean, X = Function, mt = Number, v = Object, N = String;
function st(t, e) {
  const n = {};
  return Object.keys(t).forEach((o) => {
    if (e.hasOwnProperty(o))
      if (t[o].hasOwnProperty("type"))
        n[o] = {
          // @ts-ignore
          type: t[o].type,
          default: e[o]
        };
      else {
        const a = typeof e[o] == "object" ? () => e[o] : e[o];
        n[o] = {
          type: t[o],
          default: a
        };
      }
    else
      n[o] = {
        // eslint-disable-next-line no-prototype-builtins
        type: t[o].hasOwnProperty("type") ? (
          // @ts-ignore
          t[o].type
        ) : t[o],
        default: void 0
      };
  }), n;
}
function A(t, e) {
  for (let n = 0, o = t.length; n < o; n++)
    if (e.apply(e, [t[n], n, t]))
      return t[n];
}
function z(t) {
  return typeof t == "function" || Object.prototype.toString.call(t) === "[object Function]";
}
function Y(t) {
  return typeof t == "number" && !isNaN(t);
}
function y(t) {
  return parseInt(t, 10);
}
const $ = ["Moz", "Webkit", "O", "ms"];
function yt(t = "transform") {
  var n, o;
  if (typeof window > "u")
    return "";
  const e = (o = (n = window.document) == null ? void 0 : n.documentElement) == null ? void 0 : o.style;
  if (!e || t in e)
    return "";
  for (let a = 0; a < $.length; a++)
    if (rt(t, $[a]) in e)
      return $[a];
  return "";
}
function rt(t, e) {
  return e ? `${e}${wt(t)}` : t;
}
function wt(t) {
  let e = "", n = !0;
  for (let o = 0; o < t.length; o++)
    n ? (e += t[o].toUpperCase(), n = !1) : t[o] === "-" ? n = !0 : e += t[o];
  return e;
}
const St = yt();
let M = "";
function bt(t, e) {
  return M || (M = A(
    [
      "matches",
      "webkitMatchesSelector",
      "mozMatchesSelector",
      "msMatchesSelector",
      "oMatchesSelector"
    ],
    function(n) {
      return z(t[n]);
    }
  )), z(t[M]) ? t[M](e) : !1;
}
function q(t, e, n) {
  let o = t;
  do {
    if (bt(o, e))
      return !0;
    if (o === n)
      return !1;
    o = o.parentNode;
  } while (o);
  return !1;
}
function L(t, e, n, o) {
  if (!t)
    return;
  const a = { capture: !0, ...o };
  t.addEventListener ? t.addEventListener(e, n, a) : t.attachEvent ? t.attachEvent("on" + e, n) : t["on" + e] = n;
}
function T(t, e, n, o) {
  if (!t)
    return;
  const a = { capture: !0, ...o };
  t.removeEventListener ? t.removeEventListener(e, n, a) : t.detachEvent ? t.detachEvent("on" + e, n) : t["on" + e] = null;
}
function pt(t) {
  let e = t.clientHeight;
  const n = t.ownerDocument.defaultView.getComputedStyle(t);
  return e += y(n.borderTopWidth), e += y(n.borderBottomWidth), e;
}
function Dt(t) {
  let e = t.clientWidth;
  const n = t.ownerDocument.defaultView.getComputedStyle(t);
  return e += y(n.borderLeftWidth), e += y(n.borderRightWidth), e;
}
function xt(t) {
  let e = t.clientHeight;
  const n = t.ownerDocument.defaultView.getComputedStyle(t);
  return e -= y(n.paddingTop), e -= y(n.paddingBottom), e;
}
function vt(t) {
  let e = t.clientWidth;
  const n = t.ownerDocument.defaultView.getComputedStyle(t);
  return e -= y(n.paddingLeft), e -= y(n.paddingRight), e;
}
function Nt(t, e, n) {
  const a = e === e.ownerDocument.body ? { left: 0, top: 0 } : e.getBoundingClientRect(), f = (t.clientX + e.scrollLeft - a.left) / n, S = (t.clientY + e.scrollTop - a.top) / n;
  return { x: f, y: S };
}
function Et(t, e) {
  const n = lt(t, e, "px");
  return console.log(t), { [rt("transform", St)]: n };
}
function Tt(t, e) {
  return lt(t, e, "");
}
function lt({ x: t, y: e }, n, o) {
  let a = `translate(${t}${o},${e}${o})`;
  if (n) {
    const f = `${typeof n.x == "string" ? n.x : n.x + o}`, S = `${typeof n.y == "string" ? n.y : n.y + o}`;
    a = `translate(${f}, ${S})` + a;
  }
  return a;
}
function Ct(t, e) {
  return t.targetTouches && A(t.targetTouches, (n) => e === n.identifier) || t.changedTouches && A(t.changedTouches, (n) => e === n.identifier);
}
function Xt(t) {
  if (t.targetTouches && t.targetTouches[0])
    return t.targetTouches[0].identifier;
  if (t.changedTouches && t.changedTouches[0])
    return t.changedTouches[0].identifier;
}
function Yt(t) {
  if (!t)
    return;
  let e = t.getElementById("react-draggable-style-el");
  e || (e = t.createElement("style"), e.type = "text/css", e.id = "react-draggable-style-el", e.innerHTML = `.react-draggable-transparent-selection *::-moz-selection {all: inherit;}
`, e.innerHTML += `.react-draggable-transparent-selection *::selection {all: inherit;}
`, t.getElementsByTagName("head")[0].appendChild(e)), t.body && Mt(t.body, "react-draggable-transparent-selection");
}
function J(t) {
  if (t)
    try {
      if (t.body && kt(t.body, "react-draggable-transparent-selection"), t.selection)
        t.selection.empty();
      else {
        const e = (t.defaultView || window).getSelection();
        e && e.type !== "Caret" && e.removeAllRanges();
      }
    } catch {
    }
}
function Mt(t, e) {
  t.classList ? t.classList.add(e) : t.class.match(new RegExp(`(?:^|\\s)${e}(?!\\S)`)) || (t.class += ` ${e}`);
}
function kt(t, e) {
  t.classList ? t.classList.remove(e) : t.class = t.class.replace(
    new RegExp(`(?:^|\\s)${e}(?!\\S)`, "g"),
    ""
  );
}
function Pt(t, e, n) {
  if (!t.props.bounds)
    return [e, n];
  let { bounds: o } = t.props;
  o = typeof o == "string" ? o : Bt(o);
  const a = H(t);
  if (typeof o == "string") {
    const { ownerDocument: f } = a, S = f.defaultView;
    let b;
    if (o === "parent" ? b = a.parentNode : b = f.querySelector(o), !(b instanceof S.HTMLElement))
      throw new Error(
        'Bounds selector "' + o + '" could not find an element.'
      );
    const w = b, i = S.getComputedStyle(a), c = S.getComputedStyle(w);
    o = {
      left: -a.offsetLeft + y(c.paddingLeft) + y(i.marginLeft),
      top: -a.offsetTop + y(c.paddingTop) + y(i.marginTop),
      right: vt(w) - Dt(a) - a.offsetLeft + y(c.paddingRight) - y(i.marginRight),
      bottom: xt(w) - pt(a) - a.offsetTop + y(c.paddingBottom) - y(i.marginBottom)
    };
  }
  return Y(o.right) && (e = Math.min(e, o.right)), Y(o.bottom) && (n = Math.min(n, o.bottom)), Y(o.left) && (e = Math.max(e, o.left)), Y(o.top) && (n = Math.max(n, o.top)), [e, n];
}
function Q(t, e, n) {
  const o = Math.round(e / t[0]) * t[0], a = Math.round(n / t[1]) * t[1];
  return [o, a];
}
function $t(t) {
  return t.props.axis === "both" || t.props.axis === "x";
}
function Lt(t) {
  return t.props.axis === "both" || t.props.axis === "y";
}
function B(t, e, n) {
  const o = typeof e == "number" ? Ct(t, e) : null;
  if (typeof e == "number" && !o)
    return null;
  const a = H(n), f = n.props.offsetParent || a.offsetParent || a.ownerDocument.body;
  return Nt(
    o || t,
    // @ts-ignore
    f,
    n.props.scale
  );
}
function U(t, e, n) {
  const o = t.exposed.state, a = !Y(o.lastX), f = H(t);
  return a ? {
    node: f,
    deltaX: 0,
    deltaY: 0,
    lastX: e,
    lastY: n,
    x: e,
    y: n
  } : {
    node: f,
    deltaX: e - o.lastX,
    deltaY: n - o.lastY,
    lastX: o.lastX,
    lastY: o.lastY,
    x: e,
    y: n
  };
}
function V(t, e) {
  const n = t.props.scale;
  return {
    node: e.node,
    x: t.exposed.state.x + e.deltaX / n,
    y: t.exposed.state.y + e.deltaY / n,
    deltaX: e.deltaX / n,
    deltaY: e.deltaY / n,
    lastX: t.exposed.state.x,
    lastY: t.exposed.state.y
  };
}
function Bt(t) {
  return {
    left: t.left,
    top: t.top,
    right: t.right,
    bottom: t.bottom
  };
}
function H(t) {
  var n;
  const e = (n = t == null ? void 0 : t.ctx) == null ? void 0 : n.$el;
  if (!e)
    throw new Error("<DraggableCore>: Unmounted during event!");
  return e;
}
function Ut(...t) {
}
const D = {
  touch: {
    start: "touchstart",
    move: "touchmove",
    stop: "touchend"
  },
  mouse: {
    start: "mousedown",
    move: "mousemove",
    stop: "mouseup"
  }
};
let x = D.mouse;
const Vt = {
  children: at,
  /**
   * `allowAnyClick` allows dragging using any mouse button.
   * By default, we only accept the left button.
   *
   * Defaults to `false`.
   */
  allowAnyClick: P,
  /**
   * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
   * with the exception of `onMouseDown`, will not fire.
   */
  disabled: P,
  /**
   * By default, we add 'user-select:none' attributes to the document body
   * to prevent ugly text selection during drag. If this is causing problems
   * for your app, set this to `false`.
   */
  enableUserSelectHack: P,
  /**
   * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
   * instead of using the parent node.
   */
  offsetParent: X,
  /**
   * `grid` specifies the x and y that dragging should snap to.
   */
  grid: ht,
  /**
   * `handle` specifies a selector to be used as the handle that initiates drag.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *         return (
   *            <Draggable handle=".handle">
   *              <div>
   *                  <div className="handle">Click me to drag</div>
   *                  <div>This is some other content</div>
   *              </div>
   *           </Draggable>
   *         );
   *       }
   *   });
   * ```
   */
  handle: N,
  /**
   * `cancel` specifies a selector to be used to prevent drag initialization.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *           return(
   *               <Draggable cancel=".cancel">
   *                   <div>
   *                     <div className="cancel">You can't drag from here</div>
   *                     <div>Dragging here works fine</div>
   *                   </div>
   *               </Draggable>
   *           );
   *       }
   *   });
   * ```
   */
  cancel: N,
  /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.
   * Unfortunately, in order for <Draggable> to work properly, we need raw access
   * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`
   * as in this example:
   *
   * function MyComponent() {
   *   const nodeRef = React.useRef(null);
   *   return (
   *     <Draggable nodeRef={nodeRef}>
   *       <div ref={nodeRef}>Example Target</div>
   *     </Draggable>
   *   );
   * }
   *
   * This can be used for arbitrarily nested components, so long as the ref ends up
   * pointing to the actual child DOM node and not a custom component.
   */
  nodeRef: v,
  /**
   * Called when dragging starts.
   * If this function returns the boolean false, dragging will be canceled.
   */
  onStart: X,
  /**
   * Called while dragging.
   * If this function returns the boolean false, dragging will be canceled.
   */
  onDrag: X,
  /**
   * Called when dragging stops.
   * If this function returns the boolean false, the drag will remain active.
   */
  onStop: X,
  /**
   * A workaround option which can be passed if onMouseDown needs to be accessed,
   * since it'll always be blocked (as there is internal use of onMouseDown)
   */
  onMouseDown: X,
  /**
   * `scale`, if set, applies scaling while dragging an element
   */
  scale: mt,
  /**
   * These properties should be defined on the child, not here.
   */
  className: N,
  style: v,
  transform: v
}, it = {
  allowAnyClick: !1,
  // by default only accept left click
  disabled: !1,
  enableUserSelectHack: !0,
  onStart: function() {
  },
  onDrag: function() {
  },
  onStop: function() {
  },
  onMouseDown: function() {
  },
  scale: 1
}, ct = st(Vt, it), k = /* @__PURE__ */ Z((t, {
  expose: e
}) => {
  _();
  const n = K({
    dragging: !1,
    // Used while dragging to determine deltas.
    lastX: NaN,
    lastY: NaN,
    touchIdentifier: void 0
  });
  let o = !1;
  const a = tt();
  et(() => {
    var r;
    o = !0;
    const s = (r = a == null ? void 0 : a.ctx) == null ? void 0 : r.$el;
    s && L(s, D.touch.start, d, {
      passive: !1
    });
  }), nt(() => {
    o = !1;
    const s = f();
    if (s) {
      const {
        ownerDocument: r
      } = s;
      T(r, D.mouse.move, b), T(r, D.touch.move, b), T(r, D.mouse.stop, w), T(r, D.touch.stop, w), T(s, D.touch.start, d, {
        passive: !1
      }), t.enableUserSelectHack && J(r);
    }
  });
  function f() {
    var s;
    return ((s = t == null ? void 0 : t.nodeRef) == null ? void 0 : s.value) || // @ts-ignore
    a.ctx.$el;
  }
  const S = (s) => {
    if (t.onMouseDown(s), !t.allowAnyClick && typeof s.button == "number" && s.button !== 0)
      return !1;
    const r = f();
    if (!r || !r.ownerDocument || !r.ownerDocument.body)
      throw new Error("<DraggableCore> not mounted on DragStart!");
    const {
      ownerDocument: u
    } = r;
    if (t.disabled || !(s.target instanceof u.defaultView.Node) || t.handle && !q(s.target, t.handle, r) || t.cancel && q(s.target, t.cancel, r))
      return;
    s.type === "touchstart" && s.preventDefault();
    const g = Xt(s);
    n.touchIdentifier = g;
    const p = B(s, g, a);
    if (p == null)
      return;
    const {
      x: C,
      y: h
    } = p, m = U(a, C, h);
    Ut("calling", t.onStart), !(t.onStart(s, m) === !1 || o === !1) && (t.enableUserSelectHack && Yt(u), n.dragging = !0, n.lastX = C, n.lastY = h, L(u, x.move, b), L(u, x.stop, w));
  }, b = (s) => {
    const r = B(s, n.touchIdentifier, a);
    if (r == null)
      return;
    let {
      x: u,
      y: g
    } = r;
    if (Array.isArray(t.grid)) {
      let h = u - n.lastX, m = g - n.lastY;
      if ([h, m] = Q(t.grid, h, m), !h && !m)
        return;
      u = n.lastX + h, g = n.lastY + m;
    }
    const p = U(a, u, g);
    if (t.onDrag(s, p) === !1 || o === !1) {
      try {
        w(new MouseEvent("mouseup"));
      } catch {
        const m = document.createEvent("MouseEvents");
        m.initMouseEvent("mouseup", !0, !0, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), w(m);
      }
      return;
    }
    n.lastX = u, n.lastY = g;
  }, w = (s) => {
    if (!n.dragging)
      return;
    const r = B(s, n.touchIdentifier, a);
    if (r == null)
      return;
    let {
      x: u,
      y: g
    } = r;
    if (Array.isArray(t.grid)) {
      let m = u - n.lastX || 0, E = g - n.lastY || 0;
      [m, E] = Q(t.grid, m, E), u = n.lastX + m, g = n.lastY + E;
    }
    const p = U(a, u, g);
    if (t.onStop(s, p) === !1 || o === !1)
      return !1;
    const h = f();
    h && t.enableUserSelectHack && J(h.ownerDocument), n.dragging = !1, n.lastX = NaN, n.lastY = NaN, h && (T(h.ownerDocument, x.move, b), T(h.ownerDocument, x.stop, w));
  }, i = (s) => (x = D.mouse, S(s)), c = (s) => (x = D.mouse, w(s)), d = (s) => (x = D.touch, S(s)), l = (s) => (x = D.touch, w(s));
  return e({
    state: n
  }), () => ot(t.children, {
    // Note: mouseMove handler is attached to document so it will still function
    // when the user drags quickly and leaves the bounds of the element.
    onMousedown: i,
    onMouseup: c,
    // onTouchStart is added on `componentDidMount` so they can be added with
    // {passive: false}, which allows it to cancel. See
    // https://developers.google.com/web/updates/2017/01/scrolling-intervention
    onTouchend: l
  });
});
k.props = ct;
k.name = "DraggableCore";
k.displayName = "DraggableCore";
function ut(t) {
  var e, n, o = "";
  if (typeof t == "string" || typeof t == "number")
    o += t;
  else if (typeof t == "object")
    if (Array.isArray(t))
      for (e = 0; e < t.length; e++)
        t[e] && (n = ut(t[e])) && (o && (o += " "), o += n);
    else
      for (e in t)
        t[e] && (o && (o += " "), o += e);
  return o;
}
function At() {
  for (var t, e, n = 0, o = ""; n < arguments.length; )
    (t = arguments[n++]) && (e = ut(t)) && (o && (o += " "), o += e);
  return o;
}
const Ht = {
  // Accepts all props <DraggableCore> accepts.
  ...ct,
  /**
   * `axis` determines which axis the draggable can move.
   *
   *  Note that all callbacks will still return data as normal. This only
   *  controls flushing to the DOM.
   *
   * 'both' allows movement horizontally and vertically.
   * 'x' limits movement to horizontal axis.
   * 'y' limits movement to vertical axis.
   * 'none' limits all movement.
   *
   * Defaults to 'both'.
   */
  axis: N,
  /**
   * `bounds` determines the range of movement available to the element.
   * Available values are:
   *
   * 'parent' restricts movement within the Draggable's parent node.
   *
   * Alternatively, pass an object with the following properties, all of which are optional:
   *
   * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
   *
   * All values are in px.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *         return (
   *            <Draggable bounds={{right: 300, bottom: 300}}>
   *              <div>Content</div>
   *           </Draggable>
   *         );
   *       }
   *   });
   * ```
   */
  bounds: at,
  defaultClassName: N,
  defaultClassNameDragging: N,
  defaultClassNameDragged: N,
  /**
   * `defaultPosition` specifies the x and y that the dragged item should start at
   *
   * Example:
   *
   * ```jsx
   *      let App = React.createClass({
   *          render: function () {
   *              return (
   *                  <Draggable defaultPosition={{x: 25, y: 25}}>
   *                      <div>I start with transformX: 25px and transformY: 25px;</div>
   *                  </Draggable>
   *              );
   *          }
   *      });
   * ```
   */
  defaultPosition: v,
  positionOffset: v,
  /**
   * `position`, if present, defines the current position of the element.
   *
   *  This is similar to how form elements in React work - if no `position` is supplied, the component
   *  is uncontrolled.
   *
   * Example:
   *
   * ```jsx
   *      let App = React.createClass({
   *          render: function () {
   *              return (
   *                  <Draggable position={{x: 25, y: 25}}>
   *                      <div>I start with transformX: 25px and transformY: 25px;</div>
   *                  </Draggable>
   *              );
   *          }
   *      });
   * ```
   */
  position: v,
  /**
   * These properties should be defined on the child, not here.
   */
  className: N,
  style: v,
  transform: v
}, Rt = {
  ...it,
  axis: "both",
  bounds: !1,
  defaultClassName: "react-draggable",
  defaultClassNameDragging: "react-draggable-dragging",
  defaultClassNameDragged: "react-draggable-dragged",
  defaultPosition: {
    x: 0,
    y: 0
  },
  scale: 1
}, Wt = st(Ht, Rt), R = /* @__PURE__ */ Z((t, {
  expose: e
}) => {
  _();
  const n = tt(), o = K({
    // Whether or not we are currently dragging.
    dragging: !1,
    // Whether or not we have been dragged before.
    dragged: !1,
    // Current transform x and y.
    x: t.position ? t.position.x : t.defaultPosition.x,
    y: t.position ? t.position.y : t.defaultPosition.y,
    prevPropsPosition: {
      ...t.position
    },
    // Used for compensating for out-of-bounds drags
    slackX: 0,
    slackY: 0,
    // Can only determine if SVG after mounting
    isElementSVG: !1
  });
  O([], () => {
    t.position && !(t.onDrag || t.onStop) && console.warn("A `position` was applied to this <Draggable>, without drag handlers. This will make this component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the `position` of this element.");
  });
  function a({
    position: i
  }, {
    prevPropsPosition: c
  }) {
    return i && (!c || i.x !== c.x || i.y !== c.y) ? {
      x: i.x,
      y: i.y,
      prevPropsPosition: {
        ...i
      }
    } : null;
  }
  O(() => t, () => {
    const i = a(t, o);
    i && Object.keys(i).forEach((c) => {
      o[c] = i[c];
    });
  }, {
    deep: !0
  }), et(() => {
    typeof window.SVGElement < "u" && f() instanceof window.SVGElement && (o.isElementSVG = !0);
  }), nt(() => {
    o.isElementSVG = !1;
  });
  function f() {
    var i;
    return ((i = t == null ? void 0 : t.nodeRef) == null ? void 0 : i.value) || // @ts-ignore
    n.ctx.$el;
  }
  const S = (i, c) => {
    if (t.onStart(i, V(n, c)) === !1)
      return !1;
    o.dragging = !0, o.dragged = !0;
  }, b = (i, c) => {
    if (!o.dragging)
      return !1;
    const d = V(n, c), l = {
      x: d.x,
      y: d.y
    };
    if (t.bounds) {
      const {
        x: r,
        y: u
      } = l;
      l.x += o.slackX, l.y += o.slackY;
      const [g, p] = Pt(n, l.x, l.y);
      l.x = g, l.y = p, l.slackX = o.slackX + (r - l.x), l.slackY = o.slackY + (u - l.y), d.x = l.x, d.y = l.y, d.deltaX = l.x - o.x, d.deltaY = l.y - o.y;
    }
    if (t.onDrag(i, d) === !1)
      return !1;
    l && Object.keys(l).forEach((r) => {
      o[r] = l[r];
    });
  }, w = (i, c) => {
    if (!o.dragging || t.onStop(i, V(n, c)) === !1)
      return !1;
    const l = {
      dragging: !1,
      slackX: 0,
      slackY: 0
    };
    if (Boolean(t.position)) {
      const {
        x: r,
        y: u
      } = t.position;
      l.x = r, l.y = u;
    }
    l && Object.keys(l).forEach((r) => {
      o[r] = l[r];
    });
  };
  return e({
    state: o
  }), () => {
    var G, I;
    const {
      axis: i,
      bounds: c,
      children: d,
      defaultPosition: l,
      defaultClassName: s,
      defaultClassNameDragging: r,
      defaultClassNameDragged: u,
      position: g,
      positionOffset: p,
      scale: C,
      ...h
    } = t;
    let m = {}, E = null;
    const W = !Boolean(g) || o.dragging, F = g || l, j = {
      // Set left if horizontal drag is enabled
      x: $t(n) && W ? o.x : F.x,
      // Set top if vertical drag is enabled
      y: Lt(n) && W ? o.y : F.y
    };
    o.isElementSVG ? E = Tt(j, p) : m = Et(j, p);
    const ft = At(((G = d.props) == null ? void 0 : G.class) || "", s, {
      [r]: o.dragging,
      [u]: o.dragged
    });
    return dt(k, gt({
      ...h,
      scale: C,
      onStart: S,
      onDrag: b,
      onStop: w
    }, {
      children: ot(d, {
        className: ft,
        style: {
          ...(I = d.props) == null ? void 0 : I.style,
          ...m
        },
        transform: E
      })
    }), null);
  };
});
R.props = Wt;
R.name = "Draggable";
R.v = "Draggable";
export {
  R as Draggable,
  k as DraggableCore
};
