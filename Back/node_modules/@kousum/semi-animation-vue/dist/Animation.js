import { defineComponent as g, shallowRef as B, reactive as O, onMounted as j, onBeforeUnmount as E, watch as x, isVNode as I } from "vue";
import { Animation as N, events as R } from "@douyinfe/semi-animation";
import a from "./utils/noop";
const A = {
  onStart: {
    type: Function,
    default: a
  },
  onFrame: {
    type: Function,
    default: a
  },
  onPause: {
    type: Function,
    default: a
  },
  onResume: {
    type: Function,
    default: a
  },
  onStop: {
    type: Function,
    default: a
  },
  onRest: {
    type: Function,
    default: a
  },
  from: Object,
  to: Object,
  reverse: Boolean,
  reset: Boolean,
  force: {
    type: Boolean,
    default: !1
  },
  config: Object,
  autoStart: {
    type: Boolean,
    default: !0
  },
  forwardInstance: Function,
  immediate: Boolean,
  enter: Object,
  leave: Object,
  state: [String, Boolean],
  willEnter: {
    type: Function,
    default: a
  },
  didEnter: {
    type: Function,
    default: a
  },
  willLeave: {
    type: Function,
    default: a
  },
  didLeave: {
    type: Function,
    default: a
  }
}, M = /* @__PURE__ */ g((t, {
  slots: F
}) => {
  let r = !1, c = !1;
  const n = B(null);
  let m, s, y;
  const u = O({
    currentStyle: {}
  });
  let i = function() {
    throw new Error("Method not implemented.");
  };
  f(), v(), j(() => {
    r = !0;
    const {
      forwardInstance: e
    } = t;
    n.value === null && (f(), v()), typeof e == "function" && e(n.value), i();
  }), E(() => {
    r = !1, n.value && (n.value.destroy(), n.value = null);
  }), x([() => t.from, () => t.to, () => t.reset, () => t.force], (e, [l, o]) => {
    t.reset && (t.from !== l || t.to !== o) && (m(), f(), i()), t.force && t.to !== o && (f({
      ...t,
      from: o
    }), i());
  });
  function f(e) {
    e = e ?? t;
    let {
      from: l,
      to: o,
      config: S,
      reverse: w
    } = e;
    w && ([l, o] = [o, l]), n.value = new N({
      from: {
        ...l
      },
      to: {
        ...o
      }
    }, {
      ...S
    }), R.forEach((d) => {
      const b = `on${d[0].toUpperCase() + d.slice(1)}`;
      n.value.on(d, (h) => {
        r && !c && (u.currentStyle = {
          ...h
        }, t[b](h));
      });
    }), c = !1;
  }
  function v() {
    i = () => {
      const {
        immediate: e,
        autoStart: l
      } = t;
      e ? s() : l && y();
    }, y = () => {
      n.value && n.value.start();
    }, s = () => {
      n.value && n.value.end();
    }, m = () => {
      c = !0, n.value && n.value.destroy();
    };
  }
  return () => {
    const e = F.default, l = {};
    return Object.keys(u.currentStyle).forEach((o) => {
      ["height", "width", "left", "right", "top", "bottom", "maxHeight", "minHeight", "maxWidth", "minWidth"].includes(o) ? typeof u.currentStyle[o] == "number" && (l[o] = u.currentStyle[o] + "px") : l[o] = u.currentStyle[o];
    }), typeof e == "function" && n.value ? e(l) : I(e) ? e : null;
  };
}, {
  props: A,
  name: "Animation"
});
export {
  M as default,
  A as vuePropsType
};
//# sourceMappingURL=Animation.js.map
