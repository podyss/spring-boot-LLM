import { createVNode as t, defineComponent as K, useSlots as Q, reactive as W, ref as L, watch as Y, mergeProps as v, isVNode as ee, Fragment as oe } from "vue";
import $ from "classnames";
import * as o from "../PropTypes";
import { vuePropsMake as ne } from "../PropTypes";
import { noop as C, isFunction as te, omit as B, get as F } from "lodash";
import { cssClasses as E, numbers as ie } from '@douyinfe/semi-foundation/lib/es/popconfirm/constants';
import se from '@douyinfe/semi-foundation/lib/es/popconfirm/popconfirmFoundation';
import { IconAlertTriangle as le, IconClose as ce } from "@kousum/semi-icons-vue";
import ae, { vuePropsType as re } from "../popover";
import h from "../button";
import ue from "../locale/localeConsumer";
import '@douyinfe/semi-foundation/lib/es/popconfirm/popconfirm.css';
import { useConfigContext as de } from "../configProvider/context/Consumer";
import { useHasInProps as fe, useBaseComponent as pe } from "../_base/baseComponent";
const me = {
  ...re,
  motion: o.oneOfType([o.bool, o.func, o.object]),
  disabled: o.bool,
  content: o.oneOfType([o.node, o.func]),
  title: o.any,
  prefixCls: o.string,
  className: o.string,
  style: o.object,
  icon: o.oneOfType([o.string, o.node]),
  okText: o.string,
  okType: o.string,
  cancelText: o.string,
  cancelType: o.string,
  onCancel: o.func,
  onConfirm: o.func,
  onClickOutSide: o.func,
  onVisibleChange: o.func,
  visible: o.bool,
  defaultVisible: o.bool,
  okButtonProps: o.object,
  cancelButtonProps: o.object,
  stopPropagation: o.oneOfType([o.bool, o.string]),
  showCloseIcon: o.bool,
  zIndex: o.number,
  // private
  trigger: o.string,
  position: o.string
}, Ce = {
  stopPropagation: !0,
  trigger: "click",
  // position: 'bottomLeft',
  onVisibleChange: C,
  disabled: !1,
  icon: t(le, {
    size: "extra-large"
  }, null),
  okType: "primary",
  cancelType: "tertiary",
  prefixCls: E.PREFIX,
  zIndex: ie.DEFAULT_Z_INDEX,
  showCloseIcon: !0,
  onCancel: C,
  onConfirm: C,
  onClickOutSide: C
}, ge = ne(me, Ce), Fe = /* @__PURE__ */ K({
  props: {
    ...ge
  },
  name: "Popconfirm",
  setup(l, {}) {
    const f = Q(), {
      getProps: j
    } = fe(), {
      context: P
    } = de(), c = W({
      cancelLoading: !1,
      confirmLoading: !1,
      visible: l.defaultVisible || !1
    }), g = L(), T = L(), {
      adapter: N,
      isControlled: R
    } = pe(l, c);
    function z() {
      return {
        ...N(),
        setVisible: (e) => {
          c.visible = e;
        },
        updateConfirmLoading: (e) => {
          c.confirmLoading = e;
        },
        updateCancelLoading: (e) => {
          c.cancelLoading = e;
        },
        notifyConfirm: (e) => l.onConfirm(e),
        notifyCancel: (e) => l.onCancel(e),
        notifyVisibleChange: (e) => l.onVisibleChange(e),
        notifyClickOutSide: (e) => l.onClickOutSide(e),
        focusCancelButton: () => {
          var n;
          const e = (n = g.value) == null ? void 0 : n.querySelector("[data-type=cancel]");
          e == null || e.focus({
            preventScroll: !0
          });
        },
        focusOkButton: () => {
          var n;
          const e = (n = g.value) == null ? void 0 : n.querySelector("[data-type=ok]");
          e == null || e.focus({
            preventScroll: !0
          });
        },
        focusPrevFocusElement: () => {
          var e;
          (e = T.value) == null || e.focusTrigger();
        }
      };
    }
    const D = z(), p = new se(D);
    function _(e, n) {
      const s = {}, {
        hasOwnProperty: a
      } = Object.prototype;
      return a.call(e, "visible") && (s.visible = e.visible), s;
    }
    Y(() => l.visible, (e) => {
      const n = _({
        ...l
      }, {
        ...c
      });
      n && Object.keys(n).forEach((s) => {
        c[s] = n[s];
      });
    }, {
      immediate: !0
    });
    const k = (e) => p.handleCancel(e), q = (e) => p.handleConfirm(e), A = (e) => p.handleVisibleChange(e), U = (e) => p.handleClickOutSide(e), X = (e) => e && e.nativeEvent && e.nativeEvent.stopImmediatePropagation();
    function H() {
      const {
        okText: e,
        cancelText: n,
        okType: s,
        cancelType: a,
        cancelButtonProps: m,
        okButtonProps: r
      } = l, {
        cancelLoading: u,
        confirmLoading: i
      } = c;
      return t(ue, {
        componentName: "Popconfirm"
      }, {
        default: (d, y) => t(oe, null, [t(h, v({
          "data-type": "cancel",
          type: a,
          onClick: k,
          loading: u
        }, B(m, "autoFocus")), {
          default: () => [n || F(d, "cancel")]
        }), t(h, v({
          "data-type": "ok",
          type: s,
          theme: "solid",
          onClick: q,
          loading: i
        }, B(r, "autoFocus")), {
          default: () => [e || F(d, "confirm")]
        })])
      });
    }
    function M({
      initialFocusRef: e
    }) {
      const {
        content: n,
        title: s,
        className: a,
        style: m,
        cancelType: r,
        icon: u,
        prefixCls: i,
        showCloseIcon: d
      } = l, {
        direction: y
      } = P.value, x = $(i, a, {
        [`${i}-rtl`]: y === "rtl"
      }), O = s !== null && typeof s < "u", I = !(n === null || typeof n > "u"), b = ee(u), S = $({
        [`${i}-body`]: !0,
        [`${i}-body-withIcon`]: b
      });
      return (
        // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
        t("div", {
          class: x,
          onClick: X,
          style: m
        }, [t("div", {
          class: `${i}-inner`
        }, [t("div", {
          class: `${i}-header`
        }, [b ? t("i", {
          class: `${i}-header-icon`,
          "x-semi-prop": "icon"
        }, [u]) : null, t("div", {
          class: `${i}-header-body`
        }, [O ? t("div", {
          class: `${i}-header-title`,
          "x-semi-prop": "title"
        }, [s]) : null]), d ? t(h, {
          className: `${i}-btn-close`,
          icon: t(ce, null, null),
          size: "small",
          theme: "borderless",
          type: r,
          onClick: k
        }, null) : null]), I ? t("div", {
          class: S,
          "x-semi-prop": "content"
        }, [te(n) ? n({
          initialFocusRef: e
        }) : n]) : null, t("div", {
          class: `${i}-footer`,
          ref: g
        }, [H()])])])
      );
    }
    return () => {
      var w;
      const {
        direction: e
      } = P.value, n = e === "rtl" ? "bottomRight" : "bottomLeft", s = (w = f.default) == null ? void 0 : w.call(f), {
        className: a,
        prefixCls: m,
        disabled: r,
        style: u,
        position: i = n,
        title: d,
        icon: y,
        okType: x,
        cancelType: O,
        defaultVisible: I,
        okButtonProps: b,
        cancelButtonProps: S,
        onCancel: ye,
        onConfirm: be,
        showCloseIcon: ve,
        ...Z
      } = j(l);
      if (r)
        return s;
      const {
        visible: G
      } = c, V = {
        onVisibleChange: A,
        className: E.POPOVER,
        onClickOutSide: U
      };
      return R("visible") && (V.trigger = "custom"), t(ae, v({
        ref: T
      }, {
        ...Z,
        // A arrow function needs to be passed here, otherwise the content will not be updated after the Popconfirm state is updated
        // Popover is a PureComponent, same props will not trigger update
        content: ({
          initialFocusRef: J
        }) => M({
          initialFocusRef: J
        }),
        visible: G,
        position: i,
        ...V
      }), {
        default: f.default
      });
    };
  }
});
export {
  Fe as default,
  ge as vuePropsType
};
//# sourceMappingURL=index.js.map
