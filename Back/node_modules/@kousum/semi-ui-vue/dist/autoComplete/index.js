import { defineComponent as Y, useSlots as ee, reactive as oe, ref as x, onMounted as te, onUnmounted as ne, watch as A, createVNode as y, isVNode as ie, mergeProps as k } from "vue";
import * as e from "../PropTypes";
import { vuePropsMake as re } from "../PropTypes";
import I from "classnames";
import { isEqual as ae, noop as g } from "lodash";
import { cssClasses as se, strings as D } from '@douyinfe/semi-foundation/lib/es/autoComplete/constants';
import le from '@douyinfe/semi-foundation/lib/es/autoComplete/foundation';
import { numbers as ue } from '@douyinfe/semi-foundation/lib/es/popover/constants';
import { useBaseComponent as de } from "../_base/baseComponent";
import ce from "../spin";
import fe from "../popover";
import pe from "../input";
import me from "../trigger";
import { getUuidShort as ge } from '@douyinfe/semi-foundation/lib/es/utils/uuid';
import ye from "./option";
import be from '@douyinfe/semi-foundation/lib/es/utils/warning';
import '@douyinfe/semi-foundation/lib/es/autoComplete/autoComplete.css';
import { styleNum as L } from "../_utils";
function he(h) {
  return typeof h == "function" || Object.prototype.toString.call(h) === "[object Object]" && !ie(h);
}
const b = se.PREFIX;
D.SIZE;
D.POSITION;
D.STATUS;
function Ce() {
  const h = E();
  return /* @__PURE__ */ Y({
    props: h,
    name: "AutoComplete",
    setup(n, {}) {
      ee();
      const a = oe({
        dropdownMinWidth: null,
        inputValue: "",
        // option list
        options: [],
        // popover visible
        visible: !1,
        // current focus option index
        focusIndex: n.defaultActiveFirstOption ? 0 : -1,
        // current selected options
        selection: /* @__PURE__ */ new Map(),
        rePosKey: 1
      });
      let v = null;
      const {
        adapter: N,
        getDataAttr: V
      } = de(n, a);
      function j() {
        const t = {
          registerKeyDown: (o) => {
            const r = {
              onKeyDown: o
            };
            a.keyboardEventSet = r;
          },
          unregisterKeyDown: (o) => {
            a.keyboardEventSet = {};
          },
          updateFocusIndex: (o) => {
            a.focusIndex = o;
          },
          updateScrollTop: (o) => {
            let r;
            r = `.${b}-option-selected`, o !== void 0 && (r = `.${b}-option:nth-child(${o + 1})`);
            let i = document.querySelector(`#${b}-${O} ${r}`);
            if (Array.isArray(i) && (i = i[0]), i) {
              const s = i.parentNode;
              s.scrollTop = i.offsetTop - s.offsetTop - s.clientHeight / 2 + i.clientHeight / 2;
            }
          }
        };
        return {
          ...N(),
          ...t,
          getTriggerWidth: () => {
            const o = S.value;
            return o && o.getBoundingClientRect().width;
          },
          setOptionWrapperWidth: (o) => {
            a.dropdownMinWidth = o;
          },
          updateInputValue: (o) => {
            a.inputValue = o;
          },
          toggleListVisible: (o) => {
            a.visible = o;
          },
          updateOptionList: (o) => {
            a.options = o;
          },
          updateSelection: (o) => {
            a.selection = o;
          },
          notifySearch: (o) => {
            n.onSearch(o);
          },
          notifyChange: (o) => {
            n.onChange(o);
          },
          notifySelect: (o) => {
            n.onSelect(o);
          },
          notifyDropdownVisibleChange: (o) => {
            n.onDropdownVisibleChange(o);
          },
          notifyClear: () => {
            n.onClear();
          },
          notifyFocus: (o) => {
            n.onFocus(o);
          },
          notifyBlur: (o) => {
            n.onBlur(o);
          },
          notifyKeyDown: (o) => {
            n.onKeyDown(o);
          },
          rePositionDropdown: () => {
            let {
              rePosKey: o
            } = a;
            o = o + 1, a.rePosKey = o;
          },
          registerClickOutsideHandler: (o) => {
            v = (i) => {
              var m, l;
              const s = P && ((l = (m = P.value).getRef) == null ? void 0 : l.call(m).vnode.el), d = S && S.value, f = s, c = i.target, p = i.composedPath && i.composedPath() || [c];
              f && (!f.contains(c) || !f.contains(c.parentNode)) && d && !d.contains(c) && !(p.includes(d) || p.includes(f)) && o(i);
            }, document.addEventListener("mousedown", v, !1);
          },
          unregisterClickOutsideHandler: () => {
            v && document.removeEventListener("mousedown", v, !1);
          }
        };
      }
      const K = j(), u = new le(K), S = x(), P = x();
      let O = "";
      be("triggerRender" in n && typeof n.triggerRender == "function", `[Semi AutoComplete]
            - If you are using the following props: 'suffix', 'prefix', 'showClear', 'validateStatus', and 'size',
            please notice that they will be removed in the next major version.
            Please use 'componentProps' to retrieve these props instead.
            - If you are using 'onBlur', 'onFocus', please try to avoid using them and look for changes in the future.`), te(() => {
        u.init(), O = ge();
      }), ne(() => {
        u.destroy();
      }), A(() => n.value, (t, o, r) => {
        t !== o && u.handleValueChange(n.value);
      }), A(() => n.data, (t, o, r) => {
        ae(t, o) || u.handleDataChange(n.data);
      }, {
        deep: !0
      });
      const W = (t, o, r) => {
        u.handleSelect(t, o);
      }, R = (t, o) => {
        u.handleSearch(t);
      }, H = (t) => u.handleBlur(t), $ = (t) => u.handleFocus(t), B = () => u.handleClear(), M = (t) => u.handleInputClick(t);
      function z() {
        const {
          size: t,
          prefix: o,
          insetLabel: r,
          insetLabelId: i,
          suffix: s,
          placeholder: d,
          style: f,
          className: c,
          showClear: p,
          disabled: m,
          triggerRender: l,
          validateStatus: C,
          autoFocus: X,
          value: w,
          id: Z
        } = n, {
          inputValue: F,
          keyboardEventSet: G,
          selection: J
        } = a, Q = {
          style: f,
          className: typeof l == "function" ? I(c) : I({
            [b]: !0,
            [`${b}-disabled`]: m
          }, c),
          onClick: M,
          ref: S,
          id: Z,
          ...G,
          // tooltip give tabindex 0 to children by default, autoComplete just need the input get focus, so outer div's tabindex set to -1
          tabIndex: -1,
          ...V()
        }, T = {
          disabled: m,
          placeholder: d,
          autoFocus: X,
          // @ts-ignore
          onChange: R,
          onClear: B,
          "aria-label": n["aria-label"],
          "aria-labelledby": n["aria-labelledby"],
          "aria-invalid": n["aria-invalid"],
          "aria-errormessage": n["aria-errormessage"],
          "aria-describedby": n["aria-describedby"],
          "aria-required": n["aria-required"],
          // TODO: remove in next major version
          suffix: s,
          // @ts-ignore
          prefix: o || r,
          insetLabelId: i,
          showClear: p,
          validateStatus: C,
          size: t,
          onBlur: H,
          onFocus: $
        };
        return y("div", Q, [typeof l == "function" ? y(me, k(T, {
          inputValue: typeof w < "u" ? w : F,
          value: Array.from(J.values()),
          triggerRender: l,
          componentName: "AutoComplete",
          componentProps: {
            ...n
          }
        }), null) : y(pe, k(T, {
          value: typeof w < "u" ? w : F
        }), null)]);
      }
      function _() {
        const t = `${b}-loading-wrapper`;
        return y("div", {
          class: t
        }, [y(ce, null, null)]);
      }
      function q(t, o) {
        const {
          focusIndex: r
        } = a;
        return y(ye, {
          showTick: !1,
          onSelect: (s, d) => W(s, o),
          focused: o === r,
          onMouseEnter: () => u.handleOptionMouseEnter(o),
          key: t.key || t.label + t.value + o,
          option: t
        }, {
          default: () => [t.label]
        });
      }
      function U() {
        const {
          maxHeight: t,
          dropdownStyle: o,
          dropdownClassName: r,
          loading: i,
          emptyContent: s
        } = n, {
          options: d,
          dropdownMinWidth: f
        } = a, c = I({
          [`${b}-option-list`]: !0
        }, r);
        let p;
        d.length === 0 ? p = s == null ? void 0 : s() : p = d.filter((l) => l.show).map((l, C) => q(l, C));
        const m = {
          maxHeight: L(t),
          minWidth: L(f),
          ...o
        };
        return y("div", {
          class: c,
          role: "listbox",
          style: m,
          id: `${b}-${O}`
        }, [i ? _() : p]);
      }
      return () => {
        const {
          position: t,
          motion: o,
          zIndex: r,
          mouseEnterDelay: i,
          mouseLeaveDelay: s,
          autoAdjustOverflow: d,
          stopPropagation: f,
          getPopupContainer: c
        } = n, {
          visible: p,
          rePosKey: m
        } = a, l = z(), C = U();
        return y(fe, {
          mouseEnterDelay: i,
          mouseLeaveDelay: s,
          autoAdjustOverflow: d,
          trigger: "custom",
          motion: o,
          visible: p,
          content: C,
          position: t,
          ref: P,
          zIndex: r,
          stopPropagation: f,
          getPopupContainer: c,
          rePosKey: m
        }, he(l) ? l : {
          default: () => [l]
        });
      };
    }
  });
}
function E() {
  const h = {
    "aria-label": e.string,
    "aria-labelledby": e.string,
    "aria-invalid": [e.bool, e.string],
    "aria-errormessage": e.string,
    "aria-describedby": e.string,
    "aria-required": e.bool,
    autoFocus: e.bool,
    autoAdjustOverflow: e.bool,
    className: e.string,
    children: e.node,
    data: e.array,
    defaultOpen: e.bool,
    defaultValue: e.oneOfType([e.string, e.number]),
    defaultActiveFirstOption: e.bool,
    disabled: e.bool,
    dropdownMatchSelectWidth: e.bool,
    dropdownClassName: e.string,
    dropdownStyle: e.object,
    emptyContent: e.func,
    id: e.string,
    insetLabel: e.node,
    insetLabelId: e.string,
    onSearch: e.func,
    onSelect: e.func,
    onClear: e.func,
    onBlur: e.func,
    onFocus: e.func,
    onChange: e.func,
    onKeyDown: e.func,
    position: String,
    placeholder: e.string,
    prefix: e.node,
    onChangeWithObject: e.bool,
    onSelectWithObject: e.bool,
    onDropdownVisibleChange: e.func,
    renderItem: e.func,
    renderSelectedItem: e.func,
    suffix: e.node,
    showClear: e.bool,
    size: String,
    style: e.object,
    stopPropagation: e.oneOfType([e.bool, e.string]),
    maxHeight: e.oneOfType([e.string, e.number]),
    mouseEnterDelay: e.number,
    mouseLeaveDelay: e.number,
    motion: e.oneOfType([e.bool, e.func, e.object]),
    getPopupContainer: e.func,
    triggerRender: e.func,
    value: e.oneOfType([e.string, e.number]),
    validateStatus: String,
    zIndex: e.number,
    loading: e.bool
  }, n = {
    stopPropagation: !0,
    motion: !0,
    zIndex: ue.DEFAULT_Z_INDEX,
    position: "bottomLeft",
    data: [],
    showClear: !1,
    size: "default",
    onFocus: g,
    onSearch: g,
    onClear: g,
    onBlur: g,
    onSelect: g,
    onChange: g,
    onSelectWithObject: !1,
    onDropdownVisibleChange: g,
    defaultActiveFirstOption: !1,
    dropdownMatchSelectWidth: !0,
    loading: !1,
    maxHeight: 300,
    validateStatus: "default",
    autoFocus: !1,
    emptyContent: g,
    onKeyDown: g
    // onPressEnter: () => undefined,
    // defaultOpen: false,
  };
  return re(h, n);
}
const Re = E(), He = Ce();
export {
  Ce as AutoCompleteFunc,
  He as default,
  Re as vuePropsType
};
//# sourceMappingURL=index.js.map
