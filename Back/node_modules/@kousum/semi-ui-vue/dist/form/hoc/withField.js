import { defineComponent as it, useSlots as nt, shallowRef as Ie, ref as H, watch as Te, onBeforeUnmount as st, createVNode as m, unref as dt, mergeProps as ue, Fragment as $e, withMemo as ut, isVNode as ft, onBeforeMount as mt, onMounted as ct } from "vue";
import X from "classnames";
import * as d from "../../PropTypes";
import { cssClasses as pt } from '@douyinfe/semi-foundation/lib/es/form/constants';
import { mergeProps as a, transformTrigger as fe, mergeOptions as We, generateValidatesFromRules as gt, transformDefaultBooleanAPI as bt } from '@douyinfe/semi-foundation/lib/es/form/utils';
import { isValid as z } from "./utils";
import * as vt from '@douyinfe/semi-foundation/lib/es/utils/object';
import ht from '@douyinfe/semi-foundation/lib/es/utils/isPromise';
import Ne from '@douyinfe/semi-foundation/lib/es/utils/warning';
import { useArrayFieldState as yt, useStateWithGetter as me, useFormState as xt } from "../hooks/index";
import St from "../errorMessage";
import { isElement as je } from "../../_base/reactUtils";
import Vt from "../label";
import { Col as ce } from "../../grid";
import { useFormUpdaterContext as Ct } from "../context/FormUpdaterContext/Consumer";
import { omit as wt } from "lodash";
import { useHasInProps as Pt } from "../../_base/baseComponent";
function pe(x) {
  return typeof x == "function" || Object.prototype.toString.call(x) === "[object Object]" && !ft(x);
}
const y = pt.PREFIX, Et = typeof window < "u" ? mt : ct;
function el(x, ge, Ae) {
  const be = x.props || {}, J = {};
  Object.keys(be).forEach((n) => {
    J[n] = {
      ...be[n],
      default: void 0
    }, delete J[n].default;
  });
  const Be = {
    ...wt(
      {
        ...J,
        ...Ae || {}
      },
      // 'style',
      "class",
      "key"
    ),
    label: [...d.node, d.func],
    id: [String],
    field: {
      type: String,
      required: !0
    },
    className: String,
    prefix: String,
    labelPosition: String,
    labelAlign: String,
    labelWidth: [String, Number],
    noLabel: Boolean,
    noErrorMessage: Boolean,
    name: String,
    fieldClassName: String,
    fieldStyle: Object,
    initValue: d.any,
    validate: [...d.node, Function],
    /** Check rules, check library based on async-validator */
    rules: d.array,
    /** Check trigger timing */
    trigger: [d.string, d.array],
    // onChange: (fieldValue: any) => void;
    /** Converts form control values before validation */
    transform: d.func,
    /** Make a second change to the component's value before the UI update */
    convert: d.func,
    allowEmptyString: d.bool,
    /** When true, use rules verification, after encountering the first rule that fails the test, the verification of subsequent rules will no longer be triggered */
    stopValidateWithError: d.bool,
    /* Custom prompt information is displayed in the same block as the verification information. When both have values, the verification information is displayed first */
    helpText: d.node,
    /* Extra message, you can use this when you need an error message and the prompt text to appear at the same time, after helpText/errorMessage */
    extraText: d.node,
    extraTextPosition: d.string,
    /** These declaration just hack for Subtract, not valid props in CommonFieldProps */
    defaultValue: d.any,
    /** Whether to take over only the data stream, when true, it will not automatically insert modules such as ErrorMessage, Label, extraText, etc. The style and DOM structure are consistent with the original component */
    pure: d.bool
  };
  return /* @__PURE__ */ it({
    props: {
      ...Be
    },
    name: "Form" + x.name,
    //@ts-ignore
    setup(n, {
      attrs: L
    }) {
      const Q = nt(), {
        getProps: Le,
        hasInProps: Me
      } = Pt();
      function r() {
        return Le({
          ...L,
          ...n
        });
      }
      const {
        context: f
      } = Ct();
      let {
        context: ve
      } = yt(), he = typeof a(r()).field < "u" ? f.value.getValue(a(r()).field) : void 0, T = typeof a(r()).initValue < "u" ? a(r()).initValue : he;
      try {
        ve.value && (T = ve.value.shouldUseInitValue && typeof a(r()).initValue < "u" ? a(r()).initValue : he);
      } catch {
      }
      const [Y, Re, ye] = me(typeof T !== void 0 ? T : null), P = Ie(!1), Z = H(a(r()).rules), ee = H(n.validate), $ = Ie(null), M = (e, l) => {
        let {
          field: t
        } = a(r());
        De(e), f.value.updateStateTouched(t, e, l);
      }, b = (e, l) => {
        if (P.value)
          return;
        let {
          field: t
        } = a(r());
        e !== Ge() && (qe(e), f.value.updateStateError(t, e, l), z(e) ? E("success") : E("error"));
      };
      function te(e) {
        return e || f.value.getFormProps().allowEmpty;
      }
      const le = (e, l) => {
        let {
          field: t,
          allowEmpty: o
        } = a(r());
        o = te(o), Re(e);
        let i = {
          ...l,
          allowEmpty: o
        };
        f.value.updateStateValue(t, e, i);
      }, Ue = () => {
        let e = {
          notNotify: !0,
          notUpdate: !0
        };
        le(T !== null ? T : void 0, e), b(void 0, e), M(void 0, e), E("default");
      }, _e = (e, l) => {
        let t = Z.value || [];
        const o = gt(a(r()).field, t), i = {
          [a(r()).field]: e
        };
        let {
          stopValidateWithError: s
        } = a(r()), u = f.value.getFormProps(["labelPosition", "labelWidth", "labelAlign", "labelCol", "wrapperCol", "disabled", "showValidateIcon", "extraTextPosition", "stopValidateWithError", "trigger"]), p = bt(s, u.stopValidateWithError, !1);
        const S = new Promise((v, c) => {
          o.validate(
            i,
            {
              first: p
            },
            // eslint-disable-next-line @typescript-eslint/no-empty-function
            (h, w) => {
            }
          ).then((h) => {
            P.value || $.value !== S || (E("success"), b(void 0, l), v({}));
          }).catch((h) => {
            if (P.value || $.value !== S)
              return;
            let {
              errors: w,
              fields: ae
            } = h;
            if (w && ae) {
              let F = w.map((_) => _.message);
              F.length === 1 && (F = F[0]), b(F, l), z(F) || (E("error"), v(w));
            } else
              throw E("error"), b(h.message, l), v(h.message), h;
          });
        });
        return $.value = S, S;
      }, Ke = (e, l, t) => {
        const o = new Promise((i) => {
          let s;
          try {
            s = ee.value(e, l);
          } catch (u) {
            s = u;
          }
          s === void 0 ? (i({}), b(void 0, t)) : ht(s) ? s.then((u) => {
            P.value || $.value !== o || (z(u) ? (b(void 0, t), i(null)) : (b(u, t), i(u)));
          }) : z(s) ? (b(void 0, t), i(null)) : (b(s, t), i(s));
        });
        return $.value = o, o;
      }, R = (e, l) => {
        let t = e, o = Z.value;
        return a(r()).transform && (t = a(r()).transform(e)), ee.value ? Ke(t, f.value.getValue(), l) : o ? _e(t, l) : null;
      }, Oe = (e, l, ...t) => {
        let {
          trigger: o,
          emptyValue: i
        } = a(r()), {
          allowEmptyString: s,
          allowEmpty: u
        } = a(r());
        u = te(u);
        let {
          options: p,
          shouldInject: S
        } = We(ge, L), v = p.onKeyChangeFnName;
        Me(v) && typeof n[p.onKeyChangeFnName] == "function" && n[p.onKeyChangeFnName](e, l, ...t);
        let c;
        p.valuePath ? c = vt.get(e, p.valuePath) : c = e, typeof a(r()).convert == "function" && (c = a(r()).convert(c)), s || u || c === i && (c = void 0);
        try {
          l && l.target && l.target.selectionStart && He(l.target.selectionStart);
        } catch {
        }
        M(!0, {
          notNotify: !0,
          notUpdate: !0
        }), le(c);
        let h = f.value.getFormProps(["labelPosition", "labelWidth", "labelAlign", "labelCol", "wrapperCol", "disabled", "showValidateIcon", "extraTextPosition", "stopValidateWithError", "trigger"]);
        fe(o, h.trigger).includes("change") && R(c);
      }, ke = (e) => {
        let {
          trigger: l
        } = a(r()), t = f.value.getFormProps(["labelPosition", "labelWidth", "labelAlign", "labelCol", "wrapperCol", "disabled", "showValidateIcon", "extraTextPosition", "stopValidateWithError", "trigger"]), o = fe(l, t.trigger);
        if (n.onBlur && n.onBlur(e), U.value || M(!0), o.includes("blur")) {
          let i = ye();
          R(i);
        }
      };
      xt();
      const [re, qe, Ge] = me(), U = H();
      function De(e) {
        U.value = e;
      }
      const [It, He, Tt] = me(0), W = H(a(r()).validateStatus);
      function E(e) {
        W.value = e;
      }
      return Te([() => n.rules, () => n.validate], () => {
        Z.value = a(r()).rules, ee.value = n.validate;
      }, {
        immediate: !0
      }), Et(() => {
        let {
          trigger: e
        } = a(r()), l = f.value.getFormProps(["labelPosition", "labelWidth", "labelAlign", "labelCol", "wrapperCol", "disabled", "showValidateIcon", "extraTextPosition", "stopValidateWithError", "trigger"]);
        const o = fe(e, l.trigger).includes("mount");
        P.value = !1, o && R(Y);
      }), st(() => {
        P.value = !0;
      }), Te(() => n.field, (e, l, t) => {
        let {
          // condition,
          field: o,
          allowEmptyString: i,
          allowEmpty: s,
          keepState: u
        } = a(r());
        s = te(s);
        const p = {
          setValue: le,
          setTouched: M,
          setError: b,
          reset: Ue,
          validate: R
        };
        if (typeof o > "u")
          return () => {
          };
        const S = ye();
        f.value.register(o, {
          value: S,
          error: re.value,
          touched: U,
          status: W.value
        }, {
          field: o,
          fieldApi: p,
          keepState: u,
          allowEmpty: s || i
        }), t(() => {
          const v = a(r()).field;
          v && f.value.unRegister(v);
        });
      }, {
        immediate: !0
      }), (e, l) => {
        const t = n.label, o = n.id;
        let {
          // condition,
          field: i,
          labelPosition: s,
          labelWidth: u,
          labelAlign: p,
          labelCol: S,
          wrapperCol: v,
          noLabel: c,
          noErrorMessage: h,
          isInInputGroup: w,
          initValue: ae,
          validate: F,
          validateStatus: _,
          trigger: $t,
          allowEmptyString: Wt,
          allowEmpty: Nt,
          emptyValue: jt,
          rules: At,
          required: xe,
          keepState: Bt,
          transform: Lt,
          name: N,
          fieldClassName: K,
          fieldStyle: Xe,
          convert: Mt,
          stopValidateWithError: Rt,
          helpText: oe,
          extraText: j,
          extraTextPosition: ze,
          pure: Je,
          rest: Se
        } = a(r());
        const ie = n.prefix ? {
          ...Se,
          prefix: n.prefix
        } : Se;
        let {
          options: ne,
          shouldInject: Qe
        } = We(ge, L);
        if (Ne(typeof i > "u" && ne.shouldInject, "[Semi Form]: 'field' is required, please check your props of Field Component"), !Qe)
          return m(x, ie, {
            default: Q.default
          });
        if (!f.value.getFormProps)
          return Ne(!0, "[Semi Form]: Field Component must be use inside the Form, please check your dom declaration"), null;
        const Ye = {
          value: Y.value,
          error: re.value,
          touched: U.value,
          status: W.value
        };
        let V = f.value.getFormProps(["labelPosition", "labelWidth", "labelAlign", "labelCol", "wrapperCol", "disabled", "showValidateIcon", "extraTextPosition"]), A = s || V.labelPosition, Ze = u || V.labelWidth, O = p || V.labelAlign, se = S || V.labelCol, Ve = v || V.wrapperCol, B = ze || V.extraTextPosition || "bottom";
        const I = o || i, k = `${I}-label`, q = `${I}-helpText`, G = `${I}-extraText`, Ce = `${I}-errormessage`;
        let we = _ || W.value;
        const et = X(`${y}-field-extra`, {
          [`${y}-field-extra-string`]: typeof j == "string",
          [`${y}-field-extra-middle`]: B === "middle",
          [`${y}-field-extra-botttom`]: B === "bottom"
        }), Pe = j ? m("div", {
          class: et,
          id: G,
          "x-semi-prop": "extraText"
        }, [j]) : null;
        let g = {
          id: I,
          disabled: V.disabled,
          ...ie,
          onBlur: ke,
          [ne.onKeyChangeFnName]: Oe,
          // value 为Ref 对象
          [ne.valueKey]: dt(Y),
          validateStatus: we,
          "aria-required": xe,
          "aria-labelledby": k
        };
        oe && (g["aria-describedby"] = j ? `${q} ${G}` : q), j && (g["aria-describedby"] = oe ? `${q} ${G}` : G), W.value === "error" && (g["aria-errormessage"] = Ce, g["aria-invalid"] = !0);
        const tt = X({
          [`${y}-field`]: !0,
          [`${y}-field-${N}`]: !!N,
          [K]: !!K
        }), lt = X({
          [`${y}-field-main`]: !0
        });
        A === "inset" && !c && (g.insetLabel = t || i, g.insetLabelId = k, typeof t == "object" && !je(t) && (g.insetLabel = t.text, g.insetLabelId = k));
        const Ee = m(x, g, {
          default: Q.default
        });
        if (w)
          return Ee;
        if (Je) {
          let de = X(ie.className, {
            [`${y}-field-pure`]: !0,
            [`${y}-field-${N}`]: !!N,
            [K]: !!K
          });
          return g.className = de, m(x, g, {
            default: Q.default
          });
        }
        let rt = se && Ve;
        const Fe = O ? `${y}-col-${O}` : "";
        let C = null;
        if (!c && A !== "inset") {
          let de = typeof t == "object" && !je(t) ? t : {};
          C = // @ts-ignore
          m(Vt, ue({
            text: t || i,
            id: k,
            required: xe,
            name: I || N || i,
            width: Ze,
            align: O
          }, de), null);
        }
        const D = m("div", {
          class: lt
        }, [B === "middle" ? Pe : null, Ee, h ? null : m(St, {
          error: re.value,
          validateStatus: we,
          helpText: oe,
          helpTextId: q,
          errorMessageId: Ce,
          showValidateIcon: V.showValidateIcon
        }, null), B === "bottom" ? Pe : null]), at = m($e, null, [A === "top" ? m("div", {
          style: {
            overflow: "hidden"
          }
        }, [m(ce, ue(se, {
          className: Fe
        }), pe(C) ? C : {
          default: () => [C]
        })]) : m(ce, ue(se, {
          className: Fe
        }), pe(C) ? C : {
          default: () => [C]
        }), m(ce, Ve, pe(D) ? D : {
          default: () => [D]
        })]), ot = [...Object.values(Ye), ...Object.values(L), ...Object.values(n), i, A, O, V.disabled];
        return ut(ot, () => m("div", {
          class: tt,
          style: Xe,
          "x-label-pos": A,
          "x-field-id": i,
          "x-extra-pos": B
        }, [rt ? at : m($e, null, [C, D])]), l, 0);
      };
    }
  });
}
export {
  el as default
};
//# sourceMappingURL=withField.js.map
