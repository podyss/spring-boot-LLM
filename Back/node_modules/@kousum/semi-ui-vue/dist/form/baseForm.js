import { defineComponent as N, useSlots as U, getCurrentInstance as X, reactive as W, onMounted as _, onUnmounted as q, createVNode as m, mergeProps as Y, isVNode as z, nextTick as C } from "vue";
import B from "classnames";
import * as e from "../PropTypes";
import { vuePropsMake as G } from "../PropTypes";
import H from '@douyinfe/semi-foundation/lib/es/form/foundation';
import { cssClasses as f } from '@douyinfe/semi-foundation/lib/es/form/constants';
import { getUuidv4 as J } from '@douyinfe/semi-foundation/lib/es/utils/uuid';
import F from '@douyinfe/semi-foundation/lib/es/utils/warning';
import { FormUpdaterContext as K, FormApiContext as L, FormStateContext as Q } from "./context";
import { isEmptyChildren as S } from "../_base/reactUtils";
import Z from "../grid/row";
import { cloneDeep as k } from "../_utils/index";
import { noop as s } from "lodash";
import '@douyinfe/semi-foundation/lib/es/form/form.css';
import { useBaseComponent as oo } from "../_base/baseComponent";
function eo(t) {
  return typeof t == "function" || Object.prototype.toString.call(t) === "[object Object]" && !z(t);
}
const b = f.PREFIX, to = {
  "aria-label": e.string,
  onSubmit: e.func,
  onSubmitFail: e.func,
  /* Triggered from update, including field mount/unmount/value change/blur/verification status change/error prompt change, input parameter is formState, currentField */
  onChange: e.func,
  onReset: e.func,
  // Triggered when the value of the form is updated, only when the value of the subfield changes. The entry parameter is formState.values
  onValueChange: e.func,
  onErrorChange: e.func,
  autoScrollToError: e.oneOfType([e.bool, e.object]),
  allowEmpty: e.bool,
  className: e.string,
  component: e.oneOfType([e.node, e.func]),
  disabled: e.bool,
  extraTextPosition: e.string,
  getFormApi: e.func,
  initValues: e.object,
  validateFields: e.func,
  layout: e.string,
  labelPosition: e.string,
  labelWidth: e.oneOfType([e.number, e.string]),
  labelAlign: e.string,
  labelCol: e.object,
  // Control labelCol {span: number, offset: number} for all field child nodes
  render: e.func,
  style: e.object,
  showValidateIcon: e.bool,
  stopValidateWithError: e.bool,
  stopPropagation: e.object,
  id: e.string,
  wrapperCol: e.object,
  // Control wrapperCol {span: number, offset: number} for all field child nodes
  trigger: [String, Array]
}, no = {
  onChange: s,
  onSubmitFail: s,
  onSubmit: s,
  onReset: s,
  onValueChange: s,
  onErrorChange: s,
  layout: "vertical",
  labelPosition: "top",
  allowEmpty: !1,
  autoScrollToError: !1,
  showValidateIcon: !0
}, ro = G(to, no), Uo = /* @__PURE__ */ N({
  props: {
    ...ro
  },
  name: "Form",
  setup(t, {
    expose: y
  }) {
    const a = U();
    let P = X();
    const u = W({
      formId: ""
    });
    F(!!(t.component && t.render), "[Semi Form] You should not use <Form component> and <Form render> in ths same time; <Form render> will be ignored"), F(t.component && a.default && !S(a.default()), "[Semi Form] You should not use <Form component> and <Form>{children}</Form> in ths same time; <Form>{slots.default()}</Form> will be ignored"), F(t.render && a.default && !S(a.default()), "[Semi Form] You should not use <Form render> and <Form>{children}</Form> in ths same time; <Form>{slots.default()}</Form> will be ignored");
    const {
      adapter: E
    } = oo(t, u);
    function I() {
      return {
        ...E(),
        cloneDeep: k,
        notifySubmit: (o, n) => {
          t.onSubmit(o, n);
        },
        notifySubmitFail: (o, n, r) => {
          t.onSubmitFail(o, n, r);
        },
        forceUpdate: (o) => {
          C(() => {
            P.proxy.$forceUpdate(), C(() => {
              o == null || o();
            });
          });
        },
        notifyChange: (o) => {
          t.onChange(o);
        },
        notifyValueChange: (o, n) => {
          t.onValueChange(o, n);
        },
        notifyErrorChange: (o, n) => {
          t.onErrorChange(o, n);
        },
        notifyReset: () => {
          t.onReset();
        },
        initFormId: () => {
          u.formId = J();
        },
        getInitValues: () => t.initValues,
        getFormProps: (o) => {
          if (typeof o > "u")
            return t;
          if (typeof o == "string")
            return t[o];
          {
            const n = {};
            return o.forEach((r) => {
              n[r] = t[r];
            }), n;
          }
        },
        getAllErrorDOM: () => {
          const {
            formId: o
          } = u, {
            id: n
          } = t, r = n || o;
          return document.querySelectorAll(`form[x-form-id="${r}"] .${f.PREFIX}-field-error-message`);
        },
        getFieldDOM: (o) => document.querySelector(`.${f.PREFIX}-field[x-field-id="${o}"]`),
        getFieldErrorDOM: (o) => {
          const {
            formId: n
          } = u, {
            id: r
          } = t;
          let d = `form[x-form-id="${r || n}"] .${f.PREFIX}-field[x-field-id="${o}"] .${f.PREFIX}-field-error-message`;
          return document.querySelector(d);
        }
      };
    }
    const v = I(), i = new H(v);
    let p = i.getFormApi();
    y({
      formApi: p
    }), t.getFormApi && t.getFormApi(p), _(() => {
      i.init();
    }), q(() => {
      i.destroy();
    });
    function x() {
      var d;
      const {
        component: o,
        render: n
      } = t, r = i.getFormState(), l = {
        formState: r,
        formApi: i.getFormApi(),
        values: r.values
      };
      return o ? m(o, l) : n ? n(l) : (d = a.default) == null ? void 0 : d.call(a, l);
    }
    function w(o) {
      o.preventDefault(), t.stopPropagation && t.stopPropagation.submit && o.stopPropagation(), i.submit(o);
    }
    function A(o) {
      o.preventDefault(), t.stopPropagation && t.stopPropagation.reset && o.stopPropagation(), i.reset();
    }
    return () => {
      const n = i.getFormState(!1), r = i.getModifyFormStateApi(), {
        formId: l
      } = u, {
        getFormApi: d,
        onChange: io,
        onSubmit: ao,
        onSubmitFail: lo,
        onErrorChange: mo,
        onValueChange: so,
        component: uo,
        render: fo,
        validateFields: co,
        initValues: go,
        layout: h,
        style: V,
        className: R,
        labelPosition: po,
        labelWidth: Fo,
        labelAlign: bo,
        labelCol: T,
        wrapperCol: j,
        allowEmpty: ho,
        autoScrollToError: Co,
        showValidateIcon: So,
        stopValidateWithError: yo,
        extraTextPosition: Po,
        id: c,
        trigger: Eo,
        ...$
      } = t, O = B(b, R, {
        [b + "-vertical"]: h === "vertical",
        [b + "-horizontal"]: h === "horizontal"
      }), D = j && T, g = m("form", Y({
        style: V
      }, $, {
        onReset: A,
        onSubmit: w,
        class: O,
        id: c || l,
        "x-form-id": c || l
      }), [x()]), M = m(Z, null, eo(g) ? g : {
        default: () => [g]
      });
      return m(K.Provider, {
        value: r
      }, {
        default: () => [m(L.Provider, {
          value: p
        }, {
          default: () => [m(Q.Provider, {
            value: n
          }, {
            default: () => [D ? M : g]
          })]
        })]
      });
    };
  }
});
export {
  Uo as default,
  ro as vuePropsType
};
//# sourceMappingURL=baseForm.js.map
