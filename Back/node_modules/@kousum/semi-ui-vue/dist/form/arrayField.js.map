{"version":3,"file":"arrayField.js","sources":["../../src/components/form/arrayField.tsx"],"sourcesContent":["/* eslint-disable react/destructuring-assignment */\nimport { getUuidv4 } from '@douyinfe/semi-foundation/utils/uuid';\nimport { cloneDeep, isUndefined } from 'lodash';\nimport { FormUpdaterContext, ArrayFieldContext } from './context';\nimport warning from '@douyinfe/semi-foundation/utils/warning';\nimport type { ArrayFieldStaff, FormUpdaterContextType } from '@douyinfe/semi-foundation/form/interface';\nimport { defineComponent, h, onBeforeUnmount, reactive, useSlots, watch } from 'vue';\nimport { useFormUpdaterContext } from './context/FormUpdaterContext/Consumer';\nimport copy from 'fast-copy';\n\nexport interface ArrayFieldProps {\n  initValue?: any[];\n  field?: string;\n}\n\nexport interface ArrayFieldChildrenProps {\n  arrayFields: {\n    key: string;\n    field: string;\n    remove: () => void;\n  }[];\n  add: () => void;\n  addWithInitValue: (lineObject: Record<string, any>) => void;\n}\n\nexport interface ArrayFieldState {\n  keys: string[];\n}\n\nconst filterArrayByIndex = (array: any[], index: number) => array.filter((item, i) => i !== index);\n\nconst getUuidByArray = (array: any[]) => array.map(() => getUuidv4());\n\nconst getUpdateKey = (arrayField: ArrayFieldStaff): string | undefined => {\n  if (!arrayField) {\n    return undefined;\n  }\n  if (arrayField && arrayField.updateKey) {\n    return arrayField.updateKey;\n  }\n  return undefined;\n};\n\nconst initValueAdapter = (initValue: any) => {\n  const iv: any[] = [];\n  if (Array.isArray(initValue)) {\n    return initValue;\n  } else {\n    warning(\n      !isUndefined(initValue),\n      '[Semi Form ArrayField] initValue of ArrayField must be an array. Please check the type of your props'\n    );\n    return iv;\n  }\n};\n\n/**\n *\n * @param {any[]} value\n * @param {string[]} oldKeys\n * @returns string[]\n */\nconst generateKeys = (value: any[], oldKeys?: string[]) => {\n  const val = initValueAdapter(value);\n  const newKeys = getUuidByArray(val);\n  // return newKeys;\n  const keys = newKeys.map((key, i) => (oldKeys && oldKeys[i] ? oldKeys[i] : key));\n  return keys;\n};\n\nexport const vuePropsType = {\n  initValue: Array,\n  field: String,\n};\nconst ArrayFieldComponent = defineComponent({\n  props: { ...vuePropsType },\n  name: 'ArrayFieldComponent',\n  setup(props, {}) {\n    const slots = useSlots();\n    let cacheFieldValues: any[];\n    let shouldUseInitValue: boolean;\n    let cacheUpdateKey: string | number;\n    const { context } = useFormUpdaterContext();\n    const initValueInProps = props.initValue;\n    const initValueInForm = context.value.getValue(props.field);\n    const initValue = initValueInProps || initValueInForm;\n    const state = reactive({\n      keys: generateKeys(initValue),\n    });\n\n    /*\n      If updateKey exists, it means that the arrayField (usually a nested ArrayField not at the first level) is only re-mounted due to setValues,\n      and the fields it contains do not need to consume initValue\n  */\n    // whether the fields inside arrayField should use props.initValue in current render process\n    shouldUseInitValue = !context.value.getArrayField(props.field);\n\n    // Separate the arrays that reset and the usual add and remove modify, otherwise they will affect each other\n    const initValueCopyForFormState = copy(initValue);\n    const initValueCopyForReset = copy(initValue);\n    context.value.registerArrayField(props.field, initValueCopyForReset);\n    // register ArrayField will update state.updateKey to render, So there is no need to execute forceUpdate here\n    context.value.updateStateValue(props.field, initValueCopyForFormState, { notNotify: true, notUpdate: true });\n\n    onBeforeUnmount(() => {\n      const updater = context.value;\n      const { field } = props;\n      updater.unRegisterArrayField(field);\n    });\n\n    watch([() => props.field, () => state.keys], () => {\n      const { field } = props;\n      const { keys } = state;\n      const fieldValues = context.value.getValue(field);\n      const updateKey = getUpdateKey(context.value.getArrayField(field));\n      // when update form outside, like use formApi.setValue('field', [{newItem1, newItem2}]),  formApi.setValues\n      // re generate keys to update arrayField;\n      if (updateKey !== cacheUpdateKey) {\n        const newKeys = generateKeys(fieldValues, keys);\n        // eslint-disable-next-line\n        state.keys = newKeys;\n        cacheUpdateKey = updateKey;\n        if (cacheUpdateKey !== null) {\n          shouldUseInitValue = false;\n        }\n      }\n    });\n\n    function add() {\n      const { keys } = state;\n      const { field } = props;\n      const updater = context.value;\n      keys.push(getUuidv4());\n      shouldUseInitValue = true;\n      state.keys = keys;\n      let updateKey = new Date().valueOf();\n      updater.updateArrayField(field, { updateKey });\n      cacheUpdateKey = updateKey;\n    }\n\n    function addWithInitValue(rowVal: Record<string, any> | string) {\n      const updater = context;\n      const { field } = props;\n      const newArrayFieldVal = updater.value.getValue(field) ? updater.value.getValue(field).slice() : [];\n      const cloneRowVal = copy(rowVal);\n      newArrayFieldVal.push(cloneRowVal);\n      updater.value.updateStateValue(field, newArrayFieldVal, {});\n      updater.value.updateArrayField(field, { updateKey: new Date().valueOf() });\n    }\n\n    function remove(i: number) {\n      const updater = context;\n      const { keys } = state;\n      const { field } = props;\n      const newKeys = filterArrayByIndex(keys, i);\n      // Make sure that all the keys in the line are removed, because some keys are not taken over by the field, only set in the initValue\n      let newArrayFieldError = updater.value.getError(field);\n      const opts = { notNotify: true, notUpdate: true };\n      if (Array.isArray(newArrayFieldError)) {\n        newArrayFieldError = newArrayFieldError.slice();\n        newArrayFieldError.splice(i, 1);\n        updater.value.updateStateError(field, newArrayFieldError, opts);\n      }\n      // if (Array.isArray(newArrayFieldTouched)) {\n      //     newArrayFieldTouched = newArrayFieldTouched.slice();\n      //     newArrayFieldTouched.splice(i, 1);\n      //     updater.updateStateTouched(field, newArrayFieldTouched, opts);\n      // }\n      let newArrayFieldValue = updater.value.getValue(field);\n      if (Array.isArray(newArrayFieldValue)) {\n        newArrayFieldValue = newArrayFieldValue.slice();\n        newArrayFieldValue.splice(i, 1);\n        updater.value.updateStateValue(field, newArrayFieldValue);\n      }\n\n      state.keys = newKeys;\n    }\n\n    return () => {\n      const { field } = props;\n      const { keys } = state;\n      const arrayFields = keys.map((key, i) => ({\n        // key: i,\n        key,\n        field: `${field}[${i}]`,\n        remove: () => remove(i),\n      }));\n      const contextVal = {\n        shouldUseInitValue: shouldUseInitValue,\n      };\n      return (\n        <ArrayFieldContext.Provider value={contextVal}>\n          {slots.default?.({ arrayFields, add, addWithInitValue })}\n        </ArrayFieldContext.Provider>\n      );\n    };\n  },\n});\n\nexport default ArrayFieldComponent;\n"],"names":["filterArrayByIndex","array","index","filter","item","i","getUuidByArray","map","getUuidv4","getUpdateKey","arrayField","updateKey","initValueAdapter","initValue","iv","Array","isArray","warning","isUndefined","generateKeys","value","oldKeys","val","key","vuePropsType","field","String","ArrayFieldComponent","defineComponent","props","name","setup","slots","useSlots","shouldUseInitValue","cacheUpdateKey","context","useFormUpdaterContext","initValueInProps","initValueInForm","getValue","state","reactive","keys","getArrayField","initValueCopyForFormState","copy","initValueCopyForReset","registerArrayField","updateStateValue","notNotify","notUpdate","onBeforeUnmount","updater","unRegisterArrayField","watch","fieldValues","newKeys","add","push","Date","valueOf","updateArrayField","addWithInitValue","rowVal","newArrayFieldVal","slice","cloneRowVal","remove","newArrayFieldError","getError","opts","splice","updateStateError","newArrayFieldValue","arrayFields","contextVal","_createVNode","ArrayFieldContext","Provider","default"],"mappings":"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"}