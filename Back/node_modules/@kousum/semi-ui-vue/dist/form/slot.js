import { defineComponent as E, isVNode as m, createVNode as e, Fragment as u, mergeProps as v } from "vue";
import C from "classnames";
import { cssClasses as W } from '@douyinfe/semi-foundation/lib/es/form/constants';
import { isString as x, isNumber as F, isObject as S } from "lodash";
import P from "./label";
import { Col as p } from "../grid";
import V from "./errorMessage";
import { useFormUpdaterContext as B } from "./context/FormUpdaterContext/Consumer";
import { getFragmentChildren as I } from "../_utils";
const n = W.PREFIX, M = {
  className: String,
  style: Object,
  label: [String, Number, Function, Array, Object],
  noLabel: Boolean,
  labelPosition: String,
  error: [Object, String]
}, K = /* @__PURE__ */ E({
  props: {
    ...M
  },
  setup(d, {
    slots: $
  }) {
    const {
      context: j
    } = B();
    return () => {
      const i = I($);
      let c, h, k, f, a, o = "top";
      try {
        const l = j.value.getFormProps(["labelPosition", "labelWidth", "labelAlign", "labelCol", "wrapperCol"]);
        c = l.labelCol, h = l.wrapperCol, k = l.labelWidth, f = l.labelAlign, o = l.labelPosition ? l.labelPosition : o;
      } catch {
      }
      d.labelPosition && (o = d.labelPosition);
      let {
        label: t,
        className: A,
        style: L,
        error: r,
        noLabel: N,
        ...R
      } = d;
      const b = c && h, O = C({
        [`${n}-field`]: !0,
        [`${n}-slot`]: !0
      }, A), w = C({
        [`${n}-col-${f}`]: !0
      });
      switch (!0) {
        case (S(t) && !m(t)):
          break;
        case (x(t) || F(t)):
          t = {
            text: t
          };
          break;
        case m(t):
          t = {
            text: t
          };
          break;
      }
      let s = null;
      if (typeof r !== void 0) {
        let l = {};
        switch (!0) {
          case (S(r) && !m(r)):
            l = r;
            break;
          case (x(r) || F(r)):
            l = {
              error: r
            };
            break;
          case m(r):
            l = {
              error: r
            };
            break;
        }
        s = e(V, l, null);
      }
      let g = {
        align: f,
        width: k,
        // @ts-ignore: After the above switch statement, label must be of object type
        ...t
      }, y = C({
        [`${n}-field-main`]: !0,
        [`${n}-slot-main`]: !0
      });
      switch (!0) {
        case (!b && !N):
          a = e(u, null, [e(P, g, null), e("div", {
            class: y
          }, [i, s])]);
          break;
        case (!b && N):
          a = e(u, null, [e("div", {
            class: y
          }, [i, s])]);
          break;
        case (b && o === "top"):
          a = e(u, null, [e("div", {
            style: {
              overflow: "hidden"
            }
          }, [e(p, v(c, {
            className: w
          }), {
            default: () => [e(P, g, null)]
          })]), e(p, null, {
            default: () => [i, s]
          })]);
          break;
        case (b && o !== "top"):
          a = e(u, null, [e(p, v(c, {
            className: w
          }), {
            default: () => [e(P, g, null)]
          }), e(p, null, {
            default: () => [i, s]
          })]);
          break;
      }
      return e("div", {
        class: O,
        "x-label-pos": o,
        style: L
      }, [a]);
    };
  }
});
export {
  K as default
};
//# sourceMappingURL=slot.js.map
