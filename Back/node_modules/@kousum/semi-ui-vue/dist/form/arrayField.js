import { defineComponent as h, useSlots as S, reactive as C, onBeforeUnmount as x, watch as I, createVNode as P } from "vue";
import { getUuidv4 as V } from '@douyinfe/semi-foundation/lib/es/utils/uuid';
import { isUndefined as B } from "lodash";
import { ArrayFieldContext as E } from "./context";
import N from '@douyinfe/semi-foundation/lib/es/utils/warning';
import { useFormUpdaterContext as R } from "./context/FormUpdaterContext/Consumer";
import v from "fast-copy";
const D = (e, o) => e.filter((d, c) => c !== o), O = (e) => e.map(() => V()), $ = (e) => {
  if (e && e && e.updateKey)
    return e.updateKey;
}, b = (e) => {
  const o = [];
  return Array.isArray(e) ? e : (N(!B(e), "[Semi Form ArrayField] initValue of ArrayField must be an array. Please check the type of your props"), o);
}, A = (e, o) => {
  const d = b(e);
  return O(d).map((m, f) => o && o[f] ? o[f] : m);
}, T = {
  initValue: Array,
  field: String
}, L = /* @__PURE__ */ h({
  props: {
    ...T
  },
  name: "ArrayFieldComponent",
  setup(e, {}) {
    const o = S();
    let d, c;
    const {
      context: l
    } = R(), m = e.initValue, f = l.value.getValue(e.field), p = m || f, i = C({
      keys: A(p)
    });
    d = !l.value.getArrayField(e.field);
    const F = v(p), g = v(p);
    l.value.registerArrayField(e.field, g), l.value.updateStateValue(e.field, F, {
      notNotify: !0,
      notUpdate: !0
    }), x(() => {
      const a = l.value, {
        field: t
      } = e;
      a.unRegisterArrayField(t);
    }), I([() => e.field, () => i.keys], () => {
      const {
        field: a
      } = e, {
        keys: t
      } = i, r = l.value.getValue(a), n = $(l.value.getArrayField(a));
      if (n !== c) {
        const u = A(r, t);
        i.keys = u, c = n, c !== null && (d = !1);
      }
    });
    function k() {
      const {
        keys: a
      } = i, {
        field: t
      } = e, r = l.value;
      a.push(V()), d = !0, i.keys = a;
      let n = (/* @__PURE__ */ new Date()).valueOf();
      r.updateArrayField(t, {
        updateKey: n
      }), c = n;
    }
    function w(a) {
      const t = l, {
        field: r
      } = e, n = t.value.getValue(r) ? t.value.getValue(r).slice() : [], u = v(a);
      n.push(u), t.value.updateStateValue(r, n, {}), t.value.updateArrayField(r, {
        updateKey: (/* @__PURE__ */ new Date()).valueOf()
      });
    }
    function U(a) {
      const t = l, {
        keys: r
      } = i, {
        field: n
      } = e, u = D(r, a);
      let s = t.value.getError(n);
      const K = {
        notNotify: !0,
        notUpdate: !0
      };
      Array.isArray(s) && (s = s.slice(), s.splice(a, 1), t.value.updateStateError(n, s, K));
      let y = t.value.getValue(n);
      Array.isArray(y) && (y = y.slice(), y.splice(a, 1), t.value.updateStateValue(n, y)), i.keys = u;
    }
    return () => {
      const {
        field: a
      } = e, {
        keys: t
      } = i, r = t.map((u, s) => ({
        // key: i,
        key: u,
        field: `${a}[${s}]`,
        remove: () => U(s)
      })), n = {
        shouldUseInitValue: d
      };
      return P(E.Provider, {
        value: n
      }, {
        default: () => {
          var u;
          return [(u = o.default) == null ? void 0 : u.call(o, {
            arrayFields: r,
            add: k,
            addWithInitValue: w
          })];
        }
      });
    };
  }
});
export {
  L as default,
  T as vuePropsType
};
//# sourceMappingURL=arrayField.js.map
