import { defineComponent as et, reactive as ot, ref as nt, watch as lt, onMounted as rt, onUnmounted as at, createVNode as l, mergeProps as h } from "vue";
import a from "classnames";
import { strings as x, cssClasses as st } from '@douyinfe/semi-foundation/lib/es/avatar/constants';
import it from '@douyinfe/semi-foundation/lib/es/avatar/foundation';
import '@douyinfe/semi-foundation/lib/es/avatar/avatar.css';
import { noop as v } from '@douyinfe/semi-foundation/lib/es/utils/function';
import { useBaseComponent as ct } from "../_base/baseComponent";
import { handlePrevent as mt } from '@douyinfe/semi-foundation/lib/es/utils/a11y';
import dt from "./TopSlotSvg";
import { styleNum as V } from "../_utils";
export * from "./interface";
x.SIZE;
x.SHAPE;
x.COLOR;
const o = st.PREFIX, ut = {
  style: [Object, String],
  className: String,
  color: {
    type: String,
    default: "grey"
  },
  shape: {
    type: String,
    default: "circle"
  },
  size: {
    type: String,
    default: "medium"
  },
  gap: {
    type: Number,
    default: 3
  },
  hoverMask: [Object, String, Number],
  src: String,
  srcSet: String,
  alt: String,
  onError: Function,
  onClick: {
    type: Function,
    default: v
  },
  onMouseEnter: {
    type: Function,
    default: v
  },
  onMouseLeave: {
    type: Function,
    default: v
  },
  imgAttr: Object,
  bottomSlot: Object,
  topSlot: Object,
  border: [Object, Boolean],
  contentMotion: Boolean
}, Et = /* @__PURE__ */ et({
  props: {
    ...ut
  },
  name: "Avatar",
  setup(e, {
    slots: u
  }) {
    let c;
    const s = ot({
      isImgExist: !0,
      hoverContent: "",
      focusVisible: !1,
      scale: 1
    }), w = nt();
    let F = "";
    function N() {
      var n;
      const t = ((n = u.default) == null ? void 0 : n.call(u)) || [];
      if (c && t.length === 1 && t[0].type.toString() === "Symbol(v-txt)") {
        const i = t[0].children;
        F !== i && (c.changeScale(), F = i);
      }
    }
    lt(() => e.src, () => {
      const t = new Image(0, 0);
      t.src = e.src, t.onload = () => {
        s.isImgExist = !0;
      }, t.onerror = () => {
        s.isImgExist = !1;
      }, t.onabort = () => {
        s.isImgExist = !1;
      }, N();
    });
    const {
      adapter: z
    } = ct(e, s), T = R();
    function R() {
      return {
        ...z(),
        notifyImgState: (t) => {
          s.isImgExist = t;
        },
        notifyEnter: (t) => {
          const {
            hoverMask: n
          } = e;
          s.hoverContent = n;
          const {
            onMouseEnter: i
          } = e;
          i && i(t);
        },
        notifyLeave: (t) => {
          s.hoverContent = "";
          const {
            onMouseLeave: n
          } = e;
          n && n(t);
        },
        setFocusVisible: (t) => {
          s.focusVisible = t;
        },
        setScale: (t) => {
          s.scale = t;
        },
        getAvatarNode: () => w.value
      };
    }
    rt(() => {
      c = new it(T), c.init();
    }), at(() => {
      c.destroy();
    });
    function D(t) {
      c.handleEnter(t);
    }
    function K(t) {
      c.handleLeave(t);
    }
    function Z() {
      c.handleImgLoadError();
    }
    function H(t) {
      const {
        onClick: n
      } = e;
      switch (t.key) {
        case "Enter":
          n(t), mt(t);
          break;
        case "Escape":
          t.target.blur();
          break;
      }
    }
    const U = (t) => {
      c.handleFocusVisible(t);
    }, W = (t) => {
      c.handleBlur();
    }, X = () => {
      var k;
      const {
        onClick: t,
        imgAttr: n,
        src: i,
        srcSet: C,
        alt: $
      } = e, {
        isImgExist: E
      } = s, b = (k = u.default) == null ? void 0 : k.call(u);
      let S = b;
      const m = t !== v, I = i && E, p = {
        tabIndex: 0,
        onKeyDown: H,
        onFocus: U,
        onBlur: W
      };
      if (I) {
        const d = m ? `clickable Avatar: ${$}` : $, f = {
          src: i,
          srcSet: C,
          onError: Z,
          ...n,
          className: a({
            [`${o}-no-focus-visible`]: m
          })
        }, r = m ? {
          ...f,
          ...p
        } : f;
        S = [l("img", h({
          alt: d
        }, r), null)];
      } else if (typeof b == "string") {
        const d = $ ?? b, r = {
          role: "img",
          "aria-label": m ? `clickable Avatar: ${d}` : d,
          className: a(`${o}-label`, {
            [`${o}-no-focus-visible`]: m
          })
        }, A = m ? {
          ...r,
          ...p
        } : r, B = {
          transform: `scale(${s.scale})`
        };
        S = [l("span", {
          class: `${o}-content`,
          style: B
        }, [l("span", h(A, {
          "x-semi-prop": "children"
        }), [b])])];
      }
      return S;
    }, q = () => {
      if (!e.bottomSlot)
        return null;
      if (e.bottomSlot.render)
        return e.bottomSlot.render();
      const t = e.bottomSlot.render ?? (() => {
        const n = {};
        return e.bottomSlot.bgColor && (n.backgroundColor = e.bottomSlot.bgColor), e.bottomSlot.textColor && (n.color = e.bottomSlot.textColor), l("span", {
          style: n,
          class: a(`${o}-bottom_slot-shape_${e.bottomSlot.shape}`, `${o}-bottom_slot-shape_${e.bottomSlot.shape}-${e.size}`, e.bottomSlot.className ?? "")
        }, [e.bottomSlot.text]);
      });
      return l("div", {
        class: a([`${o}-bottom_slot`]),
        style: e.bottomSlot.style ?? {}
      }, [t()]);
    }, G = () => {
      if (!e.topSlot)
        return null;
      if (e.topSlot.render)
        return e.topSlot.render();
      const t = {};
      return e.topSlot.textColor && (t.color = e.topSlot.textColor), l("div", {
        style: e.topSlot.style ?? {},
        class: a([`${o}-top_slot-wrapper`, e.topSlot.className ?? "", {
          [`${o}-animated`]: e.contentMotion
        }])
      }, [l("div", {
        class: a([`${o}-top_slot-bg`, `${o}-top_slot-bg-${e.size}`])
      }, [l("div", {
        class: a([`${o}-top_slot-bg-svg`, `${o}-top_slot-bg-svg-${e.size}`])
      }, [l(dt, {
        gradientStart: e.topSlot.gradientStart ?? "var(--semi-color-primary)",
        gradientEnd: e.topSlot.gradientEnd ?? "var(--semi-color-primary)"
      }, null)])]), l("div", {
        class: a([`${o}-top_slot`])
      }, [l("div", {
        style: t,
        class: a([`${o}-top_slot-content`, `${o}-top_slot-content-${e.size}`])
      }, [e.topSlot.text])])]);
    };
    return () => {
      var L;
      N();
      const {
        shape: t,
        size: n,
        color: i,
        className: C,
        hoverMask: $,
        onClick: E,
        imgAttr: b,
        src: S,
        srcSet: m,
        style: I,
        alt: p,
        gap: k,
        bottomSlot: d,
        topSlot: f,
        border: r,
        contentMotion: A,
        ...B
      } = e, {
        isImgExist: J,
        hoverContent: j,
        focusVisible: Q
      } = s;
      let g = {};
      x.SIZE.includes(n) || (g = {
        width: V(n),
        height: V(n)
      }), g = {
        ...g,
        ...I
      };
      const M = d || f || r, P = {
        onClick: E,
        onMouseenter: D,
        onMouseleave: K
      }, O = S && J, Y = a(o, {
        [`${o}-${t}`]: t,
        [`${o}-${n}`]: n,
        [`${o}-${i}`]: i && !O,
        [`${o}-img`]: O,
        [`${o}-focus`]: Q,
        [`${o}-animated`]: A
      }, C), tt = j ? l("div", {
        class: `${o}-hover`,
        "x-semi-prop": "hoverContent"
      }, [j]) : null;
      let y = l("span", h(B, {
        style: M ? {} : g,
        class: Y
      }, M ? {} : P, {
        role: "listitem",
        ref: w
      }), [X(), tt]);
      if (r) {
        const _ = {};
        typeof r == "object" && (r != null && r.color) && (_.borderColor = r == null ? void 0 : r.color), y = l("div", {
          style: {
            position: "relative",
            ...g
          }
        }, [y, l("span", {
          style: _,
          class: a([`${o}-additionalBorder`, `${o}-additionalBorder-${n}`, {
            [`${o}-${t}`]: t
          }])
        }, null), typeof e.border == "object" && l("span", {
          style: _,
          class: a([`${o}-additionalBorder`, `${o}-additionalBorder-${n}`, {
            [`${o}-${t}`]: t,
            [`${o}-additionalBorder-animated`]: typeof e.border == "object" && ((L = e.border) == null ? void 0 : L.motion)
          }])
        }, null)]);
      }
      return M ? l("span", h({
        class: a([`${o}-wrapper`]),
        style: g
      }, P), [y, f && ["extra-small", "small", "default", "medium", "large", "extra-large"].includes(n) && t === "circle" && G(), d && ["extra-small", "small", "default", "medium", "large", "extra-large"].includes(n) && q()]) : y;
    };
  }
});
export {
  Et as default,
  ut as vuePropsType
};
//# sourceMappingURL=index.js.map
