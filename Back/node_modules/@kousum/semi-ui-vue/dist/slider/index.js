import { defineComponent as ie, useSlots as ue, reactive as de, ref as K, nextTick as J, watch as ce, onMounted as fe, onUnmounted as me, createVNode as i, mergeProps as k, Fragment as ve, isVNode as he } from "vue";
import * as l from "../PropTypes";
import { vuePropsMake as be } from "../PropTypes";
import T from "classnames";
import { cssClasses as h } from '@douyinfe/semi-foundation/lib/es/slider/constants';
import { useBaseComponent as ye } from "../_base/baseComponent";
import ge from '@douyinfe/semi-foundation/lib/es/slider/foundation';
import I from "../tooltip/index";
import '@douyinfe/semi-foundation/lib/es/slider/slider.css';
import { noop as z, isEqual as Q } from "lodash";
function pe(t) {
  return typeof t == "function" || Object.prototype.toString.call(t) === "[object Object]" && !he(t);
}
const w = h.PREFIX;
function xe(t) {
  return t ? !!(t.offsetWidth || t.offsetHeight || t.getClientRects().length) : !1;
}
const we = {
  // allowClear: PropTypes.bool,
  "aria-label": l.string,
  "aria-labelledby": l.string,
  "aria-valuetext": l.string,
  defaultValue: [l.number, l.array],
  disabled: {
    type: l.bool,
    default: void 0
  },
  showMarkLabel: l.bool,
  included: {
    type: l.bool,
    default: void 0
  },
  // Whether to juxtapose. Allow dragging
  marks: l.object,
  // Scale
  max: l.number,
  min: l.number,
  range: {
    type: l.bool,
    default: void 0
  },
  // Whether both sides
  step: l.number,
  tipFormatter: l.func,
  value: [l.number, l.array],
  vertical: {
    type: l.bool,
    default: void 0
  },
  onAfterChange: l.func,
  // OnmouseUp and triggered when clicked
  onChange: l.func,
  onMouseUp: l.func,
  tooltipOnMark: l.bool,
  tooltipVisible: {
    type: l.bool,
    default: void 0
  },
  showArrow: l.bool,
  style: l.object,
  className: l.string,
  showBoundary: {
    type: l.bool,
    default: void 0
  },
  railStyle: l.object,
  verticalReverse: {
    type: l.bool,
    default: void 0
  },
  getAriaValueText: l.func,
  handleDot: l.oneOfType([l.object, l.array])
}, He = {
  // allowClear: false,
  disabled: !1,
  showMarkLabel: !0,
  tooltipOnMark: !1,
  included: !0,
  // No is juxtaposition. Allow dragging
  max: 100,
  min: 0,
  range: !1,
  // Whether both sides
  showArrow: !0,
  step: 1,
  tipFormatter: (t) => t,
  vertical: !1,
  showBoundary: !1,
  onAfterChange: (t) => {
  },
  onChange: (t) => {
  },
  verticalReverse: !1
}, De = be(we, He), Re = /* @__PURE__ */ ie({
  props: {
    ...De
  },
  name: "Slider",
  setup(t, {}) {
    ue();
    let {
      value: E
    } = t;
    E || (E = t.defaultValue);
    const c = de({
      // eslint-disable-next-line no-nested-ternary
      currentValue: E || (t.range ? [0, 0] : 0),
      min: t.min || 0,
      max: t.max || 0,
      focusPos: "",
      onChange: t.onChange,
      disabled: t.disabled || !1,
      chooseMovePos: "",
      isDrag: !1,
      clickValue: 0,
      showBoundary: !1,
      isInRenderTree: !0,
      firstDotFocusVisible: !1,
      secondDotFocusVisible: !1
    }), x = K(), L = K(), O = K();
    let W = [!1, !1];
    const N = /* @__PURE__ */ new Set(), P = /* @__PURE__ */ new Set(), {
      adapter: Z,
      getDataAttr: ee
    } = ye(t, c), ne = te();
    function te() {
      return {
        ...Z(),
        getSliderLengths: () => {
          var e;
          if (x && x.value) {
            const a = x.value.getBoundingClientRect(), o = (e = x.value.offsetParent) == null ? void 0 : e.getBoundingClientRect(), r = {
              x: o ? a.left - o.left : x.value.offsetLeft,
              y: o ? a.top - o.top : x.value.current.offsetTop
            };
            return {
              sliderX: r.x,
              sliderY: r.y,
              sliderWidth: a.width,
              sliderHeight: a.height
            };
          }
          return {
            sliderX: 0,
            sliderY: 0,
            sliderWidth: 0,
            sliderHeight: 0
          };
        },
        getParentRect: () => {
          const e = x && x.value && x.value.offsetParent;
          if (e)
            return e.getBoundingClientRect();
        },
        getScrollParentVal: () => {
          const e = n.getScrollParent(x.value);
          return {
            scrollTop: e.scrollTop,
            scrollLeft: e.scrollLeft
          };
        },
        isEventFromHandle: (e) => {
          const a = [L, O];
          let o = !1;
          return a.forEach((r) => {
            r.value && r.value.contains(e.target) && (o = !0);
          }), o;
        },
        getOverallVars: () => ({
          dragging: W
        }),
        updateDisabled: (e) => {
          c.disabled = e;
        },
        transNewPropsToState(e, a = z) {
          Object.keys(e).forEach((o) => {
            c[o] = e[o];
          }), J(() => {
            a == null || a();
          });
        },
        notifyChange: (e) => {
          t.onChange(Array.isArray(e) ? [...e].sort((a, o) => a - o) : e);
        },
        setDragging: (e) => {
          W = e;
        },
        updateCurrentValue: (e) => {
        },
        setOverallVars: (e, a) => {
          console.error("smw: 用途 未知");
        },
        getMinHandleEl: () => L.value,
        getMaxHandleEl: () => O.value,
        onHandleDown: (e) => {
          P.add(F(document.body, "mousemove", n.onHandleMove, !1)), P.add(F(window, "mouseup", n.onHandleUp, !1)), P.add(F(document.body, "touchmove", n.onHandleTouchMove, !1));
        },
        onHandleMove: (e, a, o = z, r = !1, s) => {
          if (!n.checkAndUpdateIsInRenderTreeState())
            return;
          const {
            value: u
          } = t;
          let d = s;
          if (d === void 0) {
            const y = n.transPosToValue(e, a);
            if (y === !1)
              return;
            d = n.outPutValue(y);
          }
          const {
            currentValue: g
          } = c;
          if (!Q(n.outPutValue(g), d)) {
            if (!r && n.valueFormatIsCorrect(u))
              return !1;
            c.currentValue = d, J(() => {
              o == null || o();
            });
          }
        },
        setEventDefault: (e) => {
          e.stopPropagation(), e.preventDefault();
        },
        setStateVal: (e, a) => {
          c[e] = a;
        },
        checkAndUpdateIsInRenderTreeState: () => {
          const e = xe(x.value);
          return e !== c.isInRenderTree && (c.isInRenderTree = e), e;
        },
        onHandleEnter: (e) => {
          c.focusPos = e;
        },
        onHandleLeave: () => {
          c.focusPos = "";
        },
        onHandleUpBefore: (e) => {
          var a;
          (a = t.onMouseUp) == null || a.call(t, e), e.stopPropagation(), e.preventDefault(), Array.from(P).forEach((o) => o()), P.clear();
        },
        onHandleUpAfter: () => {
          const {
            currentValue: e
          } = c, a = n.outPutValue(e);
          t.onAfterChange(a);
        },
        unSubscribeEventListener: () => {
          Array.from(N).forEach((e) => e == null ? void 0 : e());
        }
      };
    }
    const n = new ge(ne);
    ce([() => t.value, () => t.disabled, () => c.currentValue], (e, [a, o]) => {
      const r = !Q(t.value, a);
      if (t.disabled !== o && n.handleDisabledChange(t.disabled), r) {
        const b = t.value, u = c.currentValue;
        n.handleValueChange(u, b);
      }
    }), fe(() => {
      n.init();
    }), me(() => {
      n.init();
    });
    const ae = () => {
      const {
        vertical: e,
        range: a,
        tooltipVisible: o,
        tipFormatter: r,
        "aria-label": s,
        "aria-labelledby": b,
        "aria-valuetext": u,
        getAriaValueText: d,
        disabled: g
      } = t, {
        chooseMovePos: y,
        isDrag: H,
        isInRenderTree: V,
        firstDotFocusVisible: $,
        secondDotFocusVisible: B
      } = c, C = e ? "top" : "left", S = n.getMinAndMaxPercent(c.currentValue), M = S.min, X = S.max, {
        tipVisible: U,
        tipChildren: j
      } = n.computeHandleVisibleVal(o && V, r, a), Y = T(h.HANDLE, {
        [`${h.HANDLE}-clicked`]: y === "min" && H
      }), se = T(h.HANDLE, {
        [`${h.HANDLE}-clicked`]: y === "max" && H
      }), {
        min: q,
        max: G,
        currentValue: D
      } = c, R = {
        "aria-label": s ?? (g ? "Disabled Slider" : void 0),
        "aria-labelledby": b,
        "aria-disabled": g
      };
      e && Object.assign(R, {
        "aria-orientation": "vertical"
      });
      const m = t.handleDot;
      return a ? i(ve, null, [i(I, {
        content: j.min,
        position: "top",
        trigger: "custom",
        rePosKey: M,
        visible: V && (U.min || $),
        className: `${h.HANDLE}-tooltip`
      }, {
        default: () => {
          var f, A;
          return [i("span", k({
            ref: L,
            class: Y,
            style: {
              [C]: `${M * 100}%`,
              zIndex: y === "min" ? 2 : 1
            },
            onMousedown: (v) => {
              n.onHandleDown(v, "min");
            },
            onMouseenter: () => {
              n.onHandleEnter("min");
            },
            onTouchstart: (v) => {
              n.onHandleTouchStart(v, "min");
            },
            onMouseleave: () => {
              n.onHandleLeave();
            },
            onKeyup: (v) => {
              n.onHandleUp(v);
            },
            onTouchend: (v) => {
              n.onHandleUp(v);
            },
            onKeydown: (v) => {
              n.handleKeyDown(v, "min");
            },
            onFocus: (v) => {
              n.onFocus(v, "min");
            },
            onBlur: (v) => {
              n.onBlur(v, "min");
            },
            role: "slider",
            tabindex: g ? -1 : 0
          }, R, {
            "aria-valuetext": d ? d(D[0], 0) : u,
            "aria-valuenow": D[0],
            "aria-valuemax": D[1],
            "aria-valuemin": q
          }), [(m == null ? void 0 : m[0]) && i("div", {
            class: h.HANDLE_DOT,
            style: {
              ...(f = m[0]) != null && f.size ? {
                width: m[0].size,
                height: m[0].size
              } : {},
              ...(A = m[0]) != null && A.color ? {
                backgroundColor: m[0].color
              } : {}
            }
          }, null)])];
        }
      }), i(I, {
        content: j.max,
        position: "top",
        trigger: "custom",
        rePosKey: X,
        visible: V && (U.max || B),
        className: `${h.HANDLE}-tooltip`
      }, {
        default: () => {
          var f, A, v;
          return [i("span", k({
            ref: O,
            class: se,
            style: {
              [C]: `${X * 100}%`,
              zIndex: y === "max" ? 2 : 1
            },
            onMousedown: (p) => {
              n.onHandleDown(p, "max");
            },
            onMouseenter: () => {
              n.onHandleEnter("max");
            },
            onMouseleave: () => {
              n.onHandleLeave();
            },
            onKeyup: (p) => {
              n.onHandleUp(p);
            },
            onTouchstart: (p) => {
              n.onHandleTouchStart(p, "max");
            },
            onTouchend: (p) => {
              n.onHandleUp(p);
            },
            onKeydown: (p) => {
              n.handleKeyDown(p, "max");
            },
            onFocus: (p) => {
              n.onFocus(p, "max");
            },
            onBlur: (p) => {
              n.onBlur(p, "max");
            },
            role: "slider",
            tabindex: g ? -1 : 0
          }, R, {
            "aria-valuetext": d ? d(D[1], 1) : u,
            "aria-valuenow": D[1],
            "aria-valuemax": G,
            "aria-valuemin": D[0]
          }), [((f = t.handleDot) == null ? void 0 : f[1]) && i("div", {
            class: h.HANDLE_DOT,
            style: {
              ...(A = t.handleDot[1]) != null && A.size ? {
                width: t.handleDot[1].size,
                height: t.handleDot[1].size
              } : {},
              ...(v = t.handleDot[1]) != null && v.color ? {
                backgroundColor: t.handleDot[1].color
              } : {}
            }
          }, null)])];
        }
      })]) : i(I, {
        content: j.min,
        showArrow: t.showArrow,
        position: "top",
        trigger: "custom",
        rePosKey: M,
        visible: V && (U.min || $),
        className: `${h.HANDLE}-tooltip`
      }, {
        default: () => [i("span", k({
          onMouseover: n.checkAndUpdateIsInRenderTreeState,
          ref: L,
          class: Y,
          style: {
            [C]: `${M * 100}%`,
            zIndex: y === "min" && H ? 2 : 1
          },
          onMousedown: (f) => {
            n.onHandleDown(f, "min");
          },
          onMouseenter: () => {
            n.onHandleEnter("min");
          },
          onTouchstart: (f) => {
            n.onHandleTouchStart(f, "min");
          },
          onMouseleave: () => {
            n.onHandleLeave();
          },
          onKeyup: (f) => {
            n.onHandleUp(f);
          },
          onTouchend: (f) => {
            n.onHandleUp(f);
          },
          onKeydown: (f) => {
            n.handleKeyDown(f, "min");
          },
          onFocus: (f) => {
            n.onFocus(f, "min");
          },
          onBlur: (f) => {
            n.onBlur(f, "min");
          },
          role: "slider",
          "aria-valuetext": d ? d(D, 0) : u,
          tabindex: g ? -1 : 0
        }, R, {
          "aria-valuenow": D,
          "aria-valuemax": G,
          "aria-valuemin": q
        }), [m && i("div", {
          class: h.HANDLE_DOT,
          style: {
            ...m != null && m.size ? {
              width: m.size,
              height: m.size
            } : {},
            ...m != null && m.color ? {
              backgroundColor: m.color
            } : {}
          }
        }, null)])]
      });
    }, oe = () => {
      const {
        range: e,
        included: a,
        vertical: o
      } = t, r = n.getMinAndMaxPercent(c.currentValue), s = r.min, b = r.max;
      let u = o ? {
        height: e ? `${Math.abs(b - s) * 100}%` : `${s * 100}%`,
        top: e ? `${Math.min(s, b) * 100}%` : 0
      } : {
        width: e ? `${Math.abs(b - s) * 100}%` : `${s * 100}%`,
        left: e ? `${Math.min(s, b) * 100}%` : 0
      };
      return u = a ? u : {}, // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
      i("div", {
        class: h.TRACK,
        style: u,
        onClick: n.handleWrapClick
      }, null);
    }, le = () => {
      const {
        min: e,
        max: a,
        vertical: o,
        marks: r
      } = t, s = o ? "top" : "left";
      return r && Object.keys(r).length > 0 ? i("div", {
        class: h.DOTS
      }, [Object.keys(r).map((u) => {
        const d = n.isMarkActive(Number(u)), g = T(`${w}-dot`, {
          [`${w}-dot-active`]: n.isMarkActive(Number(u)) === "active"
        }), y = (Number(u) - e) / (a - e), H = (
          // eslint-disable-next-line jsx-a11y/no-static-element-interactions
          i("span", {
            key: u,
            onClick: n.handleWrapClick,
            class: g,
            style: {
              [s]: `calc(${y * 100}% - 2px)`
            }
          }, null)
        );
        return d ? t.tooltipOnMark ? i(I, {
          content: r[u]
        }, pe(H) ? H : {
          default: () => [H]
        }) : H : null;
      })]) : null;
    }, re = () => {
      if (!t.showMarkLabel)
        return null;
      const {
        min: e,
        max: a,
        vertical: o,
        marks: r,
        verticalReverse: s
      } = t, b = o ? "top" : "left";
      return r && Object.keys(r).length > 0 ? i("div", {
        class: h.MARKS + (o && s ? "-reverse" : "")
      }, [Object.keys(r).map((d) => {
        const g = n.isMarkActive(Number(d)), y = (Number(d) - e) / (a - e);
        return g ? (
          // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
          i("span", {
            key: d,
            class: T(`${w}-mark${o && s ? "-reverse" : ""}`),
            style: {
              [b]: `${y * 100}%`
            },
            onClick: n.handleWrapClick
          }, [r[d]])
        ) : null;
      })]) : null;
    }, _ = (e, a) => {
      const {
        getAriaValueText: o
      } = t;
      return o ? o(e, a) : e;
    };
    function F(e, a, o, ...r) {
      if (e.addEventListener) {
        e.addEventListener(a, o, ...r);
        const s = () => {
          e == null || e.removeEventListener(a, o), Promise.resolve().then(() => {
            N.delete(s);
          });
        };
        return N.add(s), s;
      } else
        return z;
    }
    return () => {
      const {
        disabled: e,
        currentValue: a,
        min: o,
        max: r
      } = c, {
        vertical: s,
        verticalReverse: b,
        style: u,
        railStyle: d,
        range: g,
        className: y,
        ...H
      } = t, V = T(`${w}-wrapper`, {
        [`${w}-disabled`]: e,
        [`${h.VERTICAL}-wrapper`]: s,
        [`${w}-reverse`]: s && b
      }, y), $ = T(`${w}-boundary`, {
        [`${w}-boundary-show`]: t.showBoundary && c.showBoundary
      }), B = T({
        [`${w}`]: !s,
        [h.VERTICAL]: s
      }), C = Array.isArray(a) ? [...a].sort() : a, S = g ? `Range: ${_(C[0], 0)} to ${_(C[1], 1)}` : void 0, M = i("div", k({
        class: V,
        style: u,
        ref: x,
        "aria-label": S,
        onMouseenter: () => n.handleWrapperEnter(),
        onMouseleave: () => n.handleWrapperLeave()
      }, ee()), [
        // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
        i("div", {
          class: `${w}-rail`,
          onClick: n.handleWrapClick,
          style: d
        }, null),
        oe(),
        le(),
        i("div", null, [ae()]),
        re(),
        i("div", {
          class: $
        }, [i("span", {
          class: `${w}-boundary-min`
        }, [o]), i("span", {
          class: `${w}-boundary-max`
        }, [r])])
      ]);
      return s ? M : i("div", {
        class: B
      }, [M]);
    };
  }
});
export {
  Re as default,
  De as vuePropsType
};
//# sourceMappingURL=index.js.map
