import { defineComponent as O, reactive as _, onMounted as G, watch as I, onUnmounted as Y, createVNode as s, isVNode as R, cloneVNode as k, mergeProps as q } from "vue";
import w from "classnames";
import { noop as L } from "lodash";
import { strings as i, radioGroupClasses as z } from '@douyinfe/semi-foundation/lib/es/radio/constants';
import M from '@douyinfe/semi-foundation/lib/es/radio/radioGroupFoundation';
import { useBaseComponent as X } from "../_base/baseComponent";
import v from "./radio";
import H from "./context";
import * as p from "../PropTypes";
function J(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !R(e);
}
const K = {
  "onUpdate:value": Function,
  defaultValue: {
    type: [String, Number, Boolean],
    // @ts-ignore
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  name: String,
  options: [Object, Array],
  value: {
    type: [String, Number, Boolean],
    // @ts-ignore
    default: void 0
  },
  onChange: {
    type: Function,
    default: L
  },
  className: String,
  style: [Object, String],
  direction: {
    type: [String, Object, Array, Boolean],
    default: i.DEFAULT_DIRECTION
  },
  mode: {
    type: String,
    default: ""
  },
  type: {
    type: String,
    default: i.TYPE_DEFAULT
  },
  buttonSize: {
    type: String,
    default: "middle"
  },
  prefixCls: String,
  "aria-label": String,
  "aria-describedby": String,
  "aria-errormessage": String,
  "aria-invalid": [p.bool, p.string],
  "aria-labelledby": String,
  "aria-required": [String, Boolean],
  id: String
}, le = /* @__PURE__ */ O({
  props: {
    ...K
  },
  name: "RadioGroup",
  setup(e, {
    slots: b
  }) {
    const g = e["onUpdate:value"];
    let l;
    const f = _({
      value: void 0
    }), {
      adapter: h,
      getDataAttr: P
    } = X(e, f), T = N();
    function N() {
      return {
        ...h(),
        setValue: (a) => {
          f.value = a;
        },
        // getProps: () => props,
        isInProps: (a) => a in e && e[a] !== void 0,
        notifyChange: (a) => {
          e.onChange && e.onChange(a);
        }
      };
    }
    l = new M(T), G(() => {
      l.init();
    }), I(() => e.value, (a, d) => {
      a !== d && l.handlePropValueChange(e.value);
    }), Y(() => {
      l.destroy();
    });
    const E = (a) => {
      g && g(a.target.value), l.handleChange(a);
    }, A = () => e.name || "default";
    return () => {
      const a = b.default ? b.default() : null, {
        options: d,
        mode: B,
        prefixCls: y,
        className: D,
        style: F,
        direction: r,
        type: o,
        buttonSize: U,
        id: V,
        ...Q
      } = e, c = o === i.TYPE_BUTTON, C = o === i.TYPE_PURECARD, S = o === i.TYPE_CARD || C, $ = o === i.TYPE_DEFAULT, n = y || z.PREFIX, j = w(D, {
        [n]: !0,
        [`${n}-wrapper`]: !0,
        [`${n}-${r}`]: r && !c,
        [`${n}-${r}-default`]: r && $,
        [`${n}-${r}-card`]: r && S,
        [`${n}-buttonRadio`]: c
      }), x = f.value;
      let m;
      return d ? m = (d || []).map((t, u) => typeof t == "string" ? s(v, {
        key: u,
        disabled: e.disabled,
        value: t
      }, J(t) ? t : {
        default: () => [t]
      }) : s(v, {
        key: u,
        disabled: t.disabled || e.disabled,
        value: t.value,
        extra: t.extra,
        className: t.className,
        style: t.style
      }, {
        default: () => [t.label]
      })) : a && (m = a.map((t, u) => R(t) ? k(t, {
        key: u
      }) : null)), s("div", q({
        class: j,
        style: F,
        id: V,
        "aria-label": e["aria-label"],
        "aria-invalid": e["aria-invalid"],
        "aria-errormessage": e["aria-errormessage"],
        "aria-labelledby": e["aria-labelledby"],
        "aria-describedby": e["aria-describedby"],
        "aria-required": e["aria-required"]
      }, P()), [s(H, {
        value: {
          radioGroup: {
            onChange: E,
            value: x,
            disabled: e.disabled,
            name: A(),
            isButtonRadio: c,
            isCardRadio: S,
            isPureCardRadio: C,
            buttonSize: U,
            prefixCls: y
          },
          mode: B
        }
      }, {
        default: () => m
      })]);
    };
  }
});
export {
  le as default,
  K as vuePropsType
};
//# sourceMappingURL=radioGroup.js.map
