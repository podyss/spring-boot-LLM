import { createVNode as u, defineComponent as ht, useSlots as mt, reactive as gt, ref as q, watch as bt, onMounted as St, onUnmounted as xt, isVNode as Ct, nextTick as Se, Fragment as $, mergeProps as ie } from "vue";
import v from "classnames";
import * as n from "../PropTypes";
import { vuePropsMake as Tt } from "../PropTypes";
import { noop as ke, isEqual as xe, isEmpty as I, get as A, isFunction as X, isString as Ce, pick as Kt, isUndefined as Pt } from "lodash";
import wt from '@douyinfe/semi-foundation/lib/es/treeSelect/foundation';
import { convertDataToEntities as pt, calcExpandedKeys as se, calcMotionKeys as Te, calcExpandedKeysForValues as Ke, normalizeValue as O, flattenTreeData as Pe, filterTreeData as vt, findKeysForValues as M, updateKeys as we, calcCheckedKeys as Et, calcDisabledKeys as Nt, normalizeKeyList as pe, getValueOrKey as kt } from '@douyinfe/semi-foundation/lib/es/tree/treeUtil';
import { cssClasses as Ie, strings as L } from '@douyinfe/semi-foundation/lib/es/treeSelect/constants';
import { numbers as It } from '@douyinfe/semi-foundation/lib/es/popover/constants';
import { FixedSizeList as Ot } from "@kousum/vue3-window";
import '@douyinfe/semi-foundation/lib/es/tree/tree.css';
import '@douyinfe/semi-foundation/lib/es/treeSelect/treeSelect.css';
import { useHasInProps as Rt, useBaseComponent as Dt } from "../_base/baseComponent";
import Lt from "../tag/group";
import re from "../tag/index";
import Ft from "../input/index";
import Vt from "../tree/autoSizer";
import $t from "../tree/treeContext";
import de from "../tree/treeNode";
import At from "../tree/nodeList";
import { cloneDeep as ce } from "../tree/treeUtil";
import ve from "../locale/localeConsumer";
import Mt from "../trigger";
import jt from "../tagInput";
import { isSemiIcon as Ee, styleNum as Ne } from "../_utils";
import { IconChevronDown as zt, IconClear as Ht, IconSearch as Bt } from "@kousum/semi-icons-vue";
import _t from "../checkbox/checkboxGroup";
import Wt from "../popover/index";
import ue from "../select/virtualRow";
function j(t) {
  return typeof t == "function" || Object.prototype.toString.call(t) === "[object Object]" && !Ct(t);
}
const m = Ie.PREFIX, D = Ie.PREFIX_TREE, Gt = 0, Ut = {
  "aria-describedby": n.string,
  "aria-errormessage": n.string,
  "aria-invalid": n.bool,
  "aria-labelledby": n.string,
  "aria-required": n.bool,
  "aria-label": n.string,
  borderless: n.bool,
  loadedKeys: n.array,
  loadData: n.func,
  onLoad: n.func,
  arrowIcon: n.node,
  clearIcon: n.node,
  defaultOpen: n.bool,
  defaultValue: n.oneOfType([n.string, n.array]),
  defaultExpandAll: n.bool,
  defaultExpandedKeys: n.array,
  expandAll: n.bool,
  disabled: n.bool,
  disableStrictly: n.bool,
  // Whether to turn on the input box filtering function, when it is a function, it represents a custom filtering function
  filterTreeNode: n.oneOfType([n.func, n.bool]),
  multiple: n.bool,
  searchPlaceholder: n.string,
  searchAutoFocus: n.bool,
  virtualize: n.object,
  treeNodeFilterProp: n.string,
  onChange: n.func,
  onClear: n.func,
  onSearch: n.func,
  onSelect: n.func,
  onExpand: n.func,
  onChangeWithObject: n.bool,
  onBlur: n.func,
  onFocus: n.func,
  value: n.oneOfType([n.string, n.number, n.array, n.object]),
  expandedKeys: n.array,
  autoExpandParent: n.bool,
  showClear: n.bool,
  showSearchClear: n.bool,
  autoAdjustOverflow: n.bool,
  showFilteredOnly: n.bool,
  showLine: n.bool,
  motionExpand: n.bool,
  emptyContent: n.node,
  leafOnly: n.bool,
  keyMaps: n.object,
  treeData: n.array,
  dropdownClassName: n.string,
  dropdownStyle: n.object,
  motion: n.oneOfType([n.bool, n.object, n.func]),
  placeholder: n.string,
  maxTagCount: n.number,
  size: String,
  className: n.string,
  style: n.object,
  treeNodeLabelProp: n.string,
  suffix: n.node,
  prefix: n.node,
  insetLabel: n.node,
  insetLabelId: n.string,
  zIndex: n.number,
  getPopupContainer: n.func,
  dropdownMatchSelectWidth: n.bool,
  validateStatus: String,
  mouseEnterDelay: n.number,
  mouseLeaveDelay: n.number,
  triggerRender: n.func,
  stopPropagation: n.oneOfType([n.bool, n.string]),
  outerBottomSlot: n.node,
  outerTopSlot: n.node,
  onVisibleChange: n.func,
  expandAction: n.oneOfType([n.bool, n.string]),
  searchPosition: String,
  clickToHide: n.bool,
  renderLabel: n.func,
  renderFullLabel: n.func,
  labelEllipsis: n.bool,
  optionListStyle: n.object,
  searchRender: n.oneOfType([n.func, n.bool]),
  renderSelectedItem: n.func,
  checkRelation: n.string,
  id: n.string,
  showRestTagsPopover: n.bool,
  restTagsPopoverProps: n.object,
  preventScroll: n.bool,
  clickTriggerToHide: n.bool,
  autoMergeValue: n.bool,
  dropdownMargin: n.oneOfType([n.number, n.object]),
  position: n.string
}, qt = {
  borderless: !1,
  searchPosition: L.SEARCH_POSITION_DROPDOWN,
  arrowIcon: u(zt, null, null),
  autoExpandParent: !1,
  autoAdjustOverflow: !0,
  stopPropagation: !0,
  motion: !0,
  motionExpand: !0,
  expandAll: !1,
  zIndex: It.DEFAULT_Z_INDEX,
  disableStrictly: !1,
  multiple: !1,
  filterTreeNode: !1,
  size: "default",
  treeNodeFilterProp: "label",
  onChangeWithObject: !1,
  treeNodeLabelProp: "label",
  dropdownMatchSelectWidth: !0,
  defaultOpen: !1,
  showSearchClear: !0,
  showClear: !1,
  onVisibleChange: ke,
  expandAction: !1,
  clickToHide: !0,
  searchAutoFocus: !1,
  checkRelation: "related",
  "aria-label": "TreeSelect",
  showRestTagsPopover: !1,
  restTagsPopoverProps: {},
  clickTriggerToHide: !0,
  autoMergeValue: !0
}, Xt = Tt(Ut, qt), vn = /* @__PURE__ */ ht({
  props: {
    ...Xt
  },
  name: "TreeSelect",
  setup(t, {}) {
    const {
      getProps: Oe
    } = Rt(), Re = mt(), g = gt({
      inputTriggerFocus: !1,
      isOpen: !1,
      isFocus: !1,
      // isInput: false,
      rePosKey: Gt,
      dropdownMinWidth: null,
      inputValue: "",
      keyEntities: {},
      treeData: [],
      flattenNodes: [],
      cachedFlattenNodes: void 0,
      selectedKeys: [],
      checkedKeys: /* @__PURE__ */ new Set(),
      halfCheckedKeys: /* @__PURE__ */ new Set(),
      realCheckedKeys: /* @__PURE__ */ new Set([]),
      disabledKeys: /* @__PURE__ */ new Set(),
      motionKeys: /* @__PURE__ */ new Set([]),
      motionType: "hide",
      expandedKeys: new Set(t.expandedKeys),
      filteredKeys: /* @__PURE__ */ new Set(),
      filteredExpandedKeys: /* @__PURE__ */ new Set(),
      filteredShownKeys: /* @__PURE__ */ new Set(),
      prevProps: null,
      isHovering: !1,
      cachedKeyValuePairs: {},
      loadedKeys: /* @__PURE__ */ new Set(),
      loadingKeys: /* @__PURE__ */ new Set()
    }), z = q(), H = q(), B = q(), Z = q();
    let _ = null;
    Math.random().toString(36).slice(2);
    let De, Le;
    const {
      adapter: Fe,
      context: Ve,
      getDataAttr: $e
    } = Dt(t, g);
    function Ae() {
      const e = {
        updateInputValue: (l) => {
          g.inputValue = l;
        }
      }, o = {
        registerClickOutsideHandler: (l) => {
          J.unregisterClickOutsideHandler(), _ = (a) => {
            var i, C;
            const r = Z && ((C = (i = Z.value).getRef) == null ? void 0 : C.call(i).vnode.el), d = B && B.value, f = r, c = a.target, h = a.composedPath && a.composedPath() || [c];
            f && (!f.contains(c) || !f.contains(c.parentNode)) && d && !d.contains(c) && !(h.includes(d) || h.includes(f)) && l(a);
          }, document.addEventListener("mousedown", _, !1);
        },
        unregisterClickOutsideHandler: () => {
          document.removeEventListener("mousedown", _, !1), _ = null;
        },
        rePositionDropdown: () => {
          let {
            rePosKey: l
          } = g;
          l = l + 1, g.rePosKey = l;
        }
      }, s = {
        updateState: (l) => {
          Object.keys(l).forEach((a) => {
            g[a] = l[a];
          });
        },
        notifySelect: (l, a, r) => {
          t.onSelect && t.onSelect(l, a, r);
        },
        notifySearch: (l, a, r) => {
          t.onSearch && t.onSearch(l, a, r);
        },
        cacheFlattenNodes: (l) => {
          g.cachedFlattenNodes = l ? ce(g.flattenNodes) : void 0;
        },
        notifyLoad: (l, a) => {
          const {
            onLoad: r
          } = t;
          X(r) && r(l, a);
        },
        notifyClear: (l) => {
          t.onClear && t.onClear(l);
        }
      };
      return {
        ...Fe(),
        ...e,
        ...o,
        ...s,
        updateLoadKeys: (l, a) => {
          const {
            loadingKeys: r
          } = S.handleNodeLoad(g.loadedKeys || /* @__PURE__ */ new Set([]), g.loadingKeys || /* @__PURE__ */ new Set([]), l, a);
          g.loadingKeys = r;
        },
        updateState: (l) => {
          Object.keys(l).forEach((a) => {
            g[a] = l[a];
          });
        },
        openMenu: () => {
          g.isOpen = !0, Se(() => {
            t.onVisibleChange(!0);
          });
        },
        closeMenu: (l) => {
          g.isOpen = !1, Se(() => {
            l && l(), t.onVisibleChange(!1);
          });
        },
        getTriggerWidth: () => {
          const l = B.value;
          return l && l.getBoundingClientRect().width;
        },
        setOptionWrapperWidth: (l) => {
          g.dropdownMinWidth = l;
        },
        notifyChange: (l, a, r) => {
          t.onChange && t.onChange(l, a, r);
        },
        notifyChangeWithObject: (l, a) => {
          t.onChange && t.onChange(l, a);
        },
        notifyExpand: (l, {
          expanded: a,
          node: r
        }) => {
          t.onExpand && t.onExpand([...l], {
            expanded: a,
            node: r
          }), a && t.loadData && at(r);
        },
        notifyFocus: (...l) => {
          t.onFocus && t.onFocus(...l);
        },
        notifyBlur: (...l) => {
          t.onBlur && t.onBlur(...l);
        },
        toggleHovering: (l) => {
          g.isHovering = l;
        },
        updateInputFocus: (l) => {
          if (l) {
            if (z.value) {
              const {
                preventScroll: a
              } = t;
              z.value.focus({
                preventScroll: a
              });
            }
            H.value && H.value.focus();
          } else
            z.value && z.value.blur(), H.value && H.value.blur();
        },
        updateIsFocus: (l) => {
          g.isFocus = l;
        }
      };
    }
    const J = Ae(), S = new wt(J), Me = () => {
      J.rePositionDropdown();
    };
    function je(e, o) {
      const {
        prevProps: s,
        rePosKey: l
      } = o, {
        keyMaps: a
      } = e, r = (y) => !s && y in e || s && !xe(s[y], e[y]);
      let d;
      const f = e.onChangeWithObject;
      let c = o.keyEntities || {}, h = o.cachedKeyValuePairs || {};
      const i = {
        prevProps: e
      }, C = r("treeData"), x = r("expandedKeys"), b = !!(e.filterTreeNode && o.inputValue && o.inputValue.length);
      if (C) {
        d = e.treeData, i.treeData = d;
        const y = pt(d, a);
        i.keyEntities = {
          ...y.keyEntities
        }, c = i.keyEntities, i.cachedKeyValuePairs = {
          ...y.valueEntities
        }, h = i.cachedKeyValuePairs;
      }
      d && e.motion && !xe(Object.keys(i.keyEntities), Object.keys(o.keyEntities)) && s && e.motion && (i.motionKeys = /* @__PURE__ */ new Set([]), i.motionType = null);
      const w = C && e.expandAll;
      if (b) {
        let y;
        if (d && (y = vt({
          treeData: d,
          inputValue: o.inputValue,
          filterTreeNode: e.filterTreeNode,
          filterProps: e.treeNodeFilterProp,
          showFilteredOnly: e.showFilteredOnly,
          keyEntities: i.keyEntities,
          prevExpandedKeys: [...o.filteredExpandedKeys],
          keyMaps: a
        }), i.flattenNodes = y.flattenNodes, i.motionKeys = /* @__PURE__ */ new Set([]), i.filteredKeys = y.filteredKeys, i.filteredShownKeys = y.filteredShownKeys, i.filteredExpandedKeys = y.filteredExpandedKeys), e.expandedKeys) {
          if (i.filteredExpandedKeys = se(e.expandedKeys, c, e.autoExpandParent || !s), s && e.motion) {
            const T = o ? o.filteredExpandedKeys : /* @__PURE__ */ new Set([]);
            if (!d) {
              const p = Te(T, i.filteredExpandedKeys, c);
              let {
                motionKeys: E
              } = p;
              const {
                motionType: k
              } = p;
              e.showFilteredOnly && (E = E.filter((N) => o.filteredShownKeys.has(N))), k === "hide" && (i.cachedFlattenNodes = ce(o.flattenNodes)), i.motionKeys = new Set(E), i.motionType = k;
            }
          }
          i.flattenNodes = Pe(d || o.treeData, i.filteredExpandedKeys || o.filteredExpandedKeys, a, e.showFilteredOnly && o.filteredShownKeys);
        }
      } else {
        if (x || s && r("autoExpandParent")) {
          if (i.expandedKeys = se(e.expandedKeys, c, e.autoExpandParent || !s), s && e.motion && !d) {
            const {
              motionKeys: y,
              motionType: T
            } = Te(o.expandedKeys, i.expandedKeys, c);
            i.motionKeys = new Set(y), i.motionType = T, T === "hide" && (i.cachedFlattenNodes = ce(o.flattenNodes));
          }
        } else !s && (e.defaultExpandAll || e.expandAll) || w ? i.expandedKeys = new Set(Object.keys(c)) : !s && e.defaultExpandedKeys ? i.expandedKeys = se(e.defaultExpandedKeys, c) : !s && e.defaultValue ? i.expandedKeys = Ke(O(e.defaultValue, f, a), c, e.multiple, h) : !s && e.value && (i.expandedKeys = Ke(O(e.value, f, a), c, e.multiple, h));
        if (i.expandedKeys || delete i.expandedKeys, d || i.expandedKeys) {
          const y = Pe(d || o.treeData, i.expandedKeys || o.expandedKeys, a);
          i.flattenNodes = y;
        }
      }
      const K = e.multiple;
      if (!K)
        r("value") ? i.selectedKeys = M(O(e.value, f, a), h, K) : !s && e.defaultValue ? i.selectedKeys = M(O(e.defaultValue, f, a), h, K) : d && (e.value ? i.selectedKeys = M(O(e.value, f, a) || "", h, K) : i.selectedKeys = we(o.selectedKeys, c));
      else {
        let y;
        if (r("value") ? y = M(O(e.value, f, a), h, K) : !s && e.defaultValue ? y = M(O(e.defaultValue, f, a), h, K) : d && (e.value ? y = M(O(e.value, f, a) || [], h, K) : y = we(e.checkRelation === "related" ? o.checkedKeys : o.realCheckedKeys, c)), y) {
          if (e.checkRelation === "unRelated")
            i.realCheckedKeys = new Set(y);
          else if (e.checkRelation === "related") {
            const {
              checkedKeys: T,
              halfCheckedKeys: p
            } = Et(y, c);
            i.checkedKeys = T, i.halfCheckedKeys = p;
          }
        }
      }
      return r("loadedKeys") && (i.loadedKeys = new Set(e.loadedKeys)), (C || r("value")) && (i.rePosKey = l + 1), d && e.disableStrictly && e.checkRelation === "related" && (i.disabledKeys = Nt(c, a)), i;
    }
    bt([() => t.loadedKeys, () => t.loadData, () => t.onLoad, () => t.arrowIcon, () => t.defaultOpen, () => t.defaultValue, () => t.defaultExpandAll, () => t.defaultExpandedKeys, () => t.expandAll, () => t.disabled, () => t.disableStrictly, () => t.filterTreeNode, () => t.multiple, () => t.searchPlaceholder, () => t.searchAutoFocus, () => t.virtualize, () => t.treeNodeFilterProp, () => t.onChange, () => t.onSearch, () => t.onSelect, () => t.onExpand, () => t.onChangeWithObject, () => t.onBlur, () => t.onFocus, () => t.value, () => t.expandedKeys, () => t.autoExpandParent, () => t.showClear, () => t.showSearchClear, () => t.autoAdjustOverflow, () => t.showFilteredOnly, () => t.motionExpand, () => t.emptyContent, () => t.leafOnly, () => t.treeData, () => t.dropdownClassName, () => t.dropdownStyle, () => t.motion, () => t.placeholder, () => t.maxTagCount, () => t.size, () => t.className, () => t.style, () => t.treeNodeLabelProp, () => t.suffix, () => t.prefix, () => t.insetLabel, () => t.insetLabelId, () => t.zIndex, () => t.getPopupContainer, () => t.dropdownMatchSelectWidth, () => t.validateStatus, () => t.mouseEnterDelay, () => t.mouseLeaveDelay, () => t.triggerRender, () => t.stopPropagation, () => t.outerBottomSlot, () => t.outerTopSlot, () => t.onVisibleChange, () => t.expandAction, () => t.searchPosition, () => t.clickToHide, () => t.renderLabel, () => t.renderFullLabel, () => t.labelEllipsis, () => t.optionListStyle, () => t.searchRender, () => t.renderSelectedItem, () => t.checkRelation, () => Re.defautl], () => {
      const e = je({
        ...t
      }, {
        ...g
      });
      Object.keys(e).forEach((o) => {
        g[o] = e[o];
      });
    }, {
      immediate: !0
    }), St(() => {
      S.init();
    }), xt(() => {
      S.destroy();
    });
    const ze = () => {
      const {
        suffix: e
      } = t, o = v({
        [`${m}-suffix`]: !0,
        [`${m}-suffix-text`]: e && Ce(e),
        [`${m}-suffix-icon`]: Ee(e)
      });
      return u("div", {
        class: o,
        "x-semi-prop": "suffix"
      }, [e]);
    }, He = () => {
      const {
        prefix: e,
        insetLabel: o,
        insetLabelId: s
      } = t, l = e || o, a = v({
        [`${m}-prefix`]: !0,
        // to be doublechecked
        [`${m}-inset-label`]: o,
        [`${m}-prefix-text`]: l && Ce(l),
        [`${m}-prefix-icon`]: Ee(l)
      });
      return u("div", {
        class: a,
        id: s,
        "x-semi-prop": "prefix,insetLabel"
      }, [l]);
    }, Be = () => {
      const {
        dropdownMinWidth: e
      } = g, {
        dropdownStyle: o,
        dropdownClassName: s
      } = t, l = {
        minWidth: isNaN(e) ? e : e + "px",
        ...o
      }, a = v(s, `${m}-popover`);
      return u("div", {
        class: a,
        style: l,
        onKeydown: S.handleKeyDown
      }, [ft()]);
    }, W = (e) => {
      S.removeTag(e);
    }, _e = (e) => {
      S.handleClick(e);
    }, fe = (e) => S.getDataForKeyNotInKeyEntities(e), We = (e) => {
      S.handleSelectionEnterPress(e);
    }, ye = () => {
      const {
        multiple: e,
        checkRelation: o
      } = t, {
        realCheckedKeys: s,
        checkedKeys: l,
        selectedKeys: a
      } = g;
      let r = !1;
      return e ? o === "related" ? r = !!l.size : o === "unRelated" && (r = !!s.size) : r = !!a.length, r;
    }, he = () => {
      const {
        showClear: e,
        disabled: o,
        searchPosition: s
      } = t, {
        inputValue: l,
        isOpen: a,
        isHovering: r
      } = g, d = s === L.SEARCH_POSITION_TRIGGER && l;
      return e && (ye() || d) && !o && (a || r);
    }, Ge = (e) => {
      const {
        keyEntities: o,
        disabledKeys: s
      } = g, {
        treeNodeLabelProp: l,
        leafOnly: a,
        disabled: r,
        disableStrictly: d,
        size: f,
        renderSelectedItem: c,
        keyMaps: h
      } = t, i = A(h, "label", l), C = X(c) ? c : (b) => ({
        isRenderInTag: !0,
        content: A(b, i, null)
      }), x = [];
      return e.forEach((b, w) => {
        const K = o[b] && o[b].key === b ? o[b].data : fe(b), y = (N, P) => {
          P && typeof P.preventDefault == "function" && P.preventDefault(), W(b);
        }, {
          content: T,
          isRenderInTag: p
        } = K ? C(K, {
          index: w,
          onClose: y
        }) : {};
        if (!T)
          return;
        const k = {
          closable: !(r || K.disabled || d && s.has(K.key)),
          color: "white",
          visible: !0,
          onClose: y,
          key: `tag-${b}-${w}`,
          size: f === "small" ? "small" : "large"
        };
        p ? x.push(u(re, k, j(T) ? T : {
          default: () => [T]
        })) : x.push(T);
      }), x;
    }, Ue = () => {
      const {
        placeholder: e,
        disabled: o
      } = t, {
        inputTriggerFocus: s
      } = g, l = S.getRenderTextInSingle(), a = v(`${m}-selection-TriggerSearchItem`, {
        [`${m}-selection-TriggerSearchItem-placeholder`]: (s || !l) && !o,
        [`${m}-selection-TriggerSearchItem-disabled`]: o
      });
      return u("span", {
        class: a,
        onClick: S.onClickSingleTriggerSearchItem
      }, [l || e]);
    }, qe = () => {
      const {
        inputValue: e
      } = g;
      return u($, null, [ge(), !e && Ue()]);
    }, Xe = (e) => {
      const {
        multiple: o,
        placeholder: s,
        maxTagCount: l,
        searchPosition: a,
        filterTreeNode: r,
        showRestTagsPopover: d,
        restTagsPopoverProps: f
      } = t;
      if (r && a === L.SEARCH_POSITION_TRIGGER)
        return o ? ot(e) : qe();
      if (!o || !ye()) {
        const i = S.getRenderTextInSingle(), C = v(`${m}-selection-content`, {
          [`${m}-selection-placeholder`]: !i
        });
        return u("span", {
          class: C
        }, [i || s]);
      }
      const h = Ge(e);
      return u(Lt, {
        maxTagCount: l,
        tagList: h,
        size: "large",
        mode: "custom",
        showPopover: d,
        popoverProps: f
      }, null);
    }, me = (e) => {
      e && e.stopPropagation(), S.handleClear(e);
    }, Ze = (e) => {
      e && e.stopPropagation(), S.handleClearEnterPress(e);
    }, Je = (e) => {
      S.toggleHoverState(!0);
    }, Qe = (e) => {
      S.toggleHoverState(!1);
    }, Q = (e) => {
      const {
        isOpen: o
      } = g;
      o || S.open(), S.handleInputChange(e);
    }, Ye = () => {
      const e = he(), {
        arrowIcon: o
      } = t;
      return e ? null : o ? u("div", {
        class: v(`${m}-arrow`),
        "x-semi-prop": "arrowIcon"
      }, [o]) : null;
    }, et = () => {
      const e = he(), {
        clearIcon: o
      } = t, s = v(`${m}-clearbtn`);
      return e ? u("div", {
        role: "button",
        tabindex: 0,
        "aria-label": "Clear TreeSelect value",
        class: s,
        onClick: me,
        onKeypress: Ze
      }, [o || u(Ht, null, null)]) : null;
    }, tt = () => {
      const {
        disabled: e,
        multiple: o,
        filterTreeNode: s,
        validateStatus: l,
        prefix: a,
        suffix: r,
        style: d,
        size: f,
        insetLabel: c,
        className: h,
        placeholder: i,
        showClear: C,
        leafOnly: x,
        searchPosition: b,
        triggerRender: w,
        borderless: K,
        autoMergeValue: y,
        checkRelation: T,
        ...p
      } = t, {
        inputValue: E,
        selectedKeys: k,
        checkedKeys: N,
        keyEntities: P,
        isFocus: R,
        realCheckedKeys: ee
      } = g, G = !!s, U = typeof w == "function", te = C ? {
        onMouseenter: (ae) => Je(),
        onMouseleave: (ae) => Qe()
      } : {}, F = b === L.SEARCH_POSITION_TRIGGER && G, ne = F && I(N), oe = F && !I(N), yt = U ? v(h) : v(m, {
        [`${m}-borderless`]: K,
        [`${m}-focus`]: R,
        [`${m}-disabled`]: e,
        [`${m}-single`]: !o,
        [`${m}-multiple`]: o,
        [`${m}-multiple-tagInput-empty`]: o && ne,
        [`${m}-multiple-tagInput-notEmpty`]: o && oe,
        [`${m}-filterable`]: G,
        [`${m}-error`]: l === "error",
        [`${m}-warning`]: l === "warning",
        [`${m}-small`]: f === "small",
        [`${m}-large`]: f === "large",
        [`${m}-with-prefix`]: a || c,
        [`${m}-with-suffix`]: r,
        [`${m}-with-suffix`]: r
      }, h);
      let le, V = [];
      return o ? y ? T === "related" ? V = pe([...N], P, x, !0) : T === "unRelated" && (V = [...ee]) : V = [...N] : V = k, U ? le = u(Mt, {
        inputValue: E,
        value: V.map((ae) => A(P, [ae, "data"])),
        disabled: e,
        placeholder: i,
        onClear: me,
        componentName: "TreeSelect",
        triggerRender: w,
        componentProps: {
          ...t
        },
        onSearch: Q,
        onRemove: W
      }, null) : le = [u($, {
        key: "prefix"
      }, [a || c ? He() : null]), u($, {
        key: "selection"
      }, [u("div", {
        class: `${m}-selection`
      }, [Xe(V)])]), u($, {
        key: "suffix"
      }, [r ? ze() : null]), u($, {
        key: "clearBtn"
      }, [C || F && E ? et() : null]), u($, {
        key: "arrow"
      }, [Ye()])], u("div", ie({
        role: "combobox",
        "aria-disabled": e,
        "aria-haspopup": "tree",
        tabindex: e ? null : 0,
        class: yt,
        style: d,
        ref: B,
        onClick: _e,
        onKeypress: We,
        "aria-invalid": t["aria-invalid"],
        "aria-errormessage": t["aria-errormessage"],
        "aria-label": t["aria-label"],
        "aria-labelledby": t["aria-labelledby"],
        "aria-describedby": t["aria-describedby"],
        "aria-required": t["aria-required"]
      }, te, $e()), {
        default: () => le
      });
    }, nt = (e, o) => {
      const {
        keyEntities: s,
        disabledKeys: l
      } = g, {
        size: a,
        leafOnly: r,
        disabled: d,
        disableStrictly: f,
        renderSelectedItem: c,
        treeNodeLabelProp: h,
        keyMaps: i
      } = t;
      A(i, "label", h);
      const x = pe([e], s, r, !0).map((P) => s[e] && s[e].key === e ? s[e].data : fe(e)), b = kt(x, i), w = v(`${m}-selection-tag`, {
        [`${m}-selection-tag-disabled`]: d
      }), K = !I(x) && !I(x[0]), y = f && K && l.has(x[0].key), T = K && !x[0].disabled && !d && !y, p = (P, R) => {
        R.preventDefault(), W(e);
      }, E = {
        size: a === "small" ? "small" : "large",
        key: `tag-${b}-${o}`,
        color: "white",
        className: w,
        closable: T,
        onClose: p
      }, k = x[0], N = X(c) ? c : (P) => ({
        isRenderInTag: !0,
        content: A(P, h, null)
      });
      if (X(N)) {
        const {
          content: P,
          isRenderInTag: R
        } = k ? N(k, {
          index: o,
          onClose: p
        }) : {};
        return R ? u(re, E, j(P) ? P : {
          default: () => [P]
        }) : P;
      }
      return u(re, E, j(b) ? b : {
        default: () => [b]
      });
    }, ot = (e) => {
      const {
        disabled: o,
        size: s,
        searchAutoFocus: l,
        placeholder: a,
        maxTagCount: r,
        showRestTagsPopover: d,
        restTagsPopoverProps: f,
        searchPosition: c,
        filterTreeNode: h,
        preventScroll: i
      } = t, {
        inputValue: C
      } = g, x = h && c === L.SEARCH_POSITION_TRIGGER ? l : void 0;
      return u(jt, {
        maxTagCount: r,
        disabled: o,
        onInputChange: (b) => Q(b),
        ref: H,
        placeholder: a,
        value: e,
        inputValue: C,
        size: s,
        showRestTagsPopover: d,
        restTagsPopoverProps: f,
        autoFocus: x,
        renderTagItem: (b, w) => nt(b, w),
        onRemove: (b) => W(b),
        expandRestTagsOnClick: !1,
        preventScroll: i
      }, null);
    }, ge = () => {
      const {
        searchPlaceholder: e,
        searchRender: o,
        showSearchClear: s,
        searchPosition: l,
        searchAutoFocus: a,
        multiple: r,
        disabled: d,
        preventScroll: f
      } = t, c = l === L.SEARCH_POSITION_DROPDOWN, h = v({
        [`${D}-input`]: c,
        [`${m}-inputTrigger`]: !c
      }), {
        inputValue: i
      } = g, C = {
        value: i,
        className: h,
        preventScroll: f,
        onChange: (T) => Q(T)
      }, x = {
        showClear: s,
        prefix: u(Bt, null, null)
      }, w = c ? x : {
        autofocus: a,
        onFocus: (T) => S.handleInputTriggerFocus(),
        onBlur: (T) => S.handleInputTriggerBlur(),
        disabled: d
      }, K = v({
        [`${D}-search-wrapper`]: c,
        [`${m}-triggerSingleSearch-wrapper`]: !c && !r
      }), y = typeof o == "function" || typeof o == "boolean";
      return y && !o ? null : u("div", {
        class: K
      }, [u(ve, {
        componentName: "TreeSelect"
      }, {
        default: (T) => {
          const p = c ? e || T.searchPlaceholder : "";
          return y ? o({
            ...w,
            ...C,
            placeholder: p
          }) : u(Ft, ie({
            "aria-label": "Filter TreeSelect item",
            ref: z,
            placeholder: p
          }, C, w), null);
        }
      })]);
    }, lt = () => {
      const {
        emptyContent: e
      } = t;
      return e === null ? null : e ? u(de, {
        key: "treeSelectTreeNode",
        empty: !0,
        emptyContent: t.emptyContent
      }, null) : u(ve, {
        componentName: "Tree"
      }, {
        default: (o) => u(de, {
          key: "treeSelectTreeNode",
          empty: !0,
          emptyContent: o.emptyText
        }, null)
      });
    }, at = (e) => new Promise((o) => S.setLoadKeys(e, o)), it = (e, o) => {
      S.handleNodeSelect(e, o);
    }, st = (e, o) => {
      S.handleNodeSelect(e, o);
    }, rt = (e, o) => {
      S.handleNodeExpand(e, o);
    }, dt = (e) => {
      S.handlePopoverVisibleChange(e);
    }, ct = () => {
      S.handleAfterClose();
    }, Y = (e, o, s) => {
      const {
        data: l,
        key: a
      } = e, r = S.getTreeNodeProps(a), {
        showLine: d
      } = t;
      if (!r)
        return null;
      const f = Kt(e, ["key", "label", "disabled", "isLeaf", "icon", "isEnd"]), {
        keyMaps: c
      } = f, h = l[A(c, "children", "children")];
      return !Pt(h) && (f.children = h), console.debug(g.loadingKeys.size), u(de, ie(r, l, f, {
        data: l,
        style: s,
        showLine: d
      }), null);
    }, ut = (e, o) => {
      const {
        visibleOptions: s
      } = o;
      return s[e].key;
    }, be = () => {
      const {
        flattenNodes: e,
        cachedFlattenNodes: o,
        motionKeys: s,
        motionType: l,
        filteredKeys: a
      } = g, {
        direction: r
      } = Ve.value, {
        virtualize: d,
        motionExpand: f
      } = t, c = "expandedKeys" in Oe(t);
      if (!d || I(d))
        return u(At, {
          flattenNodes: e,
          flattenList: o,
          motionKeys: f ? s : /* @__PURE__ */ new Set([]),
          motionType: l,
          searchTargetIsDeep: c && f && I(s) && !I(a),
          onMotionEnd: Me,
          renderTreeNode: Y
        }, null);
      const h = {
        visibleOptions: e,
        renderOption: Y
      };
      return u(Vt, {
        defaultHeight: Ne(d.height),
        defaultWidth: Ne(d.width),
        children: ({
          height: i,
          width: C
        }) => u(Ot, {
          itemCount: e.length,
          itemSize: d.itemSize,
          height: i,
          width: C,
          itemKey: ut,
          itemData: h,
          className: `${D}-virtual-list`,
          style: {
            direction: r
          }
        }, j(ue) ? ue : {
          default: () => [ue]
        })
      }, null);
    }, ft = () => {
      let e;
      const {
        keyEntities: o,
        motionKeys: s,
        motionType: l,
        inputValue: a,
        filteredKeys: r,
        flattenNodes: d,
        checkedKeys: f,
        realCheckedKeys: c
      } = g, {
        loadData: h,
        filterTreeNode: i,
        disabled: C,
        multiple: x,
        showFilteredOnly: b,
        motionExpand: w,
        outerBottomSlot: K,
        outerTopSlot: y,
        expandAction: T,
        labelEllipsis: p,
        virtualize: E,
        optionListStyle: k,
        searchPosition: N,
        renderLabel: P,
        renderFullLabel: R,
        checkRelation: ee,
        emptyContent: G
      } = t, U = v(`${D}-wrapper`), te = !!a && !r.size, F = I(d) || b && te, ne = N === L.SEARCH_POSITION_DROPDOWN, oe = v(`${D}-option-list ${D}-option-list-block`, {
        [`${D}-option-list-hidden`]: G === null && F
      });
      return u($t.Provider, {
        value: {
          loadData: h,
          treeDisabled: C,
          motion: w,
          motionKeys: s,
          motionType: l,
          expandAction: T,
          filterTreeNode: i,
          keyEntities: o,
          onNodeClick: De,
          onNodeDoubleClick: Le,
          // tree node will call this function when treeNode is right clicked
          onNodeRightClick: ke,
          onNodeExpand: rt,
          onNodeSelect: it,
          onNodeCheck: st,
          renderTreeNode: Y,
          multiple: x,
          showFilteredOnly: b,
          isSearching: !!a,
          renderLabel: P,
          renderFullLabel: R,
          labelEllipsis: typeof p > "u" ? E : p
        }
      }, {
        default: () => [u("div", {
          class: U
        }, [y, !y && i && ne && ge(), u("div", {
          class: oe,
          role: "tree",
          "aria-multiselectable": !!x,
          style: k
        }, [F ? lt() : x ? u(_t, {
          value: Array.from(ee === "related" ? f : c)
        }, j(e = be()) ? e : {
          default: () => [e]
        }) : be()]), K])]
      });
    };
    return () => {
      const e = Be(), {
        motion: o,
        zIndex: s,
        mouseLeaveDelay: l,
        mouseEnterDelay: a,
        autoAdjustOverflow: r,
        stopPropagation: d,
        getPopupContainer: f,
        dropdownMargin: c,
        position: h
      } = t, {
        isOpen: i,
        rePosKey: C
      } = g, x = tt();
      return u(Wt, {
        stopPropagation: d,
        getPopupContainer: f,
        zIndex: s,
        motion: o,
        margin: c,
        ref: Z,
        content: e,
        visible: i,
        trigger: "custom",
        rePosKey: C,
        position: h || "bottomLeft",
        autoAdjustOverflow: r,
        mouseLeaveDelay: l,
        mouseEnterDelay: a,
        onVisibleChange: dt,
        afterClose: ct
      }, j(x) ? x : {
        default: () => [x]
      });
    };
  }
});
export {
  vn as default,
  Xt as vuePropsType
};
//# sourceMappingURL=index.js.map
