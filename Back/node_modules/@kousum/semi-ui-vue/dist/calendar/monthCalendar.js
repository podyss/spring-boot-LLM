import { defineComponent as Q, useSlots as Y, ref as Z, reactive as ee, onMounted as te, onBeforeUnmount as ne, watch as se, createVNode as t, mergeProps as oe, createTextVNode as ae } from "vue";
import M from "classnames";
import { isEqual as N } from "lodash";
import * as a from "../PropTypes";
import { vuePropsMake as re } from "../PropTypes";
import { IconClose as le } from "@kousum/semi-icons-vue";
import ie from '@douyinfe/semi-foundation/lib/es/calendar/foundation';
import { cssClasses as g } from '@douyinfe/semi-foundation/lib/es/calendar/constants';
import S from "../locale/localeConsumer";
import { useBaseComponent as ce } from "../_base/baseComponent";
import de from "../popover";
import me from "../iconButton";
import '@douyinfe/semi-foundation/lib/es/calendar/calendar.css';
const V = (i) => `${i < 1 ? i * 100 : 100}%`, h = `${g.PREFIX}-month`, ue = 60, pe = 24, he = {
  displayValue: a.object,
  header: a.node,
  events: a.array,
  mode: a.string,
  markWeekend: a.bool,
  width: a.oneOfType([a.number, a.string]),
  height: a.oneOfType([a.number, a.string]),
  style: a.object,
  className: a.string,
  dateGridRender: a.func,
  onClick: a.func,
  onClose: a.func,
  weekStartsOn: a.number,
  renderDateDisplay: a.func,
  minEventHeight: a.number,
  allDayEventsRender: a.func
  // range: PropTypes.array as PropType<MonthCalendarProps['range']>,
  // showCurrTime: PropTypes.bool as PropType<MonthCalendarProps['showCurrTime']>,
  // scrollTop: PropTypes.number as PropType<MonthCalendarProps['scrollTop']>,
  // renderTimeDisplay: PropTypes.func as PropType<MonthCalendarProps['renderTimeDisplay']>,
}, fe = {
  displayValue: /* @__PURE__ */ new Date(),
  events: [],
  mode: "month"
}, ye = re(he, fe), Ie = /* @__PURE__ */ Q({
  props: {
    ...ye
  },
  name: "MonthCalendar",
  setup(i, {}) {
    Y();
    const P = Z(), R = /* @__PURE__ */ new Map();
    let F, k, D;
    const m = ee({
      itemLimit: 0,
      showCard: {},
      parsedEvents: {},
      cachedKeys: []
    }), {
      adapter: H,
      getDataAttr: B
    } = ce(i, m);
    function K() {
      return {
        ...H(),
        registerClickOutsideHandler: (e, n) => {
          D = (s) => {
            const l = R && R.get(e), o = s.target, f = s.composedPath && s.composedPath() || [o];
            l && !l.contains(s.target) && !f.includes(l) && n();
          }, document.addEventListener("mousedown", D, !1);
        },
        unregisterClickOutsideHandler: () => {
          document.removeEventListener("mousedown", D, !1);
        },
        setMonthlyData: (e) => {
          k = e;
        },
        getMonthlyData: () => k,
        notifyClose: (e, n) => {
          const s = {};
          s[n] = [!1], m.showCard = {
            ...m.showCard,
            ...s
          }, i.onClose && i.onClose(e);
        },
        openCard: (e, n) => {
          const s = {}, r = n ? "leftTopOver" : "rightTopOver";
          s[e] = [!0, r], m.showCard = {
            ...s
          };
        },
        setParsedEvents: (e) => {
          m.parsedEvents = e;
        },
        setItemLimit: (e) => {
          m.itemLimit = e;
        },
        cacheEventKeys: (e) => {
          m.cachedKeys = e;
        }
      };
    }
    const W = K(), C = new ie(W), O = () => (F = P.value.getBoundingClientRect().height, Math.max(0, Math.ceil((F - ue) / pe)));
    te(() => {
      C.init();
      const e = O();
      C.parseMonthlyEvents(e);
    }), ne(() => {
      C.destroy();
    }), se([() => m.cachedKeys, () => m.itemLimit, () => i.events, () => i.height, () => i.displayValue], (e, [n, s, r, l, o], f) => {
      const y = n, c = i.events.map((p) => p.key);
      let d = !1, {
        itemLimit: v
      } = m;
      l !== i.height && (v = O(), s !== v && (d = !0)), (!N(y, c) || d || !N(o, i.displayValue)) && C.parseMonthlyEvents(v);
    });
    const T = (e, n) => {
      const {
        onClick: s
      } = i, r = C.formatCbValue(n);
      s && s(e, r);
    };
    function j(e, n) {
      C.closeCard(e, n);
    }
    const G = (e, n) => {
      C.showCard(e, n);
    }, A = (e) => {
      const {
        markWeekend: n,
        displayValue: s
      } = i;
      return k = C.getMonthlyData(s, e), t("div", {
        class: `${h}-header`,
        role: "presentation"
      }, [t("div", {
        role: "presentation",
        class: `${h}-grid`
      }, [t("ul", {
        role: "row",
        class: `${h}-grid-row`
      }, [k[0].map((r) => {
        const {
          weekday: l
        } = r, o = M({
          [`${g.PREFIX}-weekend`]: n && r.isWeekend
        });
        return t("li", {
          role: "columnheader",
          "aria-label": l,
          key: `${l}-monthheader`,
          class: o
        }, [t("span", null, [l])]);
      })])])]);
    }, U = (e) => {
      const {
        itemLimit: n
      } = m;
      return e ? e.map((r, l) => {
        const {
          leftPos: o,
          width: f,
          topInd: y,
          key: c,
          children: d
        } = r, v = {
          left: V(o),
          width: V(f),
          top: `${y}em`
        };
        return y < n ? t("li", {
          class: `${g.PREFIX}-event-item ${g.PREFIX}-event-month`,
          key: c || `${l}-monthevent`,
          style: v
        }, [d]) : null;
      }) : void 0;
    }, q = (e, n, s, r) => {
      const {
        itemLimit: l,
        showCard: o
      } = m, {
        weekday: f,
        dayString: y,
        date: c
      } = n, d = c.toString(), v = e.filter((u) => !!u).length - l, p = `${h}-event-card`, L = v > 0, w = t(me, {
        className: `${p}-close`,
        onClick: (u) => j(u, d),
        type: "tertiary",
        icon: t(le, null, null),
        theme: "borderless",
        size: "small"
      }, null), $ = t("div", {
        class: `${p}-header-info`
      }, [t("div", {
        class: `${p}-header-info-weekday`
      }, [f]), t("div", {
        class: `${p}-header-info-date`
      }, [y])]), E = t("div", {
        class: p
      }, [t("div", {
        class: `${p}-content`
      }, [t("div", {
        class: `${p}-header`
      }, [$, w]), t("div", {
        class: `${p}-body`
      }, [t("ul", {
        class: `${p}-list`
      }, [e.map((u) => t("li", {
        key: u.key || `${u.start.toString()}-event`
      }, [u.children]))])])])]), b = o && o[d] ? o[d][1] : "leftTopOver", I = t(S, {
        componentName: "Calendar"
      }, {
        default: (u) => t("div", oe({
          class: `${p}-wrapper`,
          style: {
            bottom: 0
          },
          onClick: (J) => G(J, d)
        }, B()), [u.remaining.replace("${remained}", String(v))])
      });
      return t(de, {
        key: `${c.valueOf()}`,
        content: E,
        position: b,
        trigger: "custom",
        visible: o && o[d] && o[d][0],
        ref: (u) => R.set(d, u)
      }, {
        default: () => [t("li", {
          key: c,
          class: s,
          onClick: (u) => T(u, [c])
        }, [X(c, r, y), L ? I : null, x(c)])]
      });
    }, X = (e, n, s) => {
      const {
        renderDateDisplay: r
      } = i;
      return r ? r(e) : s === "1" ? t(S, {
        componentName: "Calendar"
      }, {
        default: (l, o) => t("span", {
          class: `${h}-date`
        }, [n, t("span", {
          class: `${g.PREFIX}-today-date`
        }, [ae("Â "), s]), l.datestring])
      }) : (
        // eslint-disable-next-line max-len
        t("span", {
          class: `${h}-date`
        }, [t("span", {
          class: `${g.PREFIX}-today-date`
        }, [s])])
      );
    }, x = (e) => {
      const {
        dateGridRender: n
      } = i;
      return n ? n(e.toString(), e) : null;
    }, z = (e, n, s = {}) => {
      const {
        markWeekend: r
      } = i, {
        itemLimit: l
      } = m, {
        display: o,
        day: f
      } = s;
      return t("div", {
        role: "presentation",
        class: `${h}-weekrow`,
        ref: P,
        key: `${e}-weekrow`
      }, [t("ul", {
        role: "row",
        class: `${h}-skeleton`
      }, [n.map((y) => {
        const {
          date: c,
          dayString: d,
          isToday: v,
          isSameMonth: p,
          isWeekend: L,
          month: w,
          ind: $
        } = y, E = M({
          [`${g.PREFIX}-today`]: v,
          [`${g.PREFIX}-weekend`]: r && L,
          [`${h}-same`]: p
        }), b = !!(f && f[$] && f[$].length > l), I = t("li", {
          role: "gridcell",
          "aria-label": c.toLocaleDateString(),
          "aria-current": v ? "date" : !1,
          key: `${c}-weeksk`,
          class: E,
          onClick: (u) => T(u, [c])
        }, [X(c, w, d), x(c)]);
        return b ? q(f[$], y, E, w) : I;
      })]), t("ul", {
        class: `${g.PREFIX}-event-items`
      }, [o ? U(o) : null])]);
    }, _ = () => {
      const {
        parsedEvents: e
      } = m;
      return t("div", {
        role: "presentation",
        class: `${h}-week`
      }, [t("ul", {
        role: "presentation",
        class: `${h}-grid-col`
      }, [Object.keys(k).map((n) => z(n, k[n], e[n]))])]);
    };
    return () => {
      const {
        className: e,
        height: n,
        width: s,
        style: r,
        header: l
      } = i, o = M(h, e), f = {
        height: typeof n == "string" ? n : n + "px",
        width: typeof s == "string" ? s : s + "px",
        ...r
      };
      return t(S, {
        componentName: "Calendar"
      }, {
        default: (y, c, d) => t("div", {
          role: "grid",
          class: o,
          key: m.itemLimit,
          style: f
        }, [t("div", {
          role: "presentation",
          class: `${h}-sticky-top`
        }, [l, A(d)]), t("div", {
          role: "presentation",
          class: `${h}-grid-wrapper`
        }, [_()])])
      });
    };
  }
});
export {
  Ie as default,
  ye as vuePropsType
};
//# sourceMappingURL=monthCalendar.js.map
