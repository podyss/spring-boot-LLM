import { defineComponent as A, useSlots as M, ref as X, onMounted as W, createVNode as c, mergeProps as Y, isVNode as G, cloneVNode as J } from "vue";
import O from "classnames";
import { cssClasses as Q, strings as U } from '@douyinfe/semi-foundation/lib/es/cascader/constants';
import Z from '@douyinfe/semi-foundation/lib/es/utils/isEnterPress';
import { includes as ee } from "lodash";
import te from "../locale/localeConsumer";
import { IconTick as ne, IconChevronRight as oe } from "@kousum/semi-icons-vue";
import se from "../spin";
import z from "../checkbox";
import { useBaseComponent as re } from "../_base/baseComponent";
import { FixedSizeList as ce } from "@kousum/vue3-window";
import x from "./virtualRow";
function ae(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !G(s);
}
const o = Q.PREFIX_OPTION, ie = {
  activeKeys: {
    type: Object,
    required: !0
  },
  selectedKeys: {
    type: Object,
    required: !0
  },
  loadedKeys: {
    type: Object,
    required: !0
  },
  loadingKeys: {
    type: Object,
    required: !0
  },
  onItemClick: {
    type: Function,
    required: !0
  },
  onItemHover: {
    type: Function,
    required: !0
  },
  showNext: {
    type: String,
    required: !0
  },
  onItemCheckboxClick: {
    type: Function,
    required: !0
  },
  onListScroll: {
    type: Function,
    required: !0
  },
  searchable: {
    type: Boolean,
    required: !0
  },
  keyword: {
    type: String,
    required: !0
  },
  virtualize: Object,
  expandIcon: [Object, String],
  emptyContent: {
    type: [Object, String],
    required: !1
  },
  loadData: {
    type: Function,
    required: !1
  },
  data: {
    type: Array,
    required: !0
  },
  separator: {
    type: String,
    required: !0
  },
  multiple: {
    type: Boolean,
    required: !0
  },
  checkedKeys: {
    type: Object,
    required: !0
  },
  halfCheckedKeys: {
    type: Object,
    required: !0
  },
  empty: {
    type: Boolean,
    default: !1
  },
  filterRender: Function,
  style: Object,
  className: String
}, $e = /* @__PURE__ */ A({
  props: {
    ...ie
  },
  name: "CascaderItem",
  setup(s, {}) {
    M();
    const {
      context: P
    } = re(s, {}), K = (e, t) => {
      const {
        onItemClick: n
      } = s;
      t.data.disabled || "disabled" in t && t.disabled || n(e, t);
    }, j = (e, t) => {
      Z(e) && K(e, t);
    }, B = (e, t) => {
      const {
        showNext: n,
        onItemHover: r
      } = s;
      t.data.disabled || n === U.SHOW_NEXT_BY_HOVER && r(e, t);
    }, w = (e, t) => {
      const {
        onItemCheckboxClick: n
      } = s;
      e.stopPropagation(), e && e.nativeEvent && typeof e.nativeEvent.stopImmediatePropagation == "function" && e.nativeEvent.stopImmediatePropagation(), e && e.stopImmediatePropagation && typeof e.stopImmediatePropagation == "function" && e.stopImmediatePropagation(), n(t);
    }, H = (e) => {
      const {
        activeKeys: t,
        selectedKeys: n,
        loadedKeys: r,
        loadingKeys: a
      } = s, i = {
        active: !1,
        selected: !1,
        loading: !1
      };
      return t.has(e) && (i.active = !0), n.has(e) && (i.selected = !0), a.has(e) && !r.has(e) && (i.loading = !0), i;
    }, $ = (e) => {
      switch (e) {
        case "child":
          const {
            expandIcon: t
          } = s;
          return t || c(oe, {
            className: `${o}-icon ${o}-icon-expand`
          }, null);
        case "tick":
          return c(ne, {
            className: `${o}-icon ${o}-icon-active`
          }, null);
        case "loading":
          return c(se, {
            wrapperClassName: `${o}-spin-icon`
          }, null);
        case "empty":
          return c("span", {
            "aria-hidden": !0,
            class: `${o}-icon ${o}-icon-empty`
          }, null);
        default:
          return null;
      }
    }, V = (e) => {
      const t = [], {
        keyword: n,
        separator: r
      } = s;
      return e.forEach((a, i) => {
        typeof a == "string" && ee(a, n) ? a.split(n).forEach((m, l) => {
          l > 0 && t.push(c("span", {
            class: `${o}-label-highlight`,
            key: `${l}-${i}`
          }, [n])), t.push(m);
        }) : t.push(a), i !== e.length - 1 && t.push(r);
      }), t;
    }, E = (e, t, n) => {
      const {
        multiple: r,
        selectedKeys: a,
        checkedKeys: i,
        halfCheckedKeys: m,
        keyword: l,
        filterRender: f,
        virtualize: k
      } = s, {
        searchText: I,
        key: u,
        disabled: g,
        pathData: b
      } = e, v = a.has(u), y = O(o, {
        [`${o}-flatten`]: !f,
        [`${o}-disabled`]: g,
        [`${o}-select`]: v && !r
      }), p = (d) => {
        K(d, e);
      }, q = (d) => j(d, e), C = (d) => w(d, e);
      if (f) {
        const d = {
          className: y,
          inputValue: l,
          disabled: g,
          data: b,
          checkStatus: {
            checked: i.has(e.key),
            halfChecked: m.has(e.key)
          },
          selected: v,
          onClick: p,
          onCheck: C
        }, S = f(d), N = k ? {
          key: u,
          style: {
            ...S.props.style ?? {},
            ...n
          }
        } : {
          key: u
        };
        return J(S, N);
      }
      return c("li", {
        role: "menuitem",
        class: y,
        style: n,
        key: u,
        onClick: p,
        onKeypress: q
      }, [c("span", {
        class: `${o}-label`
      }, [!r && $("empty"), r && c(z, {
        onChange: C,
        disabled: g,
        indeterminate: m.has(e.key),
        checked: i.has(e.key),
        className: `${o}-label-checkbox`
      }, null), V(I)])]);
    }, _ = (e) => {
      const {
        virtualize: t
      } = s;
      return c("ul", {
        class: `${o}-list`,
        key: "flatten-list"
      }, [t ? L(e) : e.map((r) => E(r))]);
    }, L = (e) => {
      const {
        direction: t
      } = P.value, {
        virtualize: n
      } = s;
      return c(ce, {
        height: parseInt("" + n.height),
        itemCount: e.length,
        itemSize: n.itemSize,
        itemData: {
          visibleOptions: e,
          renderOption: E
        },
        width: n.width ?? "100%",
        style: {
          direction: t
        }
      }, ae(x) ? x : {
        default: () => [x]
      });
    }, F = X();
    function T(e, t = []) {
      const {
        multiple: n,
        checkedKeys: r,
        halfCheckedKeys: a
      } = s;
      let i;
      const m = t.length;
      return t.push(c("ul", {
        role: "menu",
        class: `${o}-list`,
        key: e[0].key,
        onScroll: (l) => s.onListScroll(l, m)
      }, [e.map((l) => {
        const {
          data: f,
          key: k,
          parentKey: I
        } = l, {
          children: u,
          label: g,
          disabled: b,
          isLeaf: v
        } = f, {
          active: y,
          selected: p,
          loading: q
        } = H(k), C = !!u && u.length, d = C || s.loadData && !v;
        y && C && (i = l);
        const S = O(o, {
          [`${o}-active`]: y && !p,
          [`${o}-select`]: p && !n,
          [`${o}-disabled`]: b
        }), N = I ? {
          "aria-owns": `cascaderItem-${I}`
        } : {};
        return c("li", Y({
          role: "menuitem",
          id: `cascaderItem-${k}`,
          "aria-expanded": y,
          "aria-haspopup": !!d,
          "aria-disabled": b
        }, N, {
          class: S,
          key: k,
          onClick: (h) => {
            K(h, l);
          },
          onKeypress: (h) => j(h, l),
          onMouseenter: (h) => {
            B(h, l);
          }
        }), [c("span", {
          class: `${o}-label`
        }, [p && !n && $("tick"), !p && !n && $("empty"), n && c(z, {
          onChange: (h) => w(h, l),
          disabled: b,
          indeterminate: a.has(l.key),
          checked: r.has(l.key),
          className: `${o}-label-checkbox`
        }, null), c("span", null, [g])]), d ? $(q ? "loading" : "child") : null]);
      })])), i && t.concat(T(i.children, t)), t;
    }
    function R() {
      const {
        emptyContent: e
      } = s;
      return e === null ? null : c(te, {
        componentName: "Cascader"
      }, {
        default: (t) => c("ul", {
          class: `${o} ${o}-empty`,
          key: "empty-list"
        }, [c("span", {
          class: `${o}-label`
        }, [e || t.emptyText])])
      });
    }
    function D() {
      s.activeKeys.forEach((e) => {
        var r;
        let t = `cascaderItem-${e}`, n = (r = F.value) == null ? void 0 : r.querySelector("#" + t);
        if (n) {
          const a = n.parentNode;
          a.scrollTop = n.offsetTop - a.offsetTop - a.clientHeight / 2 + n.clientHeight / 2;
        }
      });
    }
    return W(() => {
      D();
    }), () => {
      const {
        data: e,
        searchable: t
      } = s, {
        direction: n
      } = P.value, r = !e || !e.length;
      let a;
      const i = O({
        [`${o}-lists`]: !0,
        [`${o}-lists-rtl`]: n === "rtl",
        [`${o}-lists-empty`]: r
      });
      return r ? a = R() : a = t ? _(e) : T(e), c("div", {
        ref: F,
        class: i
      }, [a]);
    };
  }
});
export {
  $e as default,
  ie as vuePropsType
};
//# sourceMappingURL=item.js.map
