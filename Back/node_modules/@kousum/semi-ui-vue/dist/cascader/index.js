import { createVNode as g, defineComponent as He, useSlots as _e, reactive as ze, ref as j, shallowRef as Z, nextTick as Me, watch as J, onMounted as je, onUnmounted as Ae, isVNode as Be, Fragment as k, mergeProps as A, createTextVNode as Fe } from "vue";
import * as n from "../PropTypes";
import { vuePropsMake as Ge } from "../PropTypes";
import v from "classnames";
import We from '@douyinfe/semi-foundation/lib/es/cascader/foundation';
import { cssClasses as Ue, strings as O } from '@douyinfe/semi-foundation/lib/es/cascader/constants';
import { numbers as Ye } from '@douyinfe/semi-foundation/lib/es/popover/constants';
import { noop as $, isEqual as Q, isEmpty as L, isSet as qe, isObject as Xe, isString as ee, isNumber as Ze, isFunction as Je } from "lodash";
import '@douyinfe/semi-foundation/lib/es/cascader/cascader.css';
import { IconChevronDown as Qe, IconClear as et } from "@kousum/semi-icons-vue";
import { calcMergeType as te, convertDataToEntities as tt, getKeyByValuePath as nt } from '@douyinfe/semi-foundation/lib/es/cascader/util';
import { calcCheckedKeys as ot, calcDisabledKeys as at, normalizeKeyList as lt } from '@douyinfe/semi-foundation/lib/es/tree/treeUtil';
import { useHasInProps as st, useBaseComponent as rt } from "../_base/baseComponent";
import it from "../input";
import ne from "../popover";
import ct from "./item";
import dt from "../trigger";
import ut from "../tag";
import ft from "../tagInput";
import { isSemiIcon as oe } from "../_utils/index";
function ae(o) {
  return typeof o == "function" || Object.prototype.toString.call(o) === "[object Object]" && !Be(o);
}
const d = Ue.PREFIX, gt = 0, yt = {
  "aria-labelledby": n.string,
  "aria-invalid": [n.bool, n.string],
  "aria-errormessage": n.string,
  "aria-describedby": n.string,
  "aria-required": n.bool,
  "aria-label": n.string,
  arrowIcon: n.node,
  clearIcon: n.node,
  expandIcon: n.node,
  borderless: n.bool,
  changeOnSelect: n.bool,
  defaultValue: n.oneOfType([n.string, n.array]),
  disabled: n.bool,
  dropdownClassName: n.string,
  dropdownStyle: n.object,
  emptyContent: n.node,
  motion: n.bool,
  /* show search input, if passed in a function, used as custom filter */
  filterTreeNode: n.oneOfType([n.func, n.bool]),
  filterLeafOnly: n.bool,
  placeholder: n.string,
  searchPlaceholder: n.string,
  size: String,
  style: n.object,
  className: n.string,
  treeData: [String, Number, Object, Array],
  treeNodeFilterProp: n.string,
  suffix: n.node,
  prefix: n.node,
  insetLabel: n.node,
  insetLabelId: n.string,
  id: n.string,
  displayProp: n.string,
  displayRender: n.func,
  onChange: n.func,
  onSearch: n.func,
  onSelect: n.func,
  onBlur: n.func,
  onFocus: n.func,
  children: n.node,
  getPopupContainer: n.func,
  zIndex: n.number,
  value: n.oneOfType([n.string, n.number, n.array]),
  validateStatus: n.string,
  showNext: n.string,
  stopPropagation: n.oneOfType([n.bool, n.string]),
  showClear: n.bool,
  defaultOpen: n.bool,
  autoAdjustOverflow: n.bool,
  onDropdownVisibleChange: n.func,
  triggerRender: n.func,
  onListScroll: n.func,
  onChangeWithObject: n.bool,
  bottomSlot: n.node,
  topSlot: n.node,
  multiple: n.bool,
  autoMergeValue: n.bool,
  maxTagCount: n.number,
  showRestTagsPopover: n.bool,
  restTagsPopoverProps: n.object,
  max: n.number,
  separator: n.string,
  onExceed: n.func,
  onClear: n.func,
  loadData: n.func,
  onLoad: n.func,
  loadedKeys: n.array,
  disableStrictly: n.bool,
  leafOnly: n.bool,
  enableLeafClick: n.bool,
  preventScroll: n.bool,
  position: n.string,
  searchPosition: n.string,
  autoClearSearchValue: {
    type: Boolean,
    default: !0
  },
  mouseEnterDelay: Number,
  mouseLeaveDelay: Number,
  virtualizeInSearch: Object,
  filterSorter: n.func,
  filterRender: n.func
}, ht = {
  borderless: !1,
  leafOnly: !1,
  arrowIcon: g(Qe, null, null),
  stopPropagation: !0,
  motion: !0,
  defaultOpen: !1,
  zIndex: Ye.DEFAULT_Z_INDEX,
  showClear: !1,
  autoClearSearchValue: !0,
  changeOnSelect: !1,
  disableStrictly: !1,
  autoMergeValue: !0,
  multiple: !1,
  filterTreeNode: !1,
  filterLeafOnly: !0,
  showRestTagsPopover: !1,
  restTagsPopoverProps: {},
  separator: " / ",
  size: "default",
  treeNodeFilterProp: "label",
  displayProp: "label",
  treeData: [],
  showNext: O.SHOW_NEXT_BY_CLICK,
  onExceed: $,
  onClear: $,
  onDropdownVisibleChange: $,
  onListScroll: $,
  enableLeafClick: !1,
  "aria-label": "Cascader",
  searchPosition: O.SEARCH_POSITION_TRIGGER
}, pt = Ge(yt, ht), Vt = /* @__PURE__ */ He({
  props: {
    ...pt
  },
  name: "Cascader",
  setup(o, {
    expose: le
  }) {
    _e();
    const {
      getProps: R
    } = st(), y = ze({
      disabledKeys: /* @__PURE__ */ new Set(),
      isOpen: o.defaultOpen,
      /* By changing rePosKey, the dropdown position can be refreshed */
      rePosKey: gt,
      /* A data structure for storing cascader data items */
      keyEntities: {},
      /* Selected and show tick icon */
      selectedKeys: /* @__PURE__ */ new Set([]),
      /* The key of the activated node */
      activeKeys: /* @__PURE__ */ new Set([]),
      /* The key of the filtered node */
      filteredKeys: /* @__PURE__ */ new Set([]),
      /* Value of input box */
      inputValue: "",
      /* Is searching */
      isSearching: !1,
      /* The placeholder of input box */
      inputPlaceHolder: o.searchPlaceholder || o.placeholder,
      /* Cache props */
      prevProps: {},
      /* Is hovering */
      isHovering: !1,
      /* Key of checked node, when multiple */
      checkedKeys: /* @__PURE__ */ new Set([]),
      /* Key of half checked node, when multiple */
      halfCheckedKeys: /* @__PURE__ */ new Set([]),
      /* Auto merged checkedKeys or leaf checkedKeys, when multiple */
      resolvedCheckedKeys: /* @__PURE__ */ new Set([]),
      /* Keys of loaded item */
      loadedKeys: /* @__PURE__ */ new Set(),
      /* Keys of loading item */
      loadingKeys: /* @__PURE__ */ new Set(),
      /* Mark whether this rendering has triggered asynchronous loading of data */
      loading: !1,
      isFocus: void 0,
      isInput: void 0
    }), V = te(o.autoMergeValue, o.leafOnly), E = j(null), B = j(null), F = j(null);
    let H = null;
    const G = Z(), W = Z(), {
      adapter: se,
      context: re,
      getDataAttr: ie
    } = rt(o, y), h = new We(ce());
    function ce() {
      const t = {
        updateInputValue: (e) => {
          y.inputValue = e;
        },
        updateInputPlaceHolder: (e) => {
          y.inputPlaceHolder = e;
        },
        focusInput: () => {
          const {
            preventScroll: e
          } = o;
          E.value && E.value.focus({
            preventScroll: e
          });
        },
        blurInput: () => {
          E.value && E.value.blur();
        }
      }, a = {
        registerClickOutsideHandler: (e) => {
          H = (s) => {
            var p;
            const r = F.value, f = B.value, i = (p = r == null ? void 0 : r.getRef) == null ? void 0 : p.call(r).vnode.el, c = s.target, u = s.composedPath && s.composedPath() || [c];
            i && (!i.contains(c) || !i.contains(c.parentNode)) && f && !f.contains(c) && !(u.includes(f) || u.includes(i)) && e(s);
          }, document.addEventListener("mousedown", H, !1);
        },
        unregisterClickOutsideHandler: () => {
          document.removeEventListener("mousedown", H, !1);
        },
        rePositionDropdown: () => {
          let {
            rePosKey: e
          } = y;
          e = e + 1, y.rePosKey = e;
        }
      };
      return {
        ...se(),
        ...t,
        ...a,
        updateStates: (e) => {
          for (let l in e)
            y[l] = e[l];
        },
        openMenu: () => {
          y.isOpen = !0;
        },
        closeMenu: (e) => {
          y.isOpen = !1, e && e();
        },
        updateSelection: (e) => {
          y.selectedKeys = e;
        },
        notifyChange: (e) => {
          o.onChange && o.onChange(e);
        },
        notifySelect: (e) => {
          o.onSelect && o.onSelect(e);
        },
        notifyOnSearch: (e) => {
          o.onSearch && o.onSearch(e);
        },
        notifyFocus: (...e) => {
          o.onFocus && o.onFocus(...e);
        },
        notifyBlur: (...e) => {
          o.onBlur && o.onBlur(...e);
        },
        notifyDropdownVisibleChange: (e) => {
          o.onDropdownVisibleChange(e);
        },
        toggleHovering: (e) => {
          y.isHovering = e;
        },
        notifyLoadData: (e, l) => {
          const {
            loadData: s
          } = o;
          s && new Promise((r) => {
            s(e).then(() => {
              setTimeout(() => {
                l(), y.loading = !0, r();
              });
            });
          });
        },
        notifyOnLoad: (e, l) => {
          const {
            onLoad: s
          } = o;
          s && s(e, l);
        },
        notifyListScroll: (e, {
          panelIndex: l,
          activeNode: s
        }) => {
          o.onListScroll(e, {
            panelIndex: l,
            activeNode: s
          });
        },
        notifyOnExceed: (e) => o.onExceed(e),
        notifyClear: () => o.onClear(),
        toggleInputShow: (e, l) => {
          y.showInput = e, Me(() => {
            l();
          });
        },
        updateFocusState: (e) => {
          y.isFocus = e;
        },
        updateLoadingKeyRefValue: (e) => {
          G.value = e;
        },
        getLoadingKeyRefValue: () => G.value,
        updateLoadedKeyRefValue: (e) => {
          W.value = e;
        },
        getLoadedKeyRefValue: () => W.value
      };
    }
    function de(t) {
      const {
        multiple: a,
        value: e,
        defaultValue: l,
        onChangeWithObject: s,
        leafOnly: r,
        autoMergeValue: f
      } = t, {
        prevProps: i
      } = y;
      let c = y.keyEntities || {};
      const u = {}, p = (m) => {
        const w = L(i) && m in t, C = i && !Q(i[m], t[m]);
        return w || C;
      }, P = () => {
        const m = !i && "treeData" in t, w = i && i.treeData !== t.treeData;
        return m || w;
      }, b = (m, w) => {
        let C = [];
        Array.isArray(m) ? C = Array.isArray(m[0]) ? m : [m] : m !== void 0 && (C = [[m]]);
        const x = [];
        return C.forEach((K) => {
          const T = s && Xe(K[0]) ? K.map((S) => S == null ? void 0 : S.value) : K;
          T.length > 0 && x.push(T);
        }), x.reduce((K, T) => {
          const S = nt(T);
          return w[S] && K.push(S), K;
        }, []);
      };
      if (a) {
        const m = p("treeData") || P(), w = p("value") || L(i) && l;
        if (m || w) {
          m && (u.treeData = t.treeData, c = tt(t.treeData), u.keyEntities = c);
          let C = y.checkedKeys;
          if (w) {
            const S = p("value") ? e : l;
            C = b(S, c);
          } else
            m && "value" in R(t) && (C = b(e, c));
          qe(C) && (C = [...C]);
          const x = ot(C, c), I = new Set(x.checkedKeys), K = new Set(x.halfCheckedKeys);
          t.disableStrictly && (u.disabledKeys = at(c));
          const T = te(f, r) === O.LEAF_ONLY_MERGE_TYPE;
          u.prevProps = t, u.checkedKeys = I, u.halfCheckedKeys = K, u.resolvedCheckedKeys = new Set(lt(I, c, T));
        }
      }
      return u;
    }
    J([() => o.multiple, () => o.value, () => o.defaultValue, () => o.onChangeWithObject, () => o.leafOnly, () => o.autoMergeValue, () => o.treeData, () => o.disableStrictly], (t) => {
      const a = de({
        ...R(o)
      });
      a && Object.keys(a).forEach((e) => {
        y[e] = a[e];
      });
    }, {
      immediate: !0
    }), je(() => {
      h.init();
    }), Ae(() => {
      h.destroy();
    }), J([() => o.treeData, () => o.value, () => o.multiple], (t, [a, e]) => {
      if (o.multiple)
        return;
      let l = !1;
      Q(a, o.treeData) || (l = !0, h.collectOptions()), e !== o.value && !l && h.handleValueChange(o.value);
    });
    const D = (t) => {
      h.handleInputChange(t);
    }, ue = (t) => {
      h.handleTagRemoveInTrigger(t);
    }, fe = (t, a, e) => {
      a.preventDefault(), h.handleTagRemoveByKey("" + e);
    }, U = (t, a) => {
      const {
        keyEntities: e,
        disabledKeys: l
      } = y, {
        size: s,
        disabled: r,
        displayProp: f,
        displayRender: i,
        disableStrictly: c
      } = o;
      if (e[t]) {
        const u = r || e[t].data.disabled || c && l.has(t), p = v(`${d}-selection-tag`, {
          [`${d}-selection-tag-disabled`]: u
        });
        return Je(i) ? i(e[t], a) : g(ut, {
          size: s === "default" ? "large" : s,
          key: `tag-${t}-${a}`,
          color: "white",
          tagKey: t,
          className: p,
          closable: !0,
          onClose: fe
        }, {
          default: () => [e[t].data[f]]
        });
      }
      return null;
    }, ge = (t) => {
      h.handleTagRemoveByKey(t);
    };
    function ye() {
      const {
        size: t,
        disabled: a,
        placeholder: e,
        maxTagCount: l,
        showRestTagsPopover: s,
        restTagsPopoverProps: r
      } = o, {
        inputValue: f,
        checkedKeys: i,
        keyEntities: c,
        resolvedCheckedKeys: u
      } = y, p = v(`${d}-tagInput-wrapper`), P = V === O.NONE_MERGE_TYPE ? i : u;
      return g(ft, {
        className: p,
        ref: E,
        disabled: a,
        size: t,
        value: [...P],
        showRestTagsPopover: s,
        restTagsPopoverProps: r,
        maxTagCount: l,
        renderTagItem: U,
        inputValue: f,
        onInputChange: D,
        onRemove: ge,
        placeholder: e,
        expandRestTagsOnClick: !1
      }, null);
    }
    function he() {
      const {
        size: t,
        disabled: a
      } = o, e = v(`${d}-input`), {
        inputValue: l,
        inputPlaceHolder: s,
        showInput: r
      } = y, f = {
        disabled: a,
        value: l,
        className: e,
        onChange: D
      }, i = v({
        [`${d}-search-wrapper`]: !0,
        [`${d}-search-wrapper-${t}`]: t !== "default"
      }), c = Y(), u = v({
        [`${d}-selection-placeholder`]: !c,
        [`${d}-selection-text-hide`]: r && l,
        [`${d}-selection-text-inactive`]: r && !l
      });
      return g("div", {
        class: i
      }, [g("span", {
        class: u
      }, [c || s]), r && g(it, A({
        forwardRef: E,
        size: t
      }, f), null)]);
    }
    const pe = (t, a) => {
      h.handleItemClick(t, a);
    }, me = (t, a) => {
      h.handleItemHover(t, a);
    }, be = (t) => {
      h.onItemCheckboxClick(t);
    }, Ce = (t, a) => {
      h.handleListScroll(t, a);
    };
    function ve(t) {
      h.close(t);
    }
    function Pe() {
      h.open();
    }
    function Se() {
      h.focus();
    }
    function we() {
      h.blur();
    }
    le({
      focus: Se,
      blur: we,
      close: ve,
      open: Pe
    });
    const Ke = () => {
      const {
        inputValue: t,
        isSearching: a,
        activeKeys: e,
        selectedKeys: l,
        checkedKeys: s,
        halfCheckedKeys: r,
        loadedKeys: f,
        loadingKeys: i
      } = y, {
        filterTreeNode: c,
        dropdownClassName: u,
        dropdownStyle: p,
        loadData: P,
        emptyContent: b,
        separator: m,
        topSlot: w,
        bottomSlot: C,
        showNext: x,
        multiple: I,
        filterRender: K,
        virtualizeInSearch: T,
        expandIcon: S
      } = R(o), _ = !!c && a, z = v(u, `${d}-popover`), M = h.getRenderData();
      return g("div", {
        class: z,
        role: "listbox",
        style: p,
        onKeydown: h.handleKeyDown
      }, [w, g(ct, {
        activeKeys: e,
        selectedKeys: l,
        separator: m,
        loadedKeys: f,
        loadingKeys: i,
        onItemClick: pe,
        onItemHover: me,
        showNext: x,
        onItemCheckboxClick: be,
        onListScroll: Ce,
        searchable: _,
        keyword: t,
        emptyContent: b,
        loadData: P,
        data: M,
        multiple: I,
        checkedKeys: s,
        halfCheckedKeys: r,
        filterRender: K,
        virtualize: T,
        expandIcon: S
      }, null), C]);
    }, Te = (t) => {
      const {
        disabled: a,
        showRestTagsPopover: e,
        restTagsPopoverProps: l
      } = o, s = v(`${d}-selection-n`, {
        [`${d}-selection-n-disabled`]: a
      }), r = g("span", {
        class: s
      }, [Fe("+"), t.length]);
      return e ? g(ne, A({
        content: t,
        showArrow: !0,
        trigger: "hover",
        position: "top",
        autoAdjustOverflow: !0
      }, l), ae(r) ? r : {
        default: () => [r]
      }) : r;
    }, xe = () => {
      const {
        autoMergeValue: t,
        maxTagCount: a
      } = o, {
        checkedKeys: e,
        resolvedCheckedKeys: l
      } = y, s = V === O.NONE_MERGE_TYPE ? e : l, r = [], f = [];
      return [...s].forEach((i, c) => {
        const u = !Ze(a) || a >= c + 1, p = U(i, c);
        u ? r.push(p) : f.push(p);
      }), g(k, null, [r, !L(f) && Te(f)]);
    }, Y = () => {
      const {
        displayProp: t,
        separator: a,
        displayRender: e
      } = o, {
        selectedKeys: l
      } = y;
      let s = "";
      if (l.size) {
        const r = h.getItemPropPath([...l][0], t);
        e && typeof e == "function" ? s = e(r) : s = r.map((f, i) => g(k, {
          key: `${f}-${i}`
        }, [i < r.length - 1 ? g(k, null, [f, a]) : f]));
      }
      return s;
    }, ke = () => {
      const {
        placeholder: t,
        filterTreeNode: a,
        multiple: e,
        searchPosition: l
      } = o, {
        checkedKeys: s
      } = y;
      if (!(!!a && l === O.SEARCH_POSITION_TRIGGER)) {
        if (e)
          return s.size === 0 ? g("span", {
            class: `${d}-selection-placeholder`
          }, [t]) : xe();
        {
          const i = Y(), c = v({
            [`${d}-selection-placeholder`]: !i
          });
          return g("span", {
            class: c
          }, [i || t]);
        }
      }
      return e ? ye() : he();
    }, Ie = () => {
      const {
        suffix: t
      } = o, a = v({
        [`${d}-suffix`]: !0,
        [`${d}-suffix-text`]: t && ee(t),
        [`${d}-suffix-icon`]: oe(t)
      });
      return g("div", {
        class: a,
        "x-semi-prop": "suffix"
      }, [t]);
    }, Oe = () => {
      const {
        prefix: t,
        insetLabel: a,
        insetLabelId: e
      } = o, l = t || a, s = v({
        [`${d}-prefix`]: !0,
        // to be doublechecked
        [`${d}-inset-label`]: a,
        [`${d}-prefix-text`]: l && ee(l),
        [`${d}-prefix-icon`]: oe(l)
      });
      return g("div", {
        class: s,
        id: e,
        "x-semi-prop": "prefix,insetLabel"
      }, [l]);
    }, Ee = () => {
      var p;
      const {
        disabled: t,
        triggerRender: a,
        multiple: e
      } = o, {
        selectedKeys: l,
        inputValue: s,
        inputPlaceHolder: r,
        resolvedCheckedKeys: f,
        checkedKeys: i,
        keyEntities: c
      } = y;
      let u;
      return e ? V === O.NONE_MERGE_TYPE ? (u = /* @__PURE__ */ new Set(), i.forEach((P) => {
        var b;
        u.add((b = c[P]) == null ? void 0 : b.pos);
      })) : (u = /* @__PURE__ */ new Set(), f.forEach((P) => {
        var b;
        u.add((b = c[P]) == null ? void 0 : b.pos);
      })) : u = (p = c[[...l][0]]) == null ? void 0 : p.pos, g(dt, {
        value: u,
        inputValue: s,
        onChange: D,
        onClear: q,
        placeholder: r,
        disabled: t,
        triggerRender: a,
        componentName: "Cascader",
        componentProps: {
          ...R(o)
        },
        onSearch: D,
        onRemove: ue
      }, null);
    }, Re = () => {
      h.toggleHoverState(!0);
    }, De = () => {
      h.toggleHoverState(!1);
    }, q = (t) => {
      t && t.stopPropagation(), h.handleClear();
    }, Ne = (t) => {
      t && t.stopPropagation(), h.handleClearEnterPress(t);
    }, X = () => {
      const {
        showClear: t,
        disabled: a,
        multiple: e
      } = o, {
        selectedKeys: l,
        isOpen: s,
        isHovering: r,
        checkedKeys: f,
        inputValue: i
      } = y, c = l.size, u = e && f.size;
      return t && (i || c || u) && !a && (s || r);
    }, $e = () => {
      const t = v(`${d}-clearbtn`);
      return X() ? g("div", {
        class: t,
        onClick: q,
        onKeypress: Ne,
        role: "button",
        tabindex: 0
      }, [g(et, null, null)]) : null;
    }, Le = () => {
      const {
        arrowIcon: t
      } = o;
      return X() ? null : t ? g("div", {
        class: v(`${d}-arrow`),
        "x-semi-prop": "arrowIcon"
      }, [t]) : null;
    }, Ve = () => {
      const {
        disabled: t,
        multiple: a,
        filterTreeNode: e,
        style: l,
        size: s,
        className: r,
        validateStatus: f,
        prefix: i,
        suffix: c,
        insetLabel: u,
        triggerRender: p,
        showClear: P,
        id: b,
        borderless: m
      } = o, {
        isOpen: w,
        isFocus: C,
        isInput: x,
        checkedKeys: I
      } = y, K = !!e, T = typeof p == "function", S = T ? v(r) : v(d, r, {
        [`${d}-borderless`]: m,
        [`${d}-focus`]: C || w && !x,
        [`${d}-disabled`]: t,
        [`${d}-single`]: !0,
        [`${d}-filterable`]: K,
        [`${d}-error`]: f === "error",
        [`${d}-warning`]: f === "warning",
        [`${d}-small`]: s === "small",
        [`${d}-large`]: s === "large",
        [`${d}-with-prefix`]: i || u,
        [`${d}-with-suffix`]: c
      }), _ = P ? {
        onMouseEnter: () => Re(),
        onMouseLeave: () => De()
      } : {}, z = v(`${d}-selection`, {
        [`${d}-selection-multiple`]: a && !L(I)
      }), M = T ? Ee() : [g(k, {
        key: "prefix"
      }, [i || u ? Oe() : null]), g(k, {
        key: "selection"
      }, [g("div", {
        class: z
      }, [ke()])]), g(k, {
        key: "suffix"
      }, [c ? Ie() : null]), g(k, {
        key: "clearbtn"
      }, [$e()]), g(k, {
        key: "arrow"
      }, [Le()])];
      return g("div", A({
        class: S,
        style: l,
        ref: B,
        onClick: (N) => h.handleClick(N),
        onKeypress: (N) => h.handleSelectionEnterPress(N),
        "aria-invalid": o["aria-invalid"],
        "aria-errormessage": o["aria-errormessage"],
        "aria-label": o["aria-label"],
        "aria-labelledby": o["aria-labelledby"],
        "aria-describedby": o["aria-describedby"],
        "aria-required": o["aria-required"],
        id: b
      }, _, {
        role: "combobox",
        tabindex: 0
      }, ie()), [M]);
    };
    return () => {
      const {
        zIndex: t,
        getPopupContainer: a,
        autoAdjustOverflow: e,
        stopPropagation: l,
        mouseLeaveDelay: s,
        mouseEnterDelay: r,
        position: f,
        motion: i
      } = o, {
        isOpen: c,
        rePosKey: u
      } = y, {
        direction: p
      } = re.value, P = Ke(), b = Ve();
      return g(ne, {
        getPopupContainer: a,
        zIndex: t,
        motion: i,
        ref: F,
        content: P,
        visible: c,
        trigger: "custom",
        rePosKey: u,
        position: p === "rtl" ? "bottomRight" : "bottomLeft",
        autoAdjustOverflow: e,
        stopPropagation: l,
        mouseLeaveDelay: s,
        mouseEnterDelay: r,
        afterClose: () => h.updateSearching(!1)
      }, ae(b) ? b : {
        default: () => [b]
      });
    };
  }
});
export {
  Vt as default,
  pt as vuePropsType
};
//# sourceMappingURL=index.js.map
