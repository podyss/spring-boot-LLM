import { defineComponent as me, useSlots as ye, ref as R, reactive as ge, onMounted as be, watch as W, onUnmounted as he, nextTick as H, createVNode as d, isVNode as xe, mergeProps as z, Fragment as A, cloneVNode as we, h as Se } from "vue";
import N from "classnames";
import { cssClasses as ve } from '@douyinfe/semi-foundation/lib/es/typography/constants';
import Ce from "./typography";
import Te from "./copyable";
import { isNull as Oe, isUndefined as P, isFunction as $e, merge as ke, omit as je, isString as Ee } from "lodash";
import Ne from "../tooltip";
import Pe from "../popover";
import Re from "./util";
import M from '@douyinfe/semi-foundation/lib/es/utils/warning';
import ze from '@douyinfe/semi-foundation/lib/es/utils/isEnterPress';
import Ae from "../locale/localeConsumer";
import { runAfterTicks as _e, isSemiIcon as Be } from "../_utils";
import Fe, { ObserverProperty as Ue } from "../resizeObserver";
import Ie from "./context";
import * as i from "../PropTypes";
import { vuePropsMake as Le } from "../PropTypes";
import { useTypographyBaseSizeContext as We } from "./context/Consumer";
function _(l) {
  return typeof l == "function" || Object.prototype.toString.call(l) === "[object Object]" && !xe(l);
}
const a = ve.PREFIX, He = "...", Me = {
  copyable: i.oneOfType([i.object(), i.bool]),
  delete: i.bool,
  disabled: i.bool,
  // editable: PropTypes.bool,
  ellipsis: i.oneOfType([i.object, i.bool]),
  mark: i.bool,
  underline: i.bool,
  link: [i.object, i.bool, i.string],
  spacing: i.string,
  strong: i.bool,
  size: i.string,
  type: i.string,
  style: i.object,
  className: i.string,
  icon: i.oneOfType([i.node, i.string]),
  heading: i.string,
  component: i.string,
  weight: [i.string, i.number],
  children: [Object, Array, Function, String],
  class: {
    type: String,
    default: ""
  },
  id: {
    type: String,
    default: ""
  },
  "x-semi-prop": {
    type: String,
    default: ""
  },
  code: Boolean,
  component_: [String, Array, Boolean, Object, Number]
}, Ve = {
  copyable: !1,
  delete: !1,
  disabled: !1,
  // editable: false,
  ellipsis: !1,
  icon: "",
  mark: !1,
  underline: !1,
  strong: !1,
  link: !1,
  type: "primary",
  spacing: "normal",
  size: "normal",
  style: {},
  className: ""
}, De = Le(Me, Ve), qe = (l, T) => {
  const {
    mark: y,
    code: j,
    underline: O,
    strong: x,
    link: $,
    disabled: E
  } = l;
  let v = T;
  const r = (k, C) => {
    let w = {};
    k && (typeof k == "object" && (w = {
      ...k
    }), v = Se(C, w, v));
  };
  return r(y, "mark"), r(j, "code"), r(O && !$, "u"), r(x, "strong"), r(l.delete, "del"), r($, E ? "span" : "a"), v;
}, pt = /* @__PURE__ */ me({
  props: {
    ...De
  },
  name: "Base",
  setup(l, {}) {
    ye();
    const {
      context: T
    } = We(), y = R(null), j = R(null), O = R(null);
    let x, $, E, v = !1;
    const r = ge({
      editable: !1,
      copied: !1,
      // ellipsis
      // if text is overflow in container
      isOverflowed: !1,
      ellipsisContent: l.children,
      expanded: !1,
      // if text is truncated with js
      isTruncated: !1,
      prevChildren: null
    });
    be(() => {
      l.ellipsis && C().then(() => _e(() => v = !0, 1));
    });
    function k(e, o) {
      const {
        prevChildren: n
      } = o, t = {}, s = e.children;
      return t.prevChildren = s, e.ellipsis && n !== s && (t.isOverflowed = !1, t.ellipsisContent = e.children, t.expanded = !1, t.isTruncated = !1), t;
    }
    W(() => l.ellipsis, (e) => {
      const o = k({
        ...l
      }, {
        ...r
      });
      o && Object.keys(o).forEach((n) => {
        r[n] = o[n];
      });
    }), W(() => l.children, () => {
      l.ellipsis && C();
    }), he(() => {
      x && window.cancelAnimationFrame(x);
    });
    const C = async (e) => (x && window.cancelAnimationFrame(x), new Promise((o) => {
      x = window.requestAnimationFrame(async () => {
        await K(), o();
      });
    }));
    function w() {
      const {
        copyable: e
      } = l, {
        expandable: o,
        expandText: n,
        pos: t,
        suffix: s
      } = b();
      return !o && P(n) && !e && t === "end" && !s.length;
    }
    const V = (e) => !e || e < 1 ? !1 : e <= 1 ? D() : y.value.scrollHeight > y.value.offsetHeight;
    function D() {
      if (!(document && document.createRange))
        return !1;
      const e = y.value, o = e == null ? void 0 : e.getBoundingClientRect().width, n = Array.from((e == null ? void 0 : e.childNodes) || []), t = document.createRange(), s = n.reduce((c, p) => (t.selectNodeContents(p), c + (t.getBoundingClientRect().width ?? 0)), 0);
      return t.detach(), s > o;
    }
    const q = () => {
      var S, h;
      const {
        isOverflowed: e,
        isTruncated: o,
        expanded: n
      } = r, {
        showTooltip: t,
        expandable: s,
        expandText: c
      } = b(), p = w(), m = !n && (p ? e : o), f = !s && P(c) && m && t;
      if (!f)
        return f;
      const u = {
        type: "tooltip"
      };
      return typeof t == "object" ? t.type && t.type.toLowerCase() === "popover" ? ke({
        opts: {
          // style: {width: '240px'},
          showArrow: !0
        }
      }, t, {
        opts: {
          className: N({
            [`${a}-ellipsis-popover`]: !0,
            [(S = t == null ? void 0 : t.opts) == null ? void 0 : S.className]: !!((h = t == null ? void 0 : t.opts) != null && h.className)
          })
        }
      }) : {
        ...u,
        ...t
      } : u;
    }, B = () => {
      if (w()) {
        const {
          rows: o,
          suffix: n,
          pos: t
        } = b(), s = V(o);
        r.isOverflowed = s, r.isTruncated = !1;
        return;
      }
    };
    function K() {
      const {
        rows: e,
        suffix: o,
        pos: n
      } = b(), {
        strong: t
      } = l, s = l.children[0].children;
      if (!y || !y.value)
        return C(), !1;
      const {
        expanded: c
      } = r;
      if (w())
        return;
      if (Oe(s))
        return new Promise((u) => {
          r.isOverflowed = !1, r.isTruncated = !1, H(() => {
            u();
          });
        });
      if (M("children" in l && typeof s != "string", "[Semi Typography] Only children with pure text could be used with ellipsis at this moment."), !e || e < 0 || c)
        return;
      const m = {
        expand: j.value,
        copy: O && O.value
      }, g = Array.isArray(s) ? s.join("") : String(s), f = Re(
        y.value,
        e,
        // Perform type conversion on children to prevent component crash due to non-string type of children
        g,
        m,
        He,
        o,
        n,
        t
      );
      return new Promise((u) => {
        r.isOverflowed = !1, r.ellipsisContent = f, r.isTruncated = g !== f, H(() => {
          u();
        });
      });
    }
    const F = (e) => {
      const {
        onExpand: o,
        expandable: n,
        collapsible: t
      } = b(), {
        expanded: s
      } = r;
      o && o(!s, e), (n && !s || t && s) && (r.expanded = !s);
    }, b = () => {
      const {
        ellipsis: e
      } = l;
      return e ? {
        rows: 1,
        expandable: !1,
        pos: "end",
        suffix: "",
        showTooltip: !1,
        collapsible: !1,
        expandText: e.expandable ? $ : void 0,
        collapseText: e.collapsible ? E : void 0,
        ...typeof e == "object" ? e : null
      } : {};
    }, X = () => {
      const {
        expanded: e,
        isTruncated: o
      } = r;
      if (!o) return null;
      const {
        expandText: n,
        expandable: t,
        collapseText: s,
        collapsible: c
      } = b(), p = !t && P(n), m = !c && P(s);
      let g;
      return !e && !p ? g = n : e && !m && (g = s), !p || !m ? (
        // TODO: replace `a` tag with `span` in next major version
        // NOTE: may have effect on style
        // eslint-disable-next-line jsx-a11y/anchor-is-valid
        d("a", {
          role: "button",
          tabindex: 0,
          class: `${a}-ellipsis-expand`,
          key: "expand",
          ref: j,
          "aria-label": g,
          onClick: F,
          onKeypress: (f) => ze(f) && F(f)
        }, [g])
      ) : null;
    }, G = () => {
      const {
        ellipsis: e,
        component_: o
      } = l;
      if (!e)
        return {
          ellipsisCls: "",
          ellipsisStyle: {}
          // ellipsisAttr: {}
        };
      const {
        rows: n
      } = b(), {
        expanded: t,
        isTruncated: s
      } = r, c = !t && w(), p = N({
        [`${a}-ellipsis`]: !0,
        [`${a}-ellipsis-single-line`]: n === 1,
        [`${a}-ellipsis-multiple-line`]: n > 1,
        // component === 'span', Text component, It should be externally displayed inline
        [`${a}-ellipsis-multiple-line-text`]: n > 1 && o === "span",
        [`${a}-ellipsis-overflow-ellipsis`]: n === 1 && c,
        // component === 'span', Text component, It should be externally displayed inline
        [`${a}-ellipsis-overflow-ellipsis-text`]: n === 1 && c && o === "span"
      }), m = c && n > 1 ? {
        WebkitLineClamp: n
      } : {};
      return {
        ellipsisCls: p,
        ellipsisStyle: m
      };
    }, J = (e) => {
      const {
        suffix: o
      } = e, n = l.children, {
        isTruncated: t,
        expanded: s,
        isOverflowed: c,
        ellipsisContent: p
      } = r;
      return s || !t ? d("span", {
        onMouseenter: B
      }, [n, o && o.length ? o : null]) : d("span", {
        onMouseenter: B
      }, [p, o]);
    };
    function Q() {
      return d(A, null, [X(), Y()]);
    }
    function Y() {
      const {
        copyable: e
      } = l, o = l.children;
      if (!e)
        return null;
      const n = (e == null ? void 0 : e.content) ?? o;
      let t, s = !1;
      Array.isArray(n) ? (t = "", n.forEach((p) => {
        typeof p.children == "object" && p.type.toString() !== "Symbol(v-txt)" && (s = !0), t += String(p.children);
      })) : (typeof n != "object" || (s = !0), t = String(n)), M(s, "Content to be copied in Typography is a object, it will case a [object Object] mistake when copy to clipboard.");
      const c = {
        content: t,
        duration: 3,
        ...typeof e == "object" ? e : null
      };
      return d(Te, z(c, {
        forwardRef: O
      }), null);
    }
    function Z() {
      const {
        icon: e,
        size: o
      } = l, n = o === "inherit" ? T.value : o;
      if (!e)
        return null;
      const t = n === "small" ? "small" : "default";
      return d("span", {
        class: `${a}-icon`,
        "x-semi-prop": "icon"
      }, [Be(e) ? we(e, {
        size: t
      }) : e]);
    }
    function ee() {
      const {
        component_: e,
        component: o,
        className: n,
        type: t,
        spacing: s,
        disabled: c,
        style: p,
        ellipsis: m,
        icon: g,
        size: f,
        link: u,
        heading: S,
        weight: h,
        ...ne
      } = l, oe = l.children, se = je(ne, [
        "strong",
        "editable",
        "mark",
        "copyable",
        "underline",
        "code",
        // 'link',
        "delete",
        "children"
      ]), U = f === "inherit" ? T.value : f, le = Z(), ie = b(), {
        ellipsisCls: re,
        ellipsisStyle: ce
      } = G();
      let I = m ? J(ie) : oe;
      const ae = N({
        [`${a}-link-text`]: u,
        [`${a}-link-underline`]: l.underline && u
      });
      let pe = qe(l, d(A, null, [le, l.link ? d("span", {
        class: ae
      }, [I]) : I]));
      const de = /^h[1-6]$/, L = Ee(S) && de.test(S), fe = N(n, re, {
        // [`${prefixCls}-primary`]: !type || type === 'primary',
        [`${a}-${t}`]: t && !u,
        [`${a}-${U}`]: U,
        [`${a}-link`]: u,
        [`${a}-disabled`]: c,
        [`${a}-${s}`]: s,
        [`${a}-${S}`]: L,
        [`${a}-${S}-weight-${h}`]: L && h && isNaN(Number(h))
      }), ue = {
        ...isNaN(Number(h)) ? {} : {
          fontWeight: h
        },
        ...p
      };
      return d(Ce, {
        className: fe,
        style: {
          ...ue,
          ...ce
        },
        component_: e,
        forwardRef: y,
        ...se
      }, {
        default: () => d(A, null, [pe, Q()])
      });
    }
    function te() {
      const e = l.children, o = q(), n = ee();
      if (o) {
        const {
          type: t,
          opts: s,
          renderTooltip: c
        } = o;
        return $e(c) ? c(e, n) : t.toLowerCase() === "popover" ? d(Pe, z({
          content: e ? e[0] : null,
          position: "top"
        }, s), _(n) ? n : {
          default: () => [n]
        }) : d(Ne, z({
          content: e ? e[0] : null,
          position: "top"
        }, s), _(n) ? n : {
          default: () => [n]
        });
      } else
        return n;
    }
    return () => {
      const {
        size: e
      } = l, o = e === "inherit" ? T.value : e, n = d(Ie.Provider, {
        value: o
      }, {
        default: () => [d(Ae, {
          componentName: "Typography"
        }, {
          default: (t) => ($ = t.expand, E = t.collapse, te())
        })]
      });
      return l.ellipsis ? d(Fe, {
        onResize: (...t) => {
          v && C(...t);
        },
        observeParent: !0,
        observerProperty: Ue.Width
      }, _(n) ? n : {
        default: () => [n]
      }) : n;
    };
  }
});
export {
  pt as default,
  De as vuePropsType
};
//# sourceMappingURL=base.js.map
