{"version":3,"file":"util.js","sources":["../../src/components/typography/util.tsx"],"sourcesContent":["import {defineComponent, ref, h, Fragment, createApp, type App} from 'vue'\nimport {omit} from \"lodash\";\n\n\n/**\n * The logic of JS for text truncation is referenced from antd typography\n * https://github.com/ant-design/ant-design/blob/master/components/typography/util.tsx\n *\n * For more thinking and analysis about this function, please refer to Feishu document\n * https://bytedance.feishu.cn/docs/doccnqovjjyoKm2U5O13bj30aTh\n */\n\nlet ellipsisContainer: HTMLElement;\nlet ellipsisApp: App;\nfunction pxToNumber(value: string) {\n  if (!value) {\n    return 0;\n  }\n  const match = value.match(/^\\d*(\\.\\d*)?/);\n  return match ? Number(match[0]) : 0;\n}\n\nfunction styleToString(style: CSSStyleDeclaration): string {\n  // There are some different behavior between Firefox & Chrome.\n  // We have to handle this ourself.\n  const styleNames = Array.prototype.slice.apply(style);\n  return styleNames.map((name: string) => `${name}: ${style.getPropertyValue(name)};`).join('');\n}\n\nconst EmptyComp = defineComponent(()=>{\n  return ()=>{\n    return <></>\n  }\n})\nconst getRenderText = (\n  originEle: HTMLElement,\n  rows: number,\n  content = '',\n  fixedContent: {\n    expand: Node;\n    copy: Node\n  },\n  ellipsisStr: string,\n  suffix: string,\n  ellipsisPos: string,\n  isStrong: boolean,\n  // eslint-disable-next-line max-params\n) => {\n\n  if (content.length === 0) {\n    return '';\n  }\n  if (!ellipsisContainer) {\n    ellipsisContainer = document.createElement('div');\n    ellipsisContainer.setAttribute('aria-hidden', 'true');\n    document.body.appendChild(ellipsisContainer);\n  }\n\n  // Get origin style\n  const originStyle = window.getComputedStyle(originEle);\n  const originCSS = styleToString(originStyle);\n  const lineHeight = pxToNumber(originStyle.lineHeight);\n  const maxHeight = Math.round(\n    lineHeight * (rows + 1) +\n    pxToNumber(originStyle.paddingTop) +\n    pxToNumber(originStyle.paddingBottom)\n  );\n\n  // Set shadow\n  ellipsisContainer.setAttribute('style', originCSS);\n  ellipsisContainer.style.position = 'fixed';\n  ellipsisContainer.style.left = '0';\n  ellipsisContainer.style.height = 'auto';\n  ellipsisContainer.style.top = '-999999px';\n  ellipsisContainer.style.zIndex = '-1000';\n  isStrong && (ellipsisContainer.style.fontWeight = '600');\n\n  // clean up css overflow\n  ellipsisContainer.style.textOverflow = 'clip';\n  ellipsisContainer.style.webkitLineClamp = 'none';\n  // Render fake container\n  if (ellipsisApp){\n    ellipsisApp.unmount()\n  }\n  ellipsisApp = createApp(\n    ()=>h('div'),\n  )\n  ellipsisApp.mount(ellipsisContainer);\n\n  // Check if ellipsis in measure div is enough for content\n  function inRange() {\n    // If content does not wrap due to line break strategy, width should be judged to determine whether it's in range\n    const widthInRange = ellipsisContainer.scrollWidth <= ellipsisContainer.offsetWidth;\n    const heightInRange = ellipsisContainer.scrollHeight < maxHeight;\n\n    return rows === 1 ? widthInRange && heightInRange : heightInRange;\n  }\n\n  // ========================= Find match ellipsis content =========================\n  // Create origin content holder\n  const ellipsisContentHolder = document.createElement('span');\n  const textNode = document.createTextNode(content);\n  ellipsisContentHolder.appendChild(textNode);\n  if (suffix.length > 0) {\n    const ellipsisTextNode = document.createTextNode(suffix);\n    ellipsisContentHolder.appendChild(ellipsisTextNode);\n  }\n  ellipsisContainer.appendChild(ellipsisContentHolder);\n\n  // Expand node needs to be added only when text needTruncated\n  Object.values(omit(fixedContent, 'expand')).map(\n    node => node && ellipsisContainer.appendChild(node.cloneNode(true))\n  );\n\n  function appendExpandNode() {\n    ellipsisContainer.innerHTML = '';\n    ellipsisContainer.appendChild(ellipsisContentHolder);\n    Object.values(fixedContent).map(node => node && ellipsisContainer.appendChild(node.cloneNode(true)));\n  }\n\n  function getCurrentText(text: string, pos: number) {\n    const end = text.length;\n    if (!pos) {\n      return ellipsisStr;\n    }\n    if (ellipsisPos === 'end') {\n      return text.slice(0, pos) + ellipsisStr;\n    }\n    return text.slice(0, pos) + ellipsisStr + text.slice(end - pos, end);\n  }\n\n  // Get maximum text\n  function measureText(\n    textNode: Text,\n    fullText: string,\n    startLoc = 0,\n    endLoc = fullText.length,\n    lastSuccessLoc = 0\n  ): string {\n    const midLoc = Math.floor((startLoc + endLoc) / 2);\n    const currentText = getCurrentText(fullText, midLoc);\n    textNode.textContent = currentText;\n    // console.log('calculating....', currentText);\n    if (startLoc >= endLoc - 1 && endLoc > 0) { // Loop when step is small\n      for (let step = endLoc; step >= startLoc; step -= 1) {\n        const currentStepText = getCurrentText(fullText, step);\n        textNode.textContent = currentStepText;\n        if (inRange()) {\n          return currentStepText;\n        }\n      }\n    } else if (endLoc === 0) {\n      return ellipsisStr;\n    }\n\n    if (inRange()) {\n      return measureText(textNode, fullText, midLoc, endLoc, midLoc);\n    }\n    return measureText(textNode, fullText, startLoc, midLoc, lastSuccessLoc);\n  }\n\n  let resText = content;\n  // First judge whether the total length of fullText, plus suffix (possible)\n  // and copied icon (possible) meets expectations？\n  // If it does not meet expectations, add an expand button to find the largest  content that meets size limit\n  // 首先判断总文本长度，加上可能有的 suffix，复制按钮长度，看结果是否符合预期\n  // 如果不符合预期，则再加上展开按钮，找最大符合尺寸的内容\n  if (!inRange()) {\n    appendExpandNode();\n    resText = measureText(textNode, content, 0, ellipsisPos === 'middle' ? Math.floor((content.length) / 2) : content.length);\n  }\n  ellipsisContainer.innerHTML = '';\n  return resText;\n};\n\n\n\nexport default getRenderText\n\n"],"names":["ellipsisContainer","ellipsisApp","pxToNumber","value","match","Number","styleToString","style","Array","prototype","slice","apply","map","name","getPropertyValue","join","getRenderText","originEle","rows","content","fixedContent","ellipsisStr","suffix","ellipsisPos","isStrong","length","document","createElement","setAttribute","body","appendChild","originStyle","window","getComputedStyle","originCSS","lineHeight","maxHeight","Math","round","paddingTop","paddingBottom","position","left","height","top","zIndex","fontWeight","textOverflow","webkitLineClamp","unmount","createApp","h","mount","inRange","widthInRange","scrollWidth","offsetWidth","heightInRange","scrollHeight","ellipsisContentHolder","textNode","createTextNode","ellipsisTextNode","Object","values","omit","node","cloneNode","appendExpandNode","innerHTML","getCurrentText","text","pos","end","measureText","fullText","startLoc","endLoc","lastSuccessLoc","midLoc","floor","currentText","textContent","step","currentStepText","resText"],"mappings":"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"}