import { defineComponent as Ae, useSlots as Ie, ref as O, reactive as De, nextTick as A, onMounted as Ne, onUnmounted as Be, watch as _, getCurrentInstance as Le, cloneVNode as V, isRef as Re, createVNode as m, Fragment as ke, isVNode as W, mergeProps as Fe } from "vue";
import L from "classnames";
import * as o from "../PropTypes";
import { vuePropsMake as Me } from "../PropTypes";
import { noop as F, throttle as X, get as f, isEmpty as Y, omit as xe, each as He, isFunction as Ue } from "lodash";
import { BASE_CLASS_PREFIX as _e } from '@douyinfe/semi-foundation/lib/es/base/constants';
import Ve from '@douyinfe/semi-foundation/lib/es/utils/warning';
import Ke from '@douyinfe/semi-foundation/lib/es/utils/Event';
import { convertDOMRectToObject as $e } from '@douyinfe/semi-foundation/lib/es/utils/dom';
import je from '@douyinfe/semi-foundation/lib/es/tooltip/foundation';
import { cssClasses as ze, strings as I, numbers as P } from '@douyinfe/semi-foundation/lib/es/tooltip/constants';
import '@douyinfe/semi-foundation/lib/es/tooltip/tooltip.css';
import { useBaseComponent as Ge } from "../_base/baseComponent";
import { isHTMLElement as R } from "../_base/reactUtils";
import { getFocusableElements as We, getActiveElement as Xe, runAfterTicks as Ye, getMultinodeToFragment as Ze, isVNodeTypeNotSymbol as qe, stopPropagation as k } from "../_utils";
import { getUuidShort as Je } from '@douyinfe/semi-foundation/lib/es/utils/uuid';
import Qe from "../_portal";
import et from "./TriangleArrow";
import tt from "./TriangleArrowVertical";
import ot from "../_cssAnimation";
const M = ze.PREFIX;
I.POSITION_SET;
I.TRIGGER_SET;
const nt = ["flex", "block", "table", "flow-root", "grid"], it = () => document.body, rt = {
  // children: PropTypes.node,
  motion: o.oneOfType([o.bool, o.object, o.func]),
  autoAdjustOverflow: o.bool,
  position: String,
  getPopupContainer: o.func,
  mouseEnterDelay: o.number,
  mouseLeaveDelay: o.number,
  trigger: [Boolean, String],
  className: o.string,
  wrapperClassName: o.string,
  clickToHide: o.bool,
  // used with trigger === hover, private
  clickTriggerToHide: o.bool,
  visible: o.bool,
  style: o.object,
  content: o.oneOfType([o.node, o.func]),
  prefixCls: o.string,
  onVisibleChange: o.func,
  onClickOutSide: o.func,
  spacing: o.oneOfType([o.number, o.object]),
  margin: o.oneOfType([o.number, o.object]),
  showArrow: o.oneOfType([o.bool, o.node]),
  zIndex: o.number,
  rePosKey: [String, Number, Boolean],
  arrowBounding: Object,
  transformFromCenter: o.bool,
  // Whether to change from the center of the trigger (for dynamic effects)
  arrowPointAtCenter: o.bool,
  stopPropagation: o.bool,
  // private
  role: o.string,
  wrapWhenSpecial: o.bool,
  // when trigger has special status such as "disabled" or "loading", wrap span
  guardFocus: o.bool,
  returnFocusOnClose: o.bool,
  preventScroll: o.bool,
  disableFocusListener: o.bool,
  // name: String,
  // cancelText: String,
  // okText: String,
  // contentClassName: String,
  closeOnEsc: {
    type: Boolean,
    default: !1
  },
  onEscKeyDown: {
    type: Function,
    default: F
  },
  wrapperId: String,
  disableArrowKeyDown: Boolean,
  afterClose: Function,
  keepDOM: Boolean
}, lt = {
  arrowBounding: P.ARROW_BOUNDING,
  autoAdjustOverflow: !0,
  arrowPointAtCenter: !0,
  trigger: "hover",
  transformFromCenter: !0,
  position: "top",
  prefixCls: M,
  role: "tooltip",
  mouseEnterDelay: P.MOUSE_ENTER_DELAY,
  mouseLeaveDelay: P.MOUSE_LEAVE_DELAY,
  motion: !0,
  onVisibleChange: F,
  onClickOutSide: F,
  spacing: P.SPACING,
  margin: P.MARGIN,
  showArrow: !0,
  wrapWhenSpecial: !0,
  zIndex: P.DEFAULT_Z_INDEX,
  closeOnEsc: !1,
  guardFocus: !1,
  returnFocusOnClose: !1,
  onEscKeyDown: F,
  disableFocusListener: !1,
  disableArrowKeyDown: !1,
  keepDOM: !1
}, st = Me(rt, lt), At = /* @__PURE__ */ Ae({
  props: {
    ...st
  },
  name: "Tooltip",
  setup(n, {
    expose: Z
  }) {
    const q = Ie(), D = O(new Ke());
    let g = O();
    const N = O(), K = O(), v = O();
    let S, b, T, x, H = !1, w;
    const l = De({
      visible: !1,
      /**
       *
       * Note: The transitionState parameter is equivalent to isInsert
       */
      transitionState: "",
      triggerEventSet: {},
      portalEventSet: {},
      containerStyle: {
        // zIndex: props.zIndex,
      },
      isInsert: !1,
      placement: n.position || "top",
      transitionStyle: {},
      isPositionUpdated: !1,
      id: n.wrapperId,
      // auto generate id, will be used by children.aria-describedby & content.id, improve a11y
      displayNone: !1
    }), {
      adapter: J,
      context: $
    } = Ge(n, l), C = Q();
    function Q() {
      return {
        ...J(),
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        on: (...e) => D.value.on(...e),
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        off: (...e) => D.value.off(...e),
        getAnimatingState: () => H,
        insertPortal: (e, {
          position: t,
          ...r
        }) => {
          l.isInsert = !0, l.transitionState = "enter", l.containerStyle = {
            ...l.containerStyle,
            containerStyle: r
          }, A(() => {
            setTimeout(() => {
              D.value.emit("portalInserted");
            }, 0);
          });
        },
        removePortal: () => {
          l.isInsert = !1, l.isPositionUpdated = !1;
        },
        getEventName: () => ({
          mouseEnter: "onMouseenter",
          mouseLeave: "onMouseleave",
          mouseOut: "onMouseout",
          mouseOver: "onMouseover",
          click: "onClick",
          focus: "onFocus",
          blur: "onBlur",
          keydown: "onKeydown",
          contextMenu: "onContextmenu"
        }),
        registerTriggerEvent: (e) => {
          l.triggerEventSet = e;
        },
        registerPortalEvent: (e) => {
          l.portalEventSet = e;
        },
        getTriggerBounding: () => {
          var t;
          const e = C.getTriggerNode();
          return g.value = e, e && ((t = e.getBoundingClientRect) == null ? void 0 : t.call(e));
        },
        // Gets the outer size of the specified container
        getPopupContainerRect: () => {
          const e = T();
          let t = null;
          return e && R(e) && (t = {
            ...$e(e.getBoundingClientRect()),
            scrollLeft: e.scrollLeft,
            scrollTop: e.scrollTop
          }), t;
        },
        containerIsBody: () => T() === document.body,
        containerIsRelative: () => {
          const e = T();
          return window.getComputedStyle(e).getPropertyValue("position") === "relative";
        },
        containerIsRelativeOrAbsolute: () => ["relative", "absolute"].includes(x),
        // Get the size of the pop-up layer
        getWrapperBounding: () => {
          const e = N.value;
          return e && e.getBoundingClientRect();
        },
        getDocumentElementBounding: () => document.documentElement.getBoundingClientRect(),
        setPosition: ({
          position: e,
          ...t
        }) => {
          l.containerStyle = {
            ...l.containerStyle,
            ...t
          }, l.placement = e, l.isPositionUpdated = !0, A(() => {
            D.value.emit("positionUpdated");
          });
        },
        setDisplayNone: (e, t) => {
          l.displayNone = e, A(() => {
            t == null || t();
          });
        },
        updatePlacementAttr: (e) => {
          l.placement = e;
        },
        togglePortalVisible: (e, t) => {
          const r = {};
          r.transitionState = e ? "enter" : "leave", r.visible = e, S && (l.transitionState = r.transitionState, l.visible = r.visible, A(() => {
            t();
          }));
        },
        registerClickOutsideHandler: (e) => {
          w && C.unregisterClickOutsideHandler(), w = (t) => {
            if (!S)
              return !1;
            let r = g.value, i = N.value;
            const s = t.target, a = t.composedPath && t.composedPath() || [s], u = n.clickTriggerToHide ? r && r.contains(s) || a.includes(r) : !1;
            (r && !r.contains(s) && i && !i.contains(s) && !(a.includes(i) || a.includes(r)) || u) && (n.onClickOutSide(t), e());
          }, document.addEventListener("mousedown", w);
        },
        unregisterClickOutsideHandler: () => {
          w && (document.removeEventListener("mousedown", w), w = null);
        },
        registerResizeHandler: (e) => {
          v.value && C.unregisterResizeHandler(), v.value = X((t) => {
            if (!S)
              return !1;
            e(t);
          }, 10), window.addEventListener("resize", v.value, !1);
        },
        unregisterResizeHandler: () => {
          v.value && (window.removeEventListener("resize", v.value, !1), v.value = null);
        },
        notifyVisibleChange: (e) => {
          n.onVisibleChange(e);
        },
        registerScrollHandler: (e) => {
          b && C.unregisterScrollHandler(), b = X((t) => {
            if (!S)
              return !1;
            const r = C.getTriggerNode();
            if (t.target.contains(r)) {
              const s = {
                x: t.target.scrollLeft,
                y: t.target.scrollTop
              };
              e(s);
            }
          }, 10), window.addEventListener("scroll", b, !0);
        },
        unregisterScrollHandler: () => {
          b && (window.removeEventListener("scroll", b, !0), b = null);
        },
        canMotion: () => !!n.motion,
        updateContainerPosition: () => {
          const e = T();
          e && R(e) && (x = window.getComputedStyle(e).getPropertyValue("position"));
        },
        getContainerPosition: () => x,
        getContainer: () => N.value,
        getTriggerNode: () => {
          let e = g.value;
          return R(g.value) || (e = g.value), e;
        },
        getFocusableElements: (e) => We(e),
        getActiveElement: () => Xe(),
        setInitialFocus: () => {
          const {
            preventScroll: e
          } = n, t = K.value;
          t && "focus" in t && t.focus({
            preventScroll: e
          });
        },
        notifyEscKeydown: (e) => {
          n.onEscKeyDown(e);
        },
        setId: () => {
          l.id = Je();
        },
        getTriggerDOM: () => g.value ? g.value : null
      };
    }
    const c = new je(C);
    Ne(() => {
      S = !0, T = n.getPopupContainer || $.value.getPopupContainer || it, c.init(), Ye(() => {
        let e = g.value;
        e && (e instanceof HTMLElement || (e = e.$el)), c.updateStateIfCursorOnTrigger(e);
      }, 1);
    }), Be(() => {
      S = !1, c.destroy();
    });
    function ee() {
      c.focusTrigger();
    }
    const te = (e) => {
      if (R(e))
        return !!e.disabled;
      if (W(e)) {
        if (f(e, "props.disabled"))
          return I.STATUS_DISABLED;
        const r = f(e, "props.loading"), i = !Y(e) && !Y(e.type) && e.type.name === "Button" || e.type.name === "IconButton";
        if (r && i)
          return I.STATUS_LOADING;
      }
      return !1;
    }, oe = () => {
      n.keepDOM ? c.setDisplayNone(!0) : c.removePortal(), c.unBindEvent();
    };
    function ne() {
      return c.calcPosition();
    }
    _([() => n.mouseLeaveDelay, () => n.mouseEnterDelay], () => {
      Ve(n.mouseLeaveDelay < n.mouseEnterDelay, "[Semi Tooltip] 'mouseLeaveDelay' cannot be less than 'mouseEnterDelay', which may cause the dropdown layer to not be hidden.");
    }), _(() => n.visible, () => {
      ["hover", "focus"].includes(n.trigger) ? n.visible ? c.delayShow() : c.delayHide() : n.visible ? c.show() : c.hide();
    }), _(() => n.rePosKey, () => {
      A(() => {
        ne();
      });
    }, {});
    const ie = () => {
      const {
        placement: e
      } = l, {
        showArrow: t,
        prefixCls: r,
        style: i
      } = n;
      let s = null;
      const a = L([`${r}-icon-arrow`]), u = f(i, "backgroundColor"), E = e != null && e.includes("left") || e != null && e.includes("right") ? m(tt, null, null) : m(et, null, null);
      return t && (W(t) ? s = t : s = V(E, {
        class: a,
        style: {
          color: u,
          fill: "currentColor"
        }
      })), s;
    }, re = (e) => {
      n.clickToHide && c.hide(), n.stopPropagation && k(e);
    }, le = (e) => {
      n.stopPropagation && k(e);
    }, se = (e) => {
      n.stopPropagation && k(e);
    }, ae = (e) => {
      n.stopPropagation && k(e);
    }, ce = (e) => {
      c.handleContainerKeydown(e);
    }, ue = (e) => {
      const t = {
        initialFocusRef: K
      };
      return Ue(e) ? e(t) : e;
    }, de = () => {
      const {
        containerStyle: e = {},
        visible: t,
        portalEventSet: r,
        placement: i,
        displayNone: s,
        transitionState: a,
        id: u,
        isPositionUpdated: E
      } = l, {
        prefixCls: y,
        content: d,
        showArrow: p,
        style: z,
        motion: G,
        role: me,
        zIndex: ye
      } = n, ve = ue(d), {
        className: Se
      } = n, be = $.value.direction, we = L(Se, {
        [`${y}-wrapper`]: !0,
        [`${y}-wrapper-show`]: t,
        [`${y}-with-arrow`]: !!p,
        [`${y}-rtl`]: be === "rtl"
      }), Ce = ie();
      let h = xe(e, G ? ["transformOrigin"] : void 0);
      const Ee = f(e, "transformOrigin"), U = f(z, "opacity", null), Pe = U || 1;
      h = {
        ...h,
        left: h.left + "px",
        top: h.top + "px"
      };
      const Te = m(ot, {
        fillMode: "forwards",
        animationState: a,
        motion: G && E,
        startClassName: a === "enter" ? `${M}-animation-show` : `${M}-animation-hide`,
        onAnimationStart: () => H = !0,
        onAnimationEnd: () => {
          var B;
          a === "leave" && (oe(), (B = n.afterClose) == null || B.call(n)), H = !1;
        },
        children: ({
          animationStyle: B,
          animationClassName: he,
          animationEventsNeedBind: Oe
        }) => m("div", Fe({
          class: L(we, he),
          style: {
            ...B,
            ...s ? {
              display: "none"
            } : {},
            transformOrigin: Ee,
            ...z,
            ...U ? {
              opacity: E ? Pe : "0"
            } : {}
          }
        }, r, Oe, {
          role: me,
          "x-placement": i,
          id: u
        }), [m("div", {
          class: `${M}-content`
        }, [ve]), Ce])
      }, null);
      return m(Qe, {
        getPopupContainer: n.getPopupContainer,
        style: {
          zIndex: ye
        }
      }, {
        default: () => [m("div", {
          tabindex: -1,
          class: `${_e}-portal-inner`,
          style: h,
          ref: N,
          onClick: re,
          onFocus: se,
          onBlur: ae,
          onMousedown: le,
          onKeydown: ce
        }, [Te])]
      });
    }, j = (e) => {
      const {
        wrapperClassName: t
      } = n, r = f(e, "props.style.display"), i = f(e, "props.block"), s = typeof e == "string", a = {};
      return s || (a.display = "inline-block"), (i || nt.includes(r)) && (a.width = "100%"), m("span", {
        class: t,
        style: a
      }, [e]);
    }, fe = (e, t) => {
      const r = {};
      return He(t, (i, s) => {
        typeof i == "function" && (r[s] = (...a) => {
          i(...a), e && typeof e[s] == "function" && e[s](...a);
        });
      }), r;
    }, ge = () => l.id, pe = Le();
    return Z({
      getPopupId: ge,
      focusTrigger: ee,
      // 当组件内部使用了expose时，使用ref得到的内容只有expose的那部分
      getRef() {
        return pe;
      }
    }), () => {
      var y;
      const {
        wrapWhenSpecial: e,
        role: t,
        trigger: r
      } = n;
      let i = Ze(q);
      const s = {
        ...f(i, "props.style")
      }, a = {};
      if (e) {
        const d = te(i);
        d ? (s.pointerEvents = "none", d === I.STATUS_DISABLED && (a.cursor = "not-allowed"), i = V(i, {
          style: s
        }), r !== "custom" && (i = j(i))) : qe(i) || (i = j(i));
      }
      let u = {};
      t === "dialog" ? (u["aria-expanded"] = l.visible ? "true" : "false", u["aria-haspopup"] = "dialog", u["aria-controls"] = l.id) : u["aria-describedby"] = l.id;
      const E = V(i, {
        ...u,
        ...i.props,
        ...fe(i.props, l.triggerEventSet),
        style: {
          ...f(i, "props.style"),
          ...a
        },
        class: L(
          f(i, "props.class")
          // `${prefixCls}-trigger`
        ),
        // to maintain refs with callback
        ref: (d) => {
          g.value = d && (d.content || d.$el || d);
          const {
            ref: p
          } = i;
          p && (typeof p.r == "function" ? p.r(d) : p.r && typeof p.r == "object" && Re(p.r) && (p.r.value = d));
        },
        tabIndex: ((y = i.props) == null ? void 0 : y.tabIndex) || 0,
        // a11y keyboard, in some condition select's tabindex need to -1 or 0
        "data-popupid": l.id
      });
      return m(ke, null, [l.isInsert ? de() : null, E]);
    };
  }
});
export {
  At as default,
  st as vuePropsType
};
//# sourceMappingURL=index.js.map
