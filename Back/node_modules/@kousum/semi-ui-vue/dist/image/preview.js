import { defineComponent as Z, useSlots as q, reactive as G, ref as U, onMounted as $, shallowRef as B, watch as z, isVNode as P, nextTick as H, onBeforeUnmount as K, createVNode as v, mergeProps as _, cloneVNode as O } from "vue";
import { PreviewContext as X } from "./previewContext";
import * as e from "../PropTypes";
import { vuePropsMake as J } from "../PropTypes";
import Q from "./previewInner";
import W from '@douyinfe/semi-foundation/lib/es/image/previewFoundation';
import { getUuidShort as Y } from '@douyinfe/semi-foundation/lib/es/utils/uuid';
import { cssClasses as ee } from '@douyinfe/semi-foundation/lib/es/image/constants';
import { isEqual as ne, omit as re, isObject as te } from "lodash";
import '@douyinfe/semi-foundation/lib/es/image/image.css';
import { useHasInProps as oe, useBaseComponent as ie } from "../_base/baseComponent";
import { getFragmentChildren as se, getChildren as V } from "../_utils";
import ae from "classnames";
const N = ee.PREFIX, le = {
  style: e.object,
  className: e.string,
  visible: e.bool,
  src: e.oneOfType([e.string, e.array]),
  currentIndex: e.number,
  defaultCurrentIndex: e.number,
  defaultVisible: e.bool,
  maskClosable: e.bool,
  closable: e.bool,
  zoomStep: e.number,
  infinite: e.bool,
  showTooltip: e.bool,
  closeOnEsc: e.bool,
  prevTip: e.string,
  nextTip: e.string,
  zoomInTip: e.string,
  zoomOutTip: e.string,
  downloadTip: e.string,
  adaptiveTip: e.string,
  originTip: e.string,
  lazyLoad: e.bool,
  lazyLoadMargin: e.string,
  preLoad: e.bool,
  preLoadGap: e.number,
  previewCls: e.string,
  previewStyle: e.object,
  disableDownload: e.bool,
  zIndex: e.number,
  renderHeader: e.func,
  renderPreviewMenu: e.func,
  getPopupContainer: e.func,
  onVisibleChange: e.func,
  onChange: e.func,
  onClose: e.func,
  onZoomIn: e.func,
  onZoomOut: e.func,
  onPrev: e.func,
  onNext: e.func,
  onDownload: e.func,
  onRatioChange: e.func,
  onRotateChange: e.func,
  previewTitle: e.node,
  rotateTip: e.string,
  viewerVisibleDelay: e.number,
  crossOrigin: e.string,
  maxZoom: e.number,
  minZoom: e.number,
  onRotateLeft: e.func,
  onDownloadError: e.func,
  setDownloadName: e.func,
  forwardRef: [Function, Object]
}, ce = {
  src: [],
  lazyLoad: !0,
  lazyLoadMargin: "0px 100px 100px 0px",
  closable: !0
}, ue = J(le, ce), Te = /* @__PURE__ */ Z({
  props: {
    ...ue
  },
  name: "Preview",
  setup(i, {}) {
    const {
      getProps: g
    } = oe(), f = q(), m = G({
      currentIndex: i.currentIndex || i.defaultCurrentIndex || 0,
      visible: i.visible || i.defaultVisible || !1
    }), {
      adapter: D
    } = ie(i, m);
    function E() {
      return {
        ...D()
      };
    }
    const M = E(), w = new W(M), I = Y({
      prefix: "semi-image-preview-group",
      length: 4
    }), R = U();
    let u;
    $(() => {
      i.lazyLoad && x();
    });
    const y = B([]);
    z([() => i.lazyLoad, y], ([n, r], [t, s], d) => {
      if (i.lazyLoad) {
        const a = s == null ? void 0 : s.map((l) => P(l) ? l.key : null), o = r == null ? void 0 : r.map((l) => P(l) ? l.key : null);
        ne(a, o) || H(() => {
          x();
        });
      }
    });
    function x() {
      u ? u.disconnect() : u = new IntersectionObserver((r) => {
        r.forEach((t) => {
          var d;
          const s = (d = t.target.dataset) == null ? void 0 : d.src;
          t.isIntersecting && s && (t.target.src = s, t.target.removeAttribute("data-src")), u.unobserve(t.target);
        });
      }, {
        root: document.querySelector(`#${I}`),
        rootMargin: i.lazyLoadMargin
      }), document.querySelectorAll(`.${N}-img`).forEach((r) => u.observe(r));
    }
    function j(n, r) {
      const t = {};
      return "currentIndex" in g(n) && n.currentIndex !== r.currentIndex && (t.currentIndex = n.currentIndex), "visible" in g(n) && n.visible !== r.visible && (t.visible = n.visible), t;
    }
    z(() => i, (n) => {
      const r = j({
        ...i
      }, {
        ...m
      });
      r && Object.keys(r).forEach((t) => {
        m[t] = r[t];
      });
    }, {
      deep: !0
    }), K(() => {
      u && (u.disconnect(), u = null);
    });
    const p = (n) => {
      w.handleVisibleChange(n);
    }, A = (n) => {
      w.handleCurrentIndexChange(n);
    }, k = () => {
      const n = se(f) || [];
      let r = 0;
      const t = [], s = [], d = (a) => a.map((o) => {
        if (o && o.type && o.type.isSemiImage) {
          const {
            src: l,
            preview: c,
            alt: C
          } = o.props;
          if (c || c === void 0) {
            const b = te(c) ? c.src ?? l : l;
            return t.push(b), s.push(c == null ? void 0 : c.previewTitle), O(o, {
              imageID: r++
            });
          }
          return o;
        }
        return o && o.children ? (o.children = d(V(o.children)), O(o, {})) : o;
      });
      return {
        srcListInChildren: t,
        newChildren: d(V(n)),
        titles: s
      };
    };
    return () => {
      var T, L, S;
      y.value = ((S = (L = (T = f.default) == null ? void 0 : T.call(f)) == null ? void 0 : L[0]) == null ? void 0 : S.children) || [];
      const {
        src: n,
        className: r,
        style: t,
        lazyLoad: s,
        setDownloadName: d,
        ...a
      } = g(i), o = {
        ...re(a, ["previewCls", "previewStyle"]),
        className: a == null ? void 0 : a.previewCls,
        style: a == null ? void 0 : a.previewStyle
      }, {
        currentIndex: l,
        visible: c
      } = m, {
        srcListInChildren: C,
        newChildren: b,
        titles: F
      } = k(), h = [...Array.isArray(n) ? n : typeof n == "string" ? [n] : [], ...C];
      return v(X.Provider, {
        value: {
          isGroup: !0,
          previewSrc: h,
          titles: F,
          currentIndex: l,
          visible: c,
          lazyLoad: s,
          previewObserver: u,
          setCurrentIndex: A,
          handleVisibleChange: p,
          setDownloadName: d
        }
      }, {
        default: () => [v("div", {
          id: I,
          style: t,
          class: ae(`${N}-preview-group`, r)
        }, [b]), v(Q, _(p ? {
          ...o,
          onVisibleChange: p
        } : o, {
          ref: R,
          src: h,
          currentIndex: l,
          visible: c
        }), null)]
      });
    };
  }
});
export {
  Te as default,
  ue as vuePropsType
};
//# sourceMappingURL=preview.js.map
