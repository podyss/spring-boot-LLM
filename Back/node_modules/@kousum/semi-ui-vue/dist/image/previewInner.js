import { defineComponent as ye, useSlots as Ie, ref as m, reactive as Ce, watch as k, onMounted as Te, onBeforeUnmount as De, createVNode as l } from "vue";
import * as o from "../PropTypes";
import { vuePropsMake as Pe } from "../PropTypes";
import { cssClasses as xe, numbers as Re } from '@douyinfe/semi-foundation/lib/es/image/constants';
import y from "classnames";
import { isFunction as s, isEqual as ze } from "lodash";
import Se from "../_portal";
import { IconArrowLeft as Le, IconArrowRight as Me } from "@kousum/semi-icons-vue";
import Ze from "./previewHeader";
import Ee from "./previewFooter";
import Ne from "./previewImage";
import Oe from '@douyinfe/semi-foundation/lib/es/image/previewInnerFoundation';
import { getScrollbarWidth as Ve } from "../_utils";
import { usePreviewContext as Ae } from "./previewContext/Consumer";
import { useHasInProps as $e, useBaseComponent as We } from "../_base/baseComponent";
const B = xe.PREFIX, je = {
  style: o.object,
  className: o.string,
  lazyLoadMargin: o.string,
  visible: o.bool,
  src: o.oneOfType([o.string, o.array]),
  currentIndex: o.number,
  defaultCurrentIndex: o.number,
  defaultVisible: o.bool,
  maskClosable: o.bool,
  closable: o.bool,
  zoomStep: o.number,
  infinite: o.bool,
  showTooltip: o.bool,
  closeOnEsc: o.bool,
  prevTip: o.string,
  nextTip: o.string,
  zoomInTip: o.string,
  zoomOutTip: o.string,
  downloadTip: o.string,
  adaptiveTip: o.string,
  originTip: o.string,
  lazyLoad: o.bool,
  preLoad: o.bool,
  preLoadGap: o.number,
  disableDownload: o.bool,
  viewerVisibleDelay: o.number,
  zIndex: o.number,
  maxZoom: o.number,
  minZoom: o.number,
  renderHeader: o.func,
  renderPreviewMenu: o.func,
  getPopupContainer: o.func,
  onVisibleChange: o.func,
  onChange: o.func,
  onClose: o.func,
  onZoomIn: o.func,
  onZoomOut: o.func,
  onPrev: o.func,
  onNext: o.func,
  onDownload: o.func,
  onRatioChange: o.func,
  onRotateChange: o.func,
  // onRotateLeft: PropTypes.func as PropType<PreviewInnerProps['onRotateLeft']>,
  setDownloadName: o.func,
  crossOrigin: o.string,
  previewTitle: o.node,
  rotateTip: o.string,
  onRotateLeft: o.func,
  onDownloadError: o.func,
  forwardRef: [o.func, o.object]
}, ke = {
  showTooltip: !1,
  zoomStep: 0.1,
  infinite: !1,
  closeOnEsc: !0,
  lazyLoad: !1,
  preLoad: !0,
  preLoadGap: 2,
  zIndex: Re.DEFAULT_Z_INDEX,
  maskClosable: !0,
  viewerVisibleDelay: 1e4,
  maxZoom: 5,
  minZoom: 0.1
}, Be = Pe(je, ke), to = /* @__PURE__ */ ye({
  props: {
    ...Be
  },
  name: "PreviewInner",
  setup(i, {}) {
    const {
      getProps: F
    } = $e();
    Ie();
    let v, P, I;
    const f = m(), w = Ce({
      imgSrc: [],
      imgLoadStatus: /* @__PURE__ */ new Map(),
      zoom: 0.1,
      currentIndex: 0,
      ratio: "adaptation",
      rotation: 0,
      viewerVisible: !0,
      visible: !1,
      preloadAfterVisibleChange: !0,
      direction: ""
    }), {
      adapter: H
    } = We(i, w), {
      context: C
    } = Ae(), T = m(), x = m(), R = m(), z = m(), S = m();
    function G() {
      return {
        ...H(),
        getIsInGroup: () => X(),
        disabledBodyScroll: () => {
          const {
            getPopupContainer: e
          } = i;
          v = document.body.style.overflow || "", !e && v !== "hidden" && (document.body.style.overflow = "hidden", document.body.style.width = `calc(${I || "100%"} - ${P}px)`);
        },
        enabledBodyScroll: () => {
          const {
            getPopupContainer: e
          } = i;
          !e && v !== "hidden" && (document.body.style.overflow = v, document.body.style.width = I);
        },
        notifyChange: (e, n) => {
          const {
            onChange: t,
            onPrev: a,
            onNext: d
          } = i;
          s(t) && t(e), n === "prev" ? a && a(e) : d && d(e);
        },
        notifyZoom: (e, n) => {
          const {
            onZoomIn: t,
            onZoomOut: a
          } = i;
          n ? s(t) && t(e) : s(a) && a(e);
        },
        notifyClose: () => {
          const {
            onClose: e
          } = i;
          s(e) && e();
        },
        notifyVisibleChange: (e) => {
          const {
            onVisibleChange: n
          } = i;
          s(n) && n(e);
        },
        notifyRatioChange: (e) => {
          const {
            onRatioChange: n
          } = i;
          s(n) && n(e);
        },
        notifyRotateChange: (e) => {
          const {
            onRotateChange: n
          } = i;
          s(n) && n(e);
        },
        notifyDownload: (e, n) => {
          const {
            onDownload: t
          } = i;
          s(t) && t(e, n);
        },
        notifyDownloadError: (e) => {
          const {
            onDownloadError: n
          } = i;
          s(n) && n(e);
        },
        registerKeyDownListener: () => {
          window && window.addEventListener("keydown", M);
        },
        unregisterKeyDownListener: () => {
          window && window.removeEventListener("keydown", M);
        },
        getSetDownloadFunc: () => {
          var e;
          return ((e = C.value) == null ? void 0 : e.setDownloadName) ?? i.setDownloadName;
        },
        isValidTarget: (e) => {
          const n = x.value, t = R.value, a = z.value, d = S.value, u = e.target;
          return !(n && n.contains(u) || t && t.contains(u) || a && a.contains(u) || d && d.contains(u));
        },
        changeImageZoom: (...e) => {
          f != null && f.value && f.value.foundation.changeZoom(...e);
        }
      };
    }
    const U = G(), r = new Oe(U);
    function K(e, n) {
      const t = {};
      let a = [];
      return e.visible && (a = Array.isArray(e.src) ? e.src : [e.src]), ze(a, n.imgSrc) || (t.imgSrc = a), e.visible !== n.visible && (t.visible = e.visible, e.visible && (t.preloadAfterVisibleChange = !0, t.viewerVisible = !0, t.rotation = 0, t.ratio = "adaptation")), "currentIndex" in F(e) && e.currentIndex !== n.currentIndex && (t.currentIndex = e.currentIndex, t.ratio = "adaptation"), t;
    }
    k(() => i, (e) => {
      const n = K({
        ...i
      }, {
        ...w
      });
      n && Object.keys(n).forEach((t) => {
        w[t] = n[t];
      });
    }, {
      deep: !0,
      immediate: !0
    }), Te(() => {
      P = Ve(), I = document.body.style.width, i.visible && r.beforeShow();
    }), k([() => w.visible, () => i.visible, () => i.src], (e, [n, t, a], d) => {
      a !== i.src && r.updateTimer(), !n && i.visible && r.beforeShow(), n && !i.visible && r.afterHide();
    }, {
      immediate: !0
    }), De(() => {
      r.clearTimer();
    });
    function X() {
      return !!(C && C.value.isGroup);
    }
    const g = (e) => {
      r.handleSwitchImage(e);
    }, q = () => {
      r.handleDownload();
    }, _ = (e) => {
      r.handlePreviewClose(e);
    }, L = (e) => {
      r.handleAdjustRatio(e);
    }, J = (e) => {
      r.handleRotateImage(e);
    }, D = (e, n = !0) => {
      r.handleZoomImage(e);
    }, Q = (e) => {
      r.handleMouseUp(e);
    }, Y = (e) => {
      r.handleMouseMove(e);
    };
    function M(e) {
      r.handleKeyDown(e);
    }
    function ee() {
      r.preloadSingleImage();
    }
    function oe(e) {
      r.onImageLoad(e);
    }
    function ne(e) {
      r.handleMouseDown(e);
    }
    const Z = (e) => {
      r.handleWheel(e);
    }, te = (e) => {
      T.value && T.value.removeEventListener("wheel", Z), e && e.addEventListener("wheel", Z, {
        passive: !1
      }), T.value = e;
    };
    return () => {
      const {
        getPopupContainer: e,
        closable: n,
        zIndex: t,
        visible: a,
        className: d,
        style: u,
        infinite: E,
        zoomStep: ie,
        crossOrigin: re,
        prevTip: ae,
        nextTip: le,
        zoomInTip: se,
        zoomOutTip: de,
        rotateTip: ce,
        downloadTip: ue,
        adaptiveTip: me,
        originTip: fe,
        showTooltip: we,
        disableDownload: N,
        renderPreviewMenu: ve,
        renderHeader: ge
      } = i, {
        currentIndex: p,
        imgSrc: O,
        zoom: V,
        ratio: A,
        rotation: pe,
        viewerVisible: he
      } = w;
      let $ = {
        zIndex: t
      };
      e && ($ = {
        zIndex: t,
        position: "static"
      });
      const c = `${B}-preview`, be = y(c, {
        [`${B}-hide`]: !a,
        [`${c}-popup`]: e
      }, d), h = he ? "" : `${c}-hide`, b = O.length, W = b !== 1 && (E || p !== 0), j = b !== 1 && (E || p !== b - 1);
      return a && l(Se, {
        getPopupContainer: e,
        style: $
      }, {
        default: () => [l("div", {
          class: be,
          style: u,
          onMousedown: ne,
          onMouseup: Q,
          ref: te,
          onMousemove: Y
        }, [l(Ze, {
          ref: x,
          className: y(h),
          onClose: _,
          renderHeader: ge,
          closable: n
        }, null), l(Ne, {
          ref: f,
          src: O[p],
          onZoom: D,
          disableDownload: N,
          setRatio: L,
          zoom: V,
          ratio: A,
          rotation: pe,
          crossOrigin: re,
          onError: ee,
          onLoad: oe
        }, null), W && // eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions
        l("div", {
          ref: z,
          class: y(`${c}-icon`, `${c}-prev`, h),
          onClick: () => g("prev")
        }, [l(Le, {
          size: "large"
        }, null)]), j && // eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions
        l("div", {
          ref: S,
          class: y(`${c}-icon`, `${c}-next`, h),
          onClick: () => g("next")
        }, [l(Me, {
          size: "large"
        }, null)]), l(Ee, {
          forwardRef: R,
          className: h,
          totalNum: b,
          curPage: p + 1,
          disabledPrev: !W,
          disabledNext: !j,
          zoom: V * 100,
          step: ie * 100,
          showTooltip: we,
          ratio: A,
          prevTip: ae,
          nextTip: le,
          zIndex: t,
          zoomInTip: se,
          zoomOutTip: de,
          rotateTip: ce,
          downloadTip: ue,
          disableDownload: N,
          adaptiveTip: me,
          originTip: fe,
          onPrev: () => g("prev"),
          onNext: () => g("next"),
          onZoomIn: D,
          onZoomOut: D,
          onDownload: q,
          onRotate: J,
          onAdjustRatio: L,
          renderPreviewMenu: ve
        }, null)])]
      });
    };
  }
});
export {
  to as default,
  Be as vuePropsType
};
//# sourceMappingURL=previewInner.js.map
