import { defineComponent as g, useSlots as y, ref as d, computed as x, createVNode as i, shallowRef as m, watch as v, isVNode as S, mergeProps as O } from "vue";
import I from "classnames";
import * as t from "../PropTypes";
import { vuePropsMake as p } from "../PropTypes";
import { DragDropProvider as C } from "@kousum/dnd-kit-vue";
import { useSortable as P } from "@kousum/dnd-kit-vue/sortable";
function h(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !S(e);
}
function T(e) {
  return i("div", O({
    style: {
      overflow: "auto"
    }
  }, e), null);
}
const j = {
  collisionDetector: t.func,
  onSortEnd: t.func,
  // Set drag and drop trigger conditions
  modifiers: t.array,
  // the dragged itemsï¼ŒThe content in items cannot be the number 0
  items: t.array,
  // Function that renders the item that is allowed to be dragged
  renderItem: t.func,
  // Whether to use a separate drag layer for items that move with the mouse
  useDragOverlay: t.bool,
  // A container for all elements that are allowed to be dragged
  container: t.any,
  // Whether to change the size of the item being dragged
  adjustScale: t.bool,
  // prefix
  prefix: t.string,
  // The className of the item that moves with the mouse during the drag
  dragOverlayCls: t.string
}, E = {
  useDragOverlay: !0,
  container: T
}, w = p(j, E), M = /* @__PURE__ */ g({
  props: {
    ...w
  },
  name: "Sortable",
  setup(e, {
    attrs: D
  }) {
    y();
    const l = d(null);
    function a(n) {
      l.value = n;
    }
    const s = (n) => e.items.indexOf(n), u = x(() => l ? s(l.value) : -1), c = (n) => {
      const {
        source: r
      } = n.operation;
      r && a(r.id);
    }, f = (n) => {
      a(null);
      const {
        target: r
      } = n.operation;
      if (r) {
        const o = s(r.id);
        u.value !== o && e.onSortEnd(n);
      }
    };
    return () => {
      let n;
      const r = e.container;
      return i(C, {
        modifiers: e.modifiers,
        onDragStart: c,
        onDragOver: (o) => {
          f(o);
        },
        onDragEnd: (o) => {
        }
      }, {
        default: () => [i(r, null, h(n = e.items.map((o, b) => i(q, {
          key: o,
          id: o,
          index: b,
          renderItem: e.renderItem,
          useDragOverlay: e.useDragOverlay,
          prefix: e.prefix,
          collisionDetector: e.collisionDetector,
          dragOverlayCls: e.dragOverlayCls
        }, null))) ? n : {
          default: () => [n]
        })]
      });
    };
  }
}), k = {
  collisionDetector: t.func,
  id: {
    type: [t.number, t.string],
    required: !0
  },
  index: {
    type: t.number,
    required: !0
  },
  useDragOverlay: t.bool,
  renderItem: t.func,
  prefix: t.string,
  // The className of the item that moves with the mouse during the drag
  dragOverlayCls: t.string
}, q = /* @__PURE__ */ g({
  props: {
    ...k
  },
  name: "SortableItem",
  setup(e, {
    attrs: D
  }) {
    y();
    const l = d(null), a = d(null), s = m(e.id);
    v(() => e.id, (r, o) => {
      r !== o && (s.value = o);
    });
    const u = m(e.index);
    v(() => e.index, (r, o) => {
      r !== o && (u.value = o);
    });
    const {
      isDragSource: c,
      isDropTarget: f
    } = P({
      id: s,
      index: u,
      element: l,
      handle: a,
      collisionDetector: e.collisionDetector
    }), n = (r) => () => i("span", {
      ref: a,
      style: {
        lineHeight: 0
      }
    }, [i(r, null, null)]);
    return () => {
      const r = I(`${e.prefix}-sortable-item`, {
        // [`${props.prefix}-sortable-item-over`]: isDropTarget?.value,
        // [`${props.prefix}-sortable-item-active`]: isDragSource?.value,
        [e.dragOverlayCls]: c == null ? void 0 : c.value
      });
      return i("div", {
        ref: l,
        class: r
      }, [e.renderItem({
        id: e.id,
        sortableHandle: n
      })]);
    };
  }
});
export {
  M as Sortable,
  q as SortableItem,
  j as propTypesSortable,
  k as vuePropsType
};
//# sourceMappingURL=index.js.map
