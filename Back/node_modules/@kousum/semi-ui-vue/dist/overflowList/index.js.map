{"version":3,"file":"index.js","sources":["../../src/components/overflowList/index.tsx"],"sourcesContent":["import cls from 'classnames';\nimport * as PropTypes from '../PropTypes';\nimport { isEqual, omit, isNull, isUndefined, isFunction, get, debounce } from 'lodash';\nimport { cssClasses, strings, numbers } from '@douyinfe/semi-foundation/overflowList/constants';\nimport ResizeObserver, { ResizeEntry } from '../resizeObserver';\nimport IntersectionObserver from './intersectionObserver';\n\nimport OverflowListFoundation, { OverflowListAdapter } from '@douyinfe/semi-foundation/overflowList/foundation';\n\nimport '@douyinfe/semi-foundation/overflowList/overflowList.scss';\nimport { CombineProps, VueJsxNode } from '../interface';\nimport copy from 'fast-copy';\nimport {\n  cloneVNode,\n  ComponentObjectPropsOptions,\n  createVNode,\n  CSSProperties,\n  defineComponent,\n  Fragment,\n  h,\n  isVNode,\n  nextTick,\n  PropType,\n  reactive,\n  ref,\n  shallowRef,\n  toRaw,\n  useSlots,\n  VNode,\n  watch,\n} from 'vue';\nimport { vuePropsMake } from '../PropTypes';\nimport { useBaseComponent, useHasInProps } from '../_base/baseComponent';\n\nconst prefixCls = cssClasses.PREFIX;\nconst Boundary = strings.BOUNDARY_MAP;\nconst OverflowDirection = strings.OVERFLOW_DIR;\nconst RenderMode = strings.MODE_MAP;\n\nexport type { ReactIntersectionObserverProps } from './intersectionObserver';\nexport type OverflowItem = Record<string, any>;\n\ntype Key = string | number;\n\nexport interface OverflowListProps {\n  className?: string;\n  collapseFrom?: 'start' | 'end';\n  items?: Array<OverflowItem>;\n  minVisibleItems?: number;\n  onIntersect?: (res: { [key: string]: IntersectionObserverEntry }) => void;\n  onOverflow?: (overflowItems: Array<OverflowItem>) => void;\n  overflowRenderer?: (overflowItems: Array<OverflowItem>) => VueJsxNode | VueJsxNode[];\n  renderMode?: 'collapse' | 'scroll';\n  style?: CSSProperties;\n  threshold?: number | number[];\n  visibleItemRenderer?: (item: OverflowItem, index: number) => VueJsxNode;\n  wrapperClassName?: string;\n  wrapperStyle?: CSSProperties;\n  itemKey?: Key | ((item: OverflowItem) => Key);\n  onVisibleStateChange?: (visibleState: Map<string, boolean>) => void;\n  overflowRenderDirection?: 'both' | 'start' | 'end'; // used in tabs, not exposed to user\n  collapseMask?: any;\n}\n\nexport interface OverflowListState {\n  direction?: typeof OverflowDirection.GROW;\n  lastOverflowCount?: number;\n  overflow?: Array<OverflowItem>;\n  visible?: Array<OverflowItem>;\n  visibleState?: Map<string, boolean>;\n  prevProps?: OverflowListProps;\n  itemSizeMap?: Map<Key, number>;\n  containerWidth?: number;\n  maxCount?: number;\n  overflowStatus?: 'calculating' | 'overflowed' | 'normal';\n  pivot?: number;\n  overflowWidth?: number;\n}\n\n// reference to https://github.com/palantir/blueprint/blob/1aa71605/packages/core/src/components/overflow-list/overflowList.tsx#L34\nconst defaultProps = {\n  collapseFrom: 'end',\n  minVisibleItems: 0,\n  overflowRenderer: (): VueJsxNode => null,\n  renderMode: 'collapse',\n  threshold: 0.75,\n  visibleItemRenderer: (): VueJsxNode => null,\n  onOverflow: () => null,\n  overflowRenderDirection: 'both',\n};\nconst propTypes: CombineProps<OverflowListProps> = {\n  // if render in scroll mode, key is required in items\n  className: PropTypes.string,\n  collapseFrom: PropTypes.string as PropType<OverflowListProps['collapseFrom']>,\n  // direction: PropTypes.string as PropType<OverflowListProps['direction']>,\n  items: PropTypes.array,\n  minVisibleItems: PropTypes.number,\n  onIntersect: PropTypes.func as PropType<OverflowListProps['onIntersect']>,\n  onOverflow: PropTypes.func as PropType<OverflowListProps['onOverflow']>,\n  overflowRenderer: PropTypes.func as PropType<OverflowListProps['overflowRenderer']>,\n  renderMode: PropTypes.string as PropType<OverflowListProps['renderMode']>,\n  style: PropTypes.object,\n  threshold: [PropTypes.number, PropTypes.array] as PropType<OverflowListProps['threshold']>,\n  visibleItemRenderer: PropTypes.func as PropType<OverflowListProps['visibleItemRenderer']>,\n  wrapperClassName: PropTypes.string,\n  wrapperStyle: PropTypes.object,\n  collapseMask: PropTypes.object as PropType<OverflowListProps['collapseMask']>,\n  overflowRenderDirection: PropTypes.string as PropType<OverflowListProps['overflowRenderDirection']>,\n  onVisibleStateChange: PropTypes.func as PropType<OverflowListProps['onVisibleStateChange']>,\n  itemKey: [PropTypes.string, PropTypes.bool, PropTypes.func] as PropType<OverflowListProps['itemKey']>,\n};\nexport const vuePropsType = vuePropsMake<OverflowListProps>(propTypes, defaultProps);\nconst OverflowList = defineComponent({\n  props: { ...vuePropsType },\n  name: 'OverflowList',\n  setup(props, {}) {\n    const { getProps } = useHasInProps();\n    const slots = useSlots();\n\n    const state = reactive<OverflowListState>({\n      direction: OverflowDirection.GROW,\n      lastOverflowCount: 0,\n      overflow: [],\n      visible: [],\n      containerWidth: 0,\n      visibleState: new Map(),\n      itemSizeMap: new Map(),\n      overflowStatus: 'calculating',\n      pivot: 0,\n      overflowWidth: 0,\n      maxCount: 0,\n    });\n\n    function getDerivedStateFromProps(props_: OverflowListProps, prevState: OverflowListState): OverflowListState {\n      const { prevProps } = prevState;\n      const newState: OverflowListState = {};\n      newState.prevProps = props_;\n\n      const needUpdate = (name: string): boolean => {\n        return (!prevProps && name in props_) || (prevProps && !isEqual(prevProps[name], props_[name]));\n      };\n      if (needUpdate('items') || needUpdate('style')) {\n        // reset visible state if the above props change.\n        newState.direction = OverflowDirection.GROW;\n        newState.lastOverflowCount = 0;\n        newState.maxCount = 0;\n        if (props_.renderMode === RenderMode.SCROLL) {\n          newState.visible = props_.items;\n          newState.overflow = [];\n        } else {\n          let maxCount = props_.items.length;\n          if (Math.floor(prevState.containerWidth / numbers.MINIMUM_HTML_ELEMENT_WIDTH) !== 0) {\n            maxCount = Math.min(maxCount, Math.floor(prevState.containerWidth / numbers.MINIMUM_HTML_ELEMENT_WIDTH));\n          }\n\n          const isCollapseFromStart = props_.collapseFrom === Boundary.START;\n          const visible = isCollapseFromStart\n            ? copy(props_.items).reverse().slice(0, maxCount)\n            : props_.items.slice(0, maxCount);\n          const overflow = isCollapseFromStart\n            ? copy(props_.items).reverse().slice(maxCount)\n            : props_.items.slice(maxCount);\n          newState.visible = visible;\n          newState.overflow = overflow;\n          newState.maxCount = maxCount;\n        }\n        newState.pivot = -1;\n        newState.overflowStatus = 'calculating';\n      }\n      return newState;\n    }\n\n    watch(\n      [() => props.items, () => props.style, () => props.renderMode, () => props.collapseFrom],\n      (val) => {\n        const newState = getDerivedStateFromProps({ ...getProps(props) }, { ...state });\n        newState &&\n          Object.keys(newState).forEach((key) => {\n            state[key] = newState[key];\n          });\n      },\n      { immediate: true }\n    );\n\n    const { adapter: adapterInject } = useBaseComponent<OverflowListProps>(props, state);\n\n    function adapter_(): OverflowListAdapter {\n      return {\n        ...adapterInject(),\n        updateVisibleState: (visibleState): void => {\n          state.visibleState = visibleState;\n          nextTick(() => {\n            props.onVisibleStateChange?.(visibleState);\n          });\n        },\n        updateStates: (states): void => {\n          states &&\n            Object.keys(states).forEach((key) => {\n              state[key] = states[key];\n            });\n        },\n        notifyIntersect: (res): void => {\n          props.onIntersect && props.onIntersect(res);\n        },\n        getItemSizeMap: () => {\n          return itemSizeMap;\n        },\n      };\n    }\n\n    const adapter = adapter_();\n\n    const foundation = new OverflowListFoundation(adapter);\n\n    let itemRefs = shallowRef({});\n\n    let scroller = null;\n    let spacer: HTMLDivElement = null;\n\n    let previousWidths: Map<Element, number> = new Map();\n\n    let itemSizeMap: Map<string, number> = new Map();\n\n    const isScrollMode = (): boolean => {\n      const { renderMode } = props;\n      return renderMode === RenderMode.SCROLL;\n    };\n\n    const onItemResizeNum = shallowRef(0);\n\n    watch(\n      [\n        () => props.items,\n        () => props.collapseFrom,\n        () => state.overflow,\n        () => state.containerWidth,\n        () => state.visible,\n        () => state.overflowStatus,\n        () => onItemResizeNum.value,\n      ],\n      (value, oldValue) => {\n        const prevItemsKeys = oldValue[0].map((item) => item.key);\n        const nowItemsKeys = props.items.map((item) => item.key);\n\n        // Determine whether to update by comparing key values\n        if (!isEqual(prevItemsKeys, nowItemsKeys)) {\n          itemRefs.value = {};\n          state.visibleState = new Map();\n        }\n\n        const { overflow, containerWidth, visible, overflowStatus } = state;\n\n        if (isScrollMode() || overflowStatus !== 'calculating') {\n          return;\n        }\n        foundation.handleCollapseOverflow();\n      }\n    );\n\n    const resize = (entries: Array<ResizeEntry> = []): void => {\n      const containerWidth = entries[0]?.target.clientWidth;\n      state.containerWidth = containerWidth;\n      state.overflowStatus = 'calculating';\n    };\n\n    const reintersect = (entries: Array<IntersectionObserverEntry>): void => {\n      foundation.handleIntersect(entries);\n    };\n\n    const mergeRef = (ref_: any, node: Element, key: Key): void => {\n      if (!itemRefs.value[key]) {\n        itemRefs.value[key] = node;\n        itemRefs.value = {\n          ...itemRefs.value,\n        };\n      }\n      if (typeof ref_ === 'function') {\n        ref_(node);\n      } else if (typeof ref_ === 'object' && ref_ && 'value' in ref_) {\n        ref_.value = node;\n      }\n    };\n\n    const renderOverflow = (): VueJsxNode => {\n      // 不要删除，这里需要它进行更新渲染，不然页面似乎不会更新\n      console.debug(state.visibleState.size);\n      const overflow = foundation.getOverflowItem();\n      return props.overflowRenderer(overflow);\n    };\n\n    const getItemKey = (item, defalutKey?: Key) => {\n      const { itemKey } = props;\n      if (isFunction(itemKey)) {\n        return itemKey(item);\n      }\n      return get(item, itemKey || 'key', defalutKey);\n    };\n\n    const renderItemList = () => {\n      const { className, wrapperClassName, wrapperStyle, style, visibleItemRenderer, renderMode, collapseFrom } = props;\n\n      const { visible, overflowStatus } = state;\n      let overflow = renderOverflow();\n      if (!isScrollMode()) {\n        if (Array.isArray(overflow)) {\n          overflow = <Fragment>{overflow}</Fragment>;\n        }\n        if (isVNode(overflow)) {\n          const child = cloneVNode(overflow);\n          overflow = (\n            <ResizeObserver\n              onResize={([entry]) => {\n                state.overflowWidth = entry.target.clientWidth;\n                state.overflowStatus = 'calculating';\n              }}\n            >\n              <div class={`${prefixCls}-overflow`}>{child}</div>\n            </ResizeObserver>\n          );\n        }\n      }\n      const inner =\n        renderMode === RenderMode.SCROLL\n          ? (() => {\n              const list = [\n                <div\n                  class={cls(wrapperClassName, `${prefixCls}-scroll-wrapper`)}\n                  ref={(ref): void => {\n                    scroller = ref as any;\n                  }}\n                  style={{ ...wrapperStyle }}\n                  key={`${prefixCls}-scroll-wrapper`}\n                >\n                  {visible.map(visibleItemRenderer).map((item) => {\n                    const { forwardRef, key } = (item as any).props;\n                    return cloneVNode(item as VNode, {\n                      ref: (node: any) => mergeRef(forwardRef, node, key),\n                      'data-scrollkey': `${key}`,\n                      key,\n                    });\n                  })}\n                </div>,\n              ];\n              if (props.overflowRenderDirection === 'both') {\n                list.unshift(overflow[0]);\n                list.push(overflow[1]);\n              } else if (props.overflowRenderDirection === 'start') {\n                list.unshift(overflow[1]);\n                list.unshift(overflow[0]);\n              } else {\n                list.push(overflow[0]);\n                list.push(overflow[1]);\n              }\n              return list;\n            })()\n          : [\n              collapseFrom === Boundary.START ? overflow : null,\n              visible.map((item, idx) => {\n                const { key } = item;\n                const element = visibleItemRenderer(item, idx);\n                const child = cloneVNode(element as any);\n                return (\n                  <ResizeObserver key={key ?? idx} onResize={([entry]) => onItemResize(entry, item, idx)}>\n                    {/* 用div包起来，可以直接在resize回调中拿到宽度，不用通过获取元素的padding, margin, border-width求和计算宽度*/}\n                    {/* This div wrap can get width directly rather than do the math of padding, margin, border-width*/}\n                    <div key={key ?? idx} class={`${prefixCls}-item`}>\n                      {child}\n                    </div>\n                  </ResizeObserver>\n                );\n              }),\n              collapseFrom === Boundary.END ? overflow : null,\n            ];\n      const list = createVNode(\n        'div',\n        {\n          class: cls(`${prefixCls}`, className),\n          style: {\n            ...style,\n            ...(renderMode === RenderMode.COLLAPSE\n              ? {\n                  maxWidth: '100%',\n                  visibility: overflowStatus === 'calculating' ? 'hidden' : 'visible',\n                }\n              : null),\n          },\n        },\n        [...inner]\n      );\n      return list;\n    };\n\n    /**\n     * 调用时机问题 for Vue\n     * onItemResize -> handleCollapseOverflow(拿到更新后的itemSizeMap)\n     */\n    const onItemResizeNum_ = debounce(() => {\n      onItemResizeNum.value++;\n    }, 10);\n\n    const onItemResize = (entry: ResizeEntry, item: OverflowItem, idx: number) => {\n      let hasChangeMap = false;\n      const key = getItemKey(item, idx);\n      const width = itemSizeMap.get(key);\n      if (!width) {\n        itemSizeMap.set(key, entry.target.clientWidth);\n        hasChangeMap = true;\n      } else if (width !== entry.target.clientWidth) {\n        // 某个item发生resize后，重新计算\n        itemSizeMap.set(key, entry.target.clientWidth);\n        state.overflowStatus = 'calculating';\n        hasChangeMap = true;\n      }\n      const { maxCount } = state;\n      // 已经按照最大值maxCount渲染完毕，触发真正的渲染。(-1 是overflow部分会占1)\n      // Already rendered maxCount items, trigger the real rendering. (-1 for the overflow part)\n      if (itemSizeMap.size === maxCount - 1) {\n        state.overflowStatus = 'calculating';\n      }\n      hasChangeMap && onItemResizeNum_();\n    };\n\n    return () => {\n      const list = renderItemList();\n      const { renderMode } = props;\n      if (renderMode === RenderMode.SCROLL) {\n        return (\n          <IntersectionObserver\n            onIntersect={reintersect}\n            threshold={props.threshold}\n            root={scroller}\n            items={itemRefs.value}\n            children={() => list}\n          ></IntersectionObserver>\n        );\n      }\n      return <ResizeObserver onResize={resize}>{list}</ResizeObserver>;\n    };\n  },\n});\n\nexport default OverflowList;\n"],"names":["_isSlot","s","Object","prototype","toString","call","_isVNode","prefixCls","cssClasses","PREFIX","Boundary","strings","BOUNDARY_MAP","OverflowDirection","OVERFLOW_DIR","RenderMode","MODE_MAP","defaultProps","collapseFrom","minVisibleItems","overflowRenderer","renderMode","threshold","visibleItemRenderer","onOverflow","overflowRenderDirection","propTypes","className","PropTypes","string","items","array","number","onIntersect","func","style","object","wrapperClassName","wrapperStyle","collapseMask","onVisibleStateChange","itemKey","bool","vuePropsType","vuePropsMake","OverflowList","defineComponent","props","name","setup","getProps","useHasInProps","useSlots","state","reactive","direction","GROW","lastOverflowCount","overflow","visible","containerWidth","visibleState","Map","itemSizeMap","overflowStatus","pivot","overflowWidth","maxCount","getDerivedStateFromProps","props_","prevState","prevProps","newState","needUpdate","isEqual","SCROLL","length","Math","floor","numbers","MINIMUM_HTML_ELEMENT_WIDTH","min","isCollapseFromStart","START","copy","reverse","slice","watch","val","keys","forEach","key","immediate","adapter","adapterInject","useBaseComponent","adapter_","updateVisibleState","nextTick","updateStates","states","notifyIntersect","res","getItemSizeMap","foundation","OverflowListFoundation","itemRefs","shallowRef","scroller","isScrollMode","onItemResizeNum","value","oldValue","prevItemsKeys","map","item","nowItemsKeys","handleCollapseOverflow","resize","entries","target","clientWidth","reintersect","handleIntersect","mergeRef","ref_","node","renderOverflow","console","debug","size","getOverflowItem","getItemKey","defalutKey","isFunction","get","renderItemList","Array","isArray","_createVNode","_Fragment","isVNode","child","cloneVNode","ResizeObserver","onResize","entry","default","inner","list","cls","ref","forwardRef","unshift","push","idx","element","onItemResize","END","createVNode","class","COLLAPSE","maxWidth","visibility","onItemResizeNum_","debounce","hasChangeMap","width","set","IntersectionObserver","children"],"mappings":"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"}