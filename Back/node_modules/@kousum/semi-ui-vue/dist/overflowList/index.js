import { defineComponent as ee, useSlots as te, reactive as oe, watch as T, shallowRef as z, createVNode as m, isVNode as V, nextTick as ne, Fragment as re, cloneVNode as O } from "vue";
import F from "classnames";
import * as l from "../PropTypes";
import { vuePropsMake as ie } from "../PropTypes";
import { isEqual as P, debounce as le, isFunction as se, get as ae } from "lodash";
import { cssClasses as ce, strings as W, numbers as k } from '@douyinfe/semi-foundation/lib/es/overflowList/constants';
import p from "../resizeObserver";
import ue from "./intersectionObserver";
import fe from '@douyinfe/semi-foundation/lib/es/overflowList/foundation';
import '@douyinfe/semi-foundation/lib/es/overflowList/overflowList.css';
import D from "fast-copy";
import { useHasInProps as me, useBaseComponent as de } from "../_base/baseComponent";
function ve(o) {
  return typeof o == "function" || Object.prototype.toString.call(o) === "[object Object]" && !V(o);
}
const y = ce.PREFIX, C = W.BOUNDARY_MAP, j = W.OVERFLOW_DIR, M = W.MODE_MAP, we = {
  collapseFrom: "end",
  minVisibleItems: 0,
  overflowRenderer: () => null,
  renderMode: "collapse",
  threshold: 0.75,
  visibleItemRenderer: () => null,
  onOverflow: () => null,
  overflowRenderDirection: "both"
}, he = {
  // if render in scroll mode, key is required in items
  className: l.string,
  collapseFrom: l.string,
  // direction: PropTypes.string as PropType<OverflowListProps['direction']>,
  items: l.array,
  minVisibleItems: l.number,
  onIntersect: l.func,
  onOverflow: l.func,
  overflowRenderer: l.func,
  renderMode: l.string,
  style: l.object,
  threshold: [l.number, l.array],
  visibleItemRenderer: l.func,
  wrapperClassName: l.string,
  wrapperStyle: l.object,
  collapseMask: l.object,
  overflowRenderDirection: l.string,
  onVisibleStateChange: l.func,
  itemKey: [l.string, l.bool, l.func]
}, be = ie(he, we), Ee = /* @__PURE__ */ ee({
  props: {
    ...be
  },
  name: "OverflowList",
  setup(o, {}) {
    const {
      getProps: A
    } = me();
    te();
    const r = oe({
      direction: j.GROW,
      lastOverflowCount: 0,
      overflow: [],
      visible: [],
      containerWidth: 0,
      visibleState: /* @__PURE__ */ new Map(),
      itemSizeMap: /* @__PURE__ */ new Map(),
      overflowStatus: "calculating",
      pivot: 0,
      overflowWidth: 0,
      maxCount: 0
    });
    function x(e, t) {
      const {
        prevProps: n
      } = t, i = {};
      i.prevProps = e;
      const f = (s) => !n && s in e || n && !P(n[s], e[s]);
      if (f("items") || f("style")) {
        if (i.direction = j.GROW, i.lastOverflowCount = 0, i.maxCount = 0, e.renderMode === M.SCROLL)
          i.visible = e.items, i.overflow = [];
        else {
          let s = e.items.length;
          Math.floor(t.containerWidth / k.MINIMUM_HTML_ELEMENT_WIDTH) !== 0 && (s = Math.min(s, Math.floor(t.containerWidth / k.MINIMUM_HTML_ELEMENT_WIDTH)));
          const d = e.collapseFrom === C.START, h = d ? D(e.items).reverse().slice(0, s) : e.items.slice(0, s), v = d ? D(e.items).reverse().slice(s) : e.items.slice(s);
          i.visible = h, i.overflow = v, i.maxCount = s;
        }
        i.pivot = -1, i.overflowStatus = "calculating";
      }
      return i;
    }
    T([() => o.items, () => o.style, () => o.renderMode, () => o.collapseFrom], (e) => {
      const t = x({
        ...A(o)
      }, {
        ...r
      });
      t && Object.keys(t).forEach((n) => {
        r[n] = t[n];
      });
    }, {
      immediate: !0
    });
    const {
      adapter: $
    } = de(o, r);
    function H() {
      return {
        ...$(),
        updateVisibleState: (e) => {
          r.visibleState = e, ne(() => {
            var t;
            (t = o.onVisibleStateChange) == null || t.call(o, e);
          });
        },
        updateStates: (e) => {
          e && Object.keys(e).forEach((t) => {
            r[t] = e[t];
          });
        },
        notifyIntersect: (e) => {
          o.onIntersect && o.onIntersect(e);
        },
        getItemSizeMap: () => b
      };
    }
    const K = H(), S = new fe(K);
    let w = z({}), L = null, b = /* @__PURE__ */ new Map();
    const N = () => {
      const {
        renderMode: e
      } = o;
      return e === M.SCROLL;
    }, E = z(0);
    T([() => o.items, () => o.collapseFrom, () => r.overflow, () => r.containerWidth, () => r.visible, () => r.overflowStatus, () => E.value], (e, t) => {
      const n = t[0].map((v) => v.key), i = o.items.map((v) => v.key);
      P(n, i) || (w.value = {}, r.visibleState = /* @__PURE__ */ new Map());
      const {
        overflow: f,
        containerWidth: s,
        visible: d,
        overflowStatus: h
      } = r;
      N() || h !== "calculating" || S.handleCollapseOverflow();
    });
    const U = (e = []) => {
      var n;
      const t = (n = e[0]) == null ? void 0 : n.target.clientWidth;
      r.containerWidth = t, r.overflowStatus = "calculating";
    }, B = (e) => {
      S.handleIntersect(e);
    }, G = (e, t, n) => {
      w.value[n] || (w.value[n] = t, w.value = {
        ...w.value
      }), typeof e == "function" ? e(t) : typeof e == "object" && e && "value" in e && (e.value = t);
    }, q = () => {
      console.debug(r.visibleState.size);
      const e = S.getOverflowItem();
      return o.overflowRenderer(e);
    }, X = (e, t) => {
      const {
        itemKey: n
      } = o;
      return se(n) ? n(e) : ae(e, n || "key", t);
    }, Y = () => {
      const {
        className: e,
        wrapperClassName: t,
        wrapperStyle: n,
        style: i,
        visibleItemRenderer: f,
        renderMode: s,
        collapseFrom: d
      } = o, {
        visible: h,
        overflowStatus: v
      } = r;
      let a = q();
      if (!N() && (Array.isArray(a) && (a = m(re, null, [a])), V(a))) {
        const c = O(a);
        a = m(p, {
          onResize: ([u]) => {
            r.overflowWidth = u.target.clientWidth, r.overflowStatus = "calculating";
          }
        }, {
          default: () => [m("div", {
            class: `${y}-overflow`
          }, [c])]
        });
      }
      const Z = s === M.SCROLL ? (() => {
        const c = [m("div", {
          class: F(t, `${y}-scroll-wrapper`),
          ref: (u) => {
            L = u;
          },
          style: {
            ...n
          },
          key: `${y}-scroll-wrapper`
        }, [h.map(f).map((u) => {
          const {
            forwardRef: R,
            key: g
          } = u.props;
          return O(u, {
            ref: (I) => G(R, I, g),
            "data-scrollkey": `${g}`,
            key: g
          });
        })])];
        return o.overflowRenderDirection === "both" ? (c.unshift(a[0]), c.push(a[1])) : o.overflowRenderDirection === "start" ? (c.unshift(a[1]), c.unshift(a[0])) : (c.push(a[0]), c.push(a[1])), c;
      })() : [d === C.START ? a : null, h.map((c, u) => {
        const {
          key: R
        } = c, g = f(c, u), I = O(g);
        return m(p, {
          key: R ?? u,
          onResize: ([_]) => Q(_, c, u)
        }, {
          default: () => [m("div", {
            key: R ?? u,
            class: `${y}-item`
          }, [I])]
        });
      }), d === C.END ? a : null];
      return m("div", {
        class: F(`${y}`, e),
        style: {
          ...i,
          ...s === M.COLLAPSE ? {
            maxWidth: "100%",
            visibility: v === "calculating" ? "hidden" : "visible"
          } : null
        }
      }, [...Z]);
    }, J = le(() => {
      E.value++;
    }, 10), Q = (e, t, n) => {
      let i = !1;
      const f = X(t, n), s = b.get(f);
      s ? s !== e.target.clientWidth && (b.set(f, e.target.clientWidth), r.overflowStatus = "calculating", i = !0) : (b.set(f, e.target.clientWidth), i = !0);
      const {
        maxCount: d
      } = r;
      b.size === d - 1 && (r.overflowStatus = "calculating"), i && J();
    };
    return () => {
      const e = Y(), {
        renderMode: t
      } = o;
      return t === M.SCROLL ? m(ue, {
        onIntersect: B,
        threshold: o.threshold,
        root: L,
        items: w.value,
        children: () => e
      }, null) : m(p, {
        onResize: U
      }, ve(e) ? e : {
        default: () => [e]
      });
    };
  }
});
export {
  Ee as default,
  be as vuePropsType
};
//# sourceMappingURL=index.js.map
