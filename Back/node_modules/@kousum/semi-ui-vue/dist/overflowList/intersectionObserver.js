import * as i from "../PropTypes";
import { vuePropsMake as l } from "../PropTypes";
import { isEqual as h, isEmpty as y } from "lodash";
import { defineComponent as b, useSlots as O, watch as a, onBeforeUnmount as j } from "vue";
import I from '@douyinfe/semi-foundation/lib/es/utils/isElement';
const k = {
  onIntersect: i.func,
  option: i.object,
  root: i.any,
  threshold: [i.number, i.array],
  rootMargin: i.string,
  items: i.object,
  children: i.func
}, E = {
  onIntersect: () => {
  },
  threshold: 0.75,
  rootMargin: "0px",
  option: {},
  items: {}
}, g = l(k, E), w = /* @__PURE__ */ b({
  props: {
    ...g
  },
  name: "ReactIntersectionObserver",
  setup(t, {}) {
    O();
    let e, r;
    a(() => t.root, (n) => {
      if (!e && n) {
        const {
          items: o
        } = t;
        r = Object.keys(o);
        const {
          root: s,
          threshold: c,
          rootMargin: m,
          option: u,
          onIntersect: d
        } = t;
        e = new IntersectionObserver(d, {
          root: s,
          threshold: c,
          rootMargin: m,
          ...u
        }), f();
      }
    }, {
      immediate: !0
    }), a([() => Object.keys(t.items), () => t.children, () => t.root], () => {
      if (e) {
        const {
          items: n
        } = t, o = Object.keys(n);
        h(r, o) || (f(!0), r = o);
      }
    }), j(() => {
      e && (e.disconnect(), e = null);
    });
    function f(n = !1) {
      const {
        items: o
      } = t;
      if (y(o)) {
        e == null || e.disconnect();
        return;
      }
      n && (e == null || e.disconnect()), Object.keys(o).forEach((s) => {
        const c = o[s];
        if (!c)
          return;
        const m = I(c) ? c : c.$el;
        e == null || e.observe(m);
      });
    }
    return () => {
      var n;
      return (n = t.children) == null ? void 0 : n.call(t);
    };
  }
});
export {
  w as default,
  g as vuePropsType
};
//# sourceMappingURL=intersectionObserver.js.map
