import { defineComponent as Re, useSlots as je, reactive as Ae, ref as O, watch as Me, createVNode as u, mergeProps as F, isVNode as Ie, toRaw as Z, Fragment as ze } from "vue";
import p from "classnames";
import * as n from "../PropTypes";
import { vuePropsMake as We } from "../PropTypes";
import Je from '@douyinfe/semi-foundation/lib/es/tree/foundation';
import { convertDataToEntities as ee, convertJsonToData as Ue, calcExpandedKeys as J, calcMotionKeys as te, calcExpandedKeysForValues as U, flattenTreeData as ne, filterTreeData as _e, findKeysForValues as D, normalizeValue as E, updateKeys as $e, calcCheckedKeys as Be, calcDisabledKeys as He } from '@douyinfe/semi-foundation/lib/es/tree/treeUtil';
import { cssClasses as qe } from '@douyinfe/semi-foundation/lib/es/tree/constants';
import { isEmpty as L, get as _, isFunction as Ge, pick as Xe, isUndefined as Qe, isEqual as Ye } from "lodash";
import { cloneDeep as $ } from "./treeUtil";
import Ze from "../input/index";
import { FixedSizeList as et } from "@kousum/vue3-window";
import tt from "./autoSizer";
import nt from "./treeContext";
import B from "./treeNode";
import { default as jt } from "./treeNode";
import at from "./nodeList";
import ae from "../locale/localeConsumer";
import '@douyinfe/semi-foundation/lib/es/tree/tree.css';
import { IconSearch as lt } from "@kousum/semi-icons-vue";
import ot from "../checkbox/checkboxGroup";
import { useConfigContext as dt } from "../configProvider/context/Consumer";
import { useHasInProps as it, useBaseComponent as rt } from "../_base/baseComponent";
export * from "./interface";
function le(o) {
  return typeof o == "function" || Object.prototype.toString.call(o) === "[object Object]" && !Ie(o);
}
const k = qe.PREFIX, st = {
  autoMergeValue: n.bool,
  blockNode: n.bool,
  className: n.string,
  showClear: n.bool,
  defaultExpandAll: n.bool,
  defaultExpandedKeys: n.array,
  defaultValue: n.oneOfType([n.string, n.array]),
  directory: n.bool,
  disabled: n.bool,
  emptyContent: n.node,
  expandAll: n.bool,
  expandedKeys: n.array,
  filterTreeNode: n.oneOfType([n.func, n.bool]),
  icon: [n.object, n.func],
  onChangeWithObject: n.bool,
  motion: n.bool,
  multiple: n.bool,
  onChange: n.func,
  onExpand: n.func,
  onSearch: n.func,
  onSelect: n.func,
  onContextMenu: n.func,
  onDoubleClick: n.func,
  searchClassName: n.string,
  searchPlaceholder: n.string,
  searchStyle: n.object,
  selectedKey: n.string,
  showFilteredOnly: n.bool,
  showLine: n.bool,
  style: n.object,
  treeData: n.array,
  keyMaps: n.object,
  treeDataSimpleJson: n.object,
  treeNodeFilterProp: n.string,
  value: n.oneOfType([n.string, n.number, n.array, n.object]),
  virtualize: n.object,
  autoExpandParent: n.bool,
  expandAction: [String, Boolean],
  searchRender: n.oneOfType([n.func, n.bool]),
  renderLabel: n.func,
  renderFullLabel: n.func,
  leafOnly: n.bool,
  loadedKeys: n.array,
  loadData: n.func,
  onLoad: n.func,
  disableStrictly: n.bool,
  draggable: n.bool,
  autoExpandWhenDragEnter: n.bool,
  hideDraggingNode: n.bool,
  renderDraggingNode: n.func,
  onDragEnd: n.func,
  onDragEnter: n.func,
  onDragLeave: n.func,
  onDragOver: n.func,
  onDragStart: n.func,
  onDrop: n.func,
  labelEllipsis: n.bool,
  checkRelation: n.string,
  "aria-label": n.string,
  preventScroll: n.bool,
  role: n.string
}, ct = {
  showClear: !0,
  disabled: !1,
  blockNode: !0,
  multiple: !1,
  filterTreeNode: !1,
  autoExpandParent: !1,
  treeNodeFilterProp: "label",
  defaultExpandAll: !1,
  expandAll: !1,
  onChangeWithObject: !1,
  motion: !0,
  leafOnly: !1,
  showFilteredOnly: !1,
  showLine: !1,
  expandAction: !1,
  disableStrictly: !1,
  draggable: !1,
  autoExpandWhenDragEnter: !0,
  checkRelation: "related",
  autoMergeValue: !0
}, ut = We(st, ct), pt = /* @__PURE__ */ Re({
  props: {
    ...ut
  },
  name: "Tree",
  setup(o, {
    expose: oe
  }) {
    je();
    const {
      getProps: de
    } = it();
    let ie, re;
    const {
      context: se
    } = dt(), f = Ae({
      inputValue: "",
      keyEntities: {},
      treeData: [],
      flattenNodes: [],
      selectedKeys: [],
      checkedKeys: /* @__PURE__ */ new Set(),
      halfCheckedKeys: /* @__PURE__ */ new Set(),
      realCheckedKeys: /* @__PURE__ */ new Set([]),
      motionKeys: /* @__PURE__ */ new Set([]),
      motionType: "hide",
      expandedKeys: new Set(o.expandedKeys),
      filteredKeys: /* @__PURE__ */ new Set(),
      filteredExpandedKeys: /* @__PURE__ */ new Set(),
      filteredShownKeys: /* @__PURE__ */ new Set(),
      prevProps: null,
      loadedKeys: /* @__PURE__ */ new Set(),
      loadingKeys: /* @__PURE__ */ new Set(),
      cachedFlattenNodes: void 0,
      cachedKeyValuePairs: {},
      disabledKeys: /* @__PURE__ */ new Set(),
      dragging: !1,
      dragNodesKeys: /* @__PURE__ */ new Set(),
      dragOverNodeKey: null,
      dropPosition: null
    }), R = O();
    O();
    const T = O(), H = O(), {
      adapter: ce,
      getDataAttr: ue
    } = rt(o, f);
    function fe() {
      const e = {
        updateInputValue: (t) => {
          f.inputValue = t;
        },
        focusInput: () => {
          const {
            preventScroll: t
          } = o;
          R.value && R.value.focus({
            preventScroll: t
          });
        }
      };
      return {
        ...ce(),
        ...e,
        updateState: (t) => {
          Object.keys(t).forEach((l) => {
            f[l] = t[l];
          });
        },
        notifyExpand: (t, {
          expanded: l,
          node: d
        }) => {
          o.onExpand && o.onExpand([...t], {
            expanded: l,
            node: d
          }), l && o.loadData && G(d);
        },
        notifySelect: (t, l, d) => {
          o.onSelect && o.onSelect(t, l, d);
        },
        notifyChange: (t) => {
          o.onChange && o.onChange(t);
        },
        notifySearch: (t, l) => {
          o.onSearch && o.onSearch(t, l);
        },
        notifyRightClick: (t, l) => {
          o.onContextMenu && o.onContextMenu(t, l);
        },
        notifyDoubleClick: (t, l) => {
          o.onDoubleClick && o.onDoubleClick(t, l);
        },
        cacheFlattenNodes: (t) => {
          f.cachedFlattenNodes = t ? $(f.flattenNodes) : void 0;
        },
        setDragNode: (t) => {
          T.value = t;
        }
      };
    }
    const ye = fe(), y = new Je(ye);
    function he(e, t) {
      var w;
      const {
        prevProps: l
      } = t, {
        keyMaps: d
      } = e;
      let i, s = t.keyEntities || {}, c = t.cachedKeyValuePairs || {};
      const m = !!(e.filterTreeNode && t.inputValue && t.inputValue.length), a = {
        prevProps: e
      }, g = "expandedKeys" in e, N = (r) => {
        const h = !l && r in e, x = l && !Ye(l[r], e[r]);
        return h || x;
      }, M = () => {
        const r = !l && "treeData" in e, h = l && l.treeData !== e.treeData;
        return r || h;
      }, P = N("treeData"), C = N("treeDataSimpleJson");
      if (P || e.draggable && M()) {
        i = e.treeData, a.treeData = i;
        const r = ee(i, d);
        a.keyEntities = {
          ...r.keyEntities
        }, s = a.keyEntities, a.cachedKeyValuePairs = {
          ...r.valueEntities
        }, c = a.cachedKeyValuePairs;
      } else if (C) {
        i = Ue(e.treeDataSimpleJson), a.treeData = i;
        const r = ee(i, d);
        a.keyEntities = {
          ...r.keyEntities
        }, s = a.keyEntities, a.cachedKeyValuePairs = {
          ...r.valueEntities
        }, c = a.cachedKeyValuePairs;
      }
      i && e.motion && l && e.motion && (a.motionKeys = /* @__PURE__ */ new Set([]), a.motionType = null);
      const v = C || P, I = v && e.expandAll;
      if (m) {
        let r;
        if (i && (r = _e({
          treeData: i,
          inputValue: t.inputValue,
          filterTreeNode: e.filterTreeNode,
          filterProps: e.treeNodeFilterProp,
          showFilteredOnly: e.showFilteredOnly,
          keyEntities: a.keyEntities,
          prevExpandedKeys: [...t.filteredExpandedKeys],
          keyMaps: d
        }), a.flattenNodes = r.flattenNodes, a.motionKeys = /* @__PURE__ */ new Set([]), a.filteredKeys = r.filteredKeys, a.filteredShownKeys = r.filteredShownKeys, a.filteredExpandedKeys = r.filteredExpandedKeys), e.expandedKeys) {
          if (a.filteredExpandedKeys = J(e.expandedKeys, s, e.autoExpandParent || !l), l && e.motion) {
            const h = t ? t.filteredExpandedKeys : /* @__PURE__ */ new Set([]);
            if (!i) {
              const x = te(h, a.filteredExpandedKeys, s);
              let {
                motionKeys: S
              } = x;
              const {
                motionType: V
              } = x;
              e.showFilteredOnly && (S = S.filter((z) => t.filteredShownKeys.has(z))), V === "hide" && (a.cachedFlattenNodes = $(t.flattenNodes)), a.motionKeys = new Set(S), a.motionType = V;
            }
          }
          a.flattenNodes = ne(i || t.treeData, a.filteredExpandedKeys || t.filteredExpandedKeys, d, e.showFilteredOnly && t.filteredShownKeys);
        }
      } else {
        if (N("expandedKeys") || l && N("autoExpandParent")) {
          if (a.expandedKeys = J(e.expandedKeys, s, e.autoExpandParent || !l), l && e.motion && !i) {
            const {
              motionKeys: r,
              motionType: h
            } = te(t.expandedKeys, a.expandedKeys, s);
            a.motionKeys = new Set(r), a.motionType = h, h === "hide" && (a.cachedFlattenNodes = $(t.flattenNodes));
          }
        } else !l && (e.defaultExpandAll || e.expandAll) || I ? a.expandedKeys = new Set(Object.keys(s)) : !l && e.defaultExpandedKeys ? a.expandedKeys = J(e.defaultExpandedKeys, s) : !l && e.defaultValue ? a.expandedKeys = U(e.defaultValue, s, e.multiple, c) : !l && e.value ? a.expandedKeys = U(e.value, s, e.multiple, c) : !g && v && e.value && (t.treeData && ((w = t.treeData) == null ? void 0 : w.length) > 0 && e.loadData || (a.expandedKeys = U(e.value, s, e.multiple, c)));
        if (a.expandedKeys || delete a.expandedKeys, i || a.expandedKeys) {
          const r = ne(i || t.treeData, a.expandedKeys || t.expandedKeys, d);
          a.flattenNodes = r;
        }
      }
      const b = e.onChangeWithObject, K = e.multiple;
      if (!K)
        N("value") ? a.selectedKeys = D(
          // In both cases whether withObject is turned on, the value is standardized to string
          E(e.value, b, d),
          c,
          K
        ) : !l && e.defaultValue ? a.selectedKeys = D(E(e.defaultValue, b, d), c, K) : i && e.value && (a.selectedKeys = D(E(e.value, b, d) || "", c, K));
      else {
        let r;
        if (N("value") ? r = D(E(e.value, b, d), c, K) : !l && e.defaultValue ? r = D(E(e.defaultValue, b, d), c, K) : i && (e.value ? r = D(E(e.value, b, d) || [], c, K) : r = $e(e.checkRelation === "related" ? t.checkedKeys : t.realCheckedKeys, s)), r) {
          if (e.checkRelation === "unRelated")
            a.realCheckedKeys = new Set(r);
          else if (e.checkRelation === "related") {
            const {
              checkedKeys: h,
              halfCheckedKeys: x
            } = Be(r, s);
            a.checkedKeys = h, a.halfCheckedKeys = x;
          }
        }
      }
      return N("loadedKeys") && (a.loadedKeys = new Set(e.loadedKeys)), i && e.disableStrictly && e.checkRelation === "related" && (a.disabledKeys = He(s, d)), a;
    }
    Me([
      () => o.filterTreeNode,
      () => o.treeData,
      () => o.draggable,
      () => o.treeDataSimpleJson,
      () => o.motion,
      () => o.expandAll,
      () => o.autoExpandParent,
      () => o.defaultExpandAll,
      () => o.defaultExpandedKeys,
      () => o.multiple,
      () => o.value,
      () => o.treeNodeFilterProp,
      () => o.showFilteredOnly,
      () => o.onChangeWithObject,
      () => o.defaultValue,
      () => o.loadedKeys,
      () => o.disableStrictly,
      () => o.checkRelation
      // getDerivedStateFromProps -> 不需要监听state
      // () => state.keyEntities as any,
      // () => state.cachedKeyValuePairs as any,
      // () => state.inputValue as any,
      // () => state.expandedKeys as any,
      // () => state.flattenNodes as any,
      // () => state.treeData as any,
      // () => state.filteredExpandedKeys as any,
      // () => state.filteredShownKeys as any,
      // () => state.checkedKeys as any,
    ], (e, t, l) => {
      const d = he({
        ...de(o)
      }, {
        ...f
      });
      d && Object.keys(d).forEach((i) => {
        f[i] = d[i];
      });
    }, {
      immediate: !0
    });
    const q = (e) => {
      y.handleInputChange(e);
    };
    oe({
      search: q,
      scrollTo: (e) => {
        var i;
        const {
          key: t,
          align: l = "center"
        } = e, {
          flattenNodes: d
        } = f;
        if (t) {
          const s = d == null ? void 0 : d.findIndex((c) => c.key === t);
          s >= 0 && ((i = H.value) == null || i.scrollToItem(s, l));
        }
      }
    });
    function me() {
      const {
        searchClassName: e,
        searchStyle: t,
        searchRender: l,
        searchPlaceholder: d,
        showClear: i
      } = o;
      if (l === !1)
        return null;
      const s = p(`${k}-input`), {
        inputValue: c
      } = f, m = {
        value: c,
        className: s,
        onChange: (g) => q(g),
        prefix: u(lt, null, null),
        showClear: i,
        placeholder: d
      }, a = p(`${k}-search-wrapper`, e);
      return u("div", {
        class: a,
        style: t
      }, [u(ae, {
        componentName: "Tree"
      }, {
        default: (g) => (m.placeholder = d || _(g, "searchPlaceholder"), Ge(l) ? l({
          ...m
        }) : u(Ze, F({
          "aria-label": "Filter Tree",
          ref: R
        }, m), null))
      })]);
    }
    const Ke = () => {
      const {
        emptyContent: e
      } = o;
      return e ? u(B, {
        key: "empty_tree",
        empty: !0,
        emptyContent: o.emptyContent
      }, null) : u(ae, {
        componentName: "Tree"
      }, {
        default: (t) => u(B, {
          key: "empty_tree",
          empty: !0,
          emptyContent: _(t, "emptyText")
        }, null)
      });
    }, ge = (e, t) => {
      y.handleNodeSelect(e, t);
    }, G = (e) => new Promise((t) => {
      const {
        loadingKeys: l
      } = y.handleNodeLoad(Z(f.loadedKeys) || /* @__PURE__ */ new Set([]), Z(f.loadingKeys) || /* @__PURE__ */ new Set([]), e, t);
      f.loadingKeys = l;
    }), Ne = (e, t) => {
      y.handleNodeSelect(e, t);
    }, be = (e, t) => {
      y.handleNodeExpand(e, t);
    }, xe = (e, t) => {
      y.handleNodeRightClick(e, t);
    }, De = (e, t) => {
      y.handleNodeDoubleClick(e, t);
    }, Ee = (e, t) => {
      y.handleNodeDragStart(e, t);
    }, ke = (e, t) => {
      y.handleNodeDragEnter(e, t, T.value);
    }, Ce = (e, t) => {
      y.handleNodeDragOver(e, t, T.value);
    }, we = (e, t) => {
      y.handleNodeDragLeave(e, t);
    }, Se = (e, t) => {
      y.handleNodeDragEnd(e, t);
    }, Te = (e, t) => {
      y.handleNodeDrop(e, t, T.value);
    }, j = (e, t, l) => {
      const {
        data: d,
        key: i
      } = e, s = y.getTreeNodeProps(i);
      if (!s)
        return null;
      const {
        keyMaps: c,
        showLine: m
      } = o, a = Xe(e, ["key", "label", "disabled", "isLeaf", "icon", "isEnd"]), g = d[_(c, "children", "children")];
      return !Qe(g) && (a.children = g), u(B, F(s, d, a, {
        showLine: m,
        data: d,
        style: L(l) ? {} : l
      }), null);
    }, Pe = (e, t) => t[e].key, A = ({
      index: e,
      style: t,
      data: l
    }) => j(l[e], e, t);
    function X() {
      const {
        flattenNodes: e,
        cachedFlattenNodes: t,
        motionKeys: l,
        motionType: d
      } = f, {
        virtualize: i,
        motion: s
      } = o, {
        direction: c
      } = se.value;
      if (!L(e))
        return !i || L(i) ? u(ze, null, [u(at, {
          flattenNodes: e,
          flattenList: t,
          motionKeys: s ? l : /* @__PURE__ */ new Set([]),
          motionType: d,
          onMotionEnd: re,
          renderTreeNode: j
        }, null)]) : u(tt, {
          defaultHeight: i.height,
          defaultWidth: i.width,
          children: ({
            height: m,
            width: a
          }) => u(et, {
            ref: H,
            itemCount: e.length,
            itemSize: i.itemSize,
            height: parseInt("" + m),
            width: a,
            itemKey: Pe,
            itemData: e,
            className: `${k}-virtual-list`,
            style: {
              direction: c
            }
          }, le(A) ? A : {
            default: () => [A]
          })
        }, null);
    }
    return () => {
      let e;
      const {
        keyEntities: t,
        motionKeys: l,
        motionType: d,
        inputValue: i,
        filteredKeys: s,
        dragOverNodeKey: c,
        dropPosition: m,
        checkedKeys: a,
        realCheckedKeys: g
      } = f, {
        blockNode: N,
        className: M,
        style: P,
        filterTreeNode: C,
        disabled: v,
        icon: I,
        directory: b,
        multiple: K,
        showFilteredOnly: w,
        showLine: r,
        motion: h,
        expandAction: x,
        loadData: S,
        renderLabel: V,
        draggable: z,
        renderFullLabel: ve,
        labelEllipsis: Q,
        virtualize: Ve,
        checkRelation: Oe
      } = o, Fe = p(`${k}-wrapper`, M), pe = p(`${k}-option-list`, {
        [`${k}-option-list-block`]: N
      }), Le = !!i && !s.size, Y = L(t) || w && Le, W = {
        role: Y ? "none" : "tree"
      };
      return W.role === "tree" && (W["aria-multiselectable"] = !!K), u(nt.Provider, {
        value: {
          treeDisabled: v,
          treeIcon: I,
          motion: h,
          motionKeys: l,
          motionType: d,
          filterTreeNode: C,
          keyEntities: t,
          onNodeClick: ie,
          onNodeExpand: be,
          onNodeSelect: ge,
          onNodeCheck: Ne,
          onNodeRightClick: xe,
          onNodeDoubleClick: De,
          renderTreeNode: j,
          onNodeDragStart: Ee,
          onNodeDragEnter: ke,
          onNodeDragOver: Ce,
          onNodeDragLeave: we,
          onNodeDragEnd: Se,
          onNodeDrop: Te,
          expandAction: x,
          directory: b,
          multiple: K,
          showFilteredOnly: w,
          isSearching: !!i,
          loadData: S,
          onNodeLoad: G,
          renderLabel: V,
          draggable: z,
          renderFullLabel: ve,
          dragOverNodeKey: c,
          dropPosition: m,
          labelEllipsis: typeof Q > "u" ? Ve : Q
        }
      }, {
        default: () => [u("div", F({
          "aria-label": o["aria-label"],
          class: Fe,
          style: P
        }, ue()), [C ? me() : null, u("div", F({
          class: pe
        }, W), [Y ? Ke() : K ? u(ot, {
          value: Array.from(Oe === "related" ? a : g)
        }, le(e = X()) ? e : {
          default: () => [e]
        }) : X()])])]
      });
    };
  }
});
export {
  jt as TreeNode,
  pt as default,
  ut as vuePropsType
};
//# sourceMappingURL=index.js.map
