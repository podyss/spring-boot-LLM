import { defineComponent as fe, useSlots as ge, ref as me, reactive as be, cloneVNode as he, createVNode as s, mergeProps as ve } from "vue";
import y from "classnames";
import * as o from "../PropTypes";
import { vuePropsMake as ye } from "../PropTypes";
import { cssClasses as Ce } from '@douyinfe/semi-foundation/lib/es/tree/constants';
import j from '@douyinfe/semi-foundation/lib/es/utils/isEnterPress';
import { debounce as ke, isEmpty as Ne, get as A, isString as M, isFunction as z } from "lodash";
import { IconTreeTriangleDown as $e, IconFile as De, IconFolderOpen as xe, IconFolder as Pe } from "@kousum/semi-icons-vue";
import { Checkbox as Ie } from "../checkbox";
import Ee from "../spin";
import { getHighLightTextHTML as Le } from "../_utils/index";
import { useTreeContext as Se } from "./TreeContext/Consumer";
import Te from "./indent";
const t = Ce.PREFIX_OPTION, we = {
  expanded: {
    type: o.bool,
    default: void 0
  },
  selected: {
    type: o.bool,
    default: void 0
  },
  checked: {
    type: o.bool,
    default: void 0
  },
  halfChecked: {
    type: o.bool,
    default: void 0
  },
  active: {
    type: o.bool,
    default: void 0
  },
  disabled: {
    type: o.bool,
    default: void 0
  },
  loaded: {
    type: o.bool,
    default: void 0
  },
  loading: {
    type: o.bool,
    default: void 0
  },
  isLeaf: {
    type: o.bool,
    default: void 0
  },
  pos: o.string,
  icon: o.node,
  directory: {
    type: o.bool,
    default: void 0
  },
  keyword: o.string,
  treeNodeFilterProp: o.string,
  selectedKey: o.string,
  motionKey: o.oneOfType([o.string, o.array]),
  isEnd: o.array,
  showLine: o.bool,
  eventKey: String,
  label: o.node,
  data: Object,
  children: Object,
  nodeInstance: o.node,
  emptyContent: o.node,
  filtered: [String, Boolean],
  level: Number,
  empty: Boolean,
  style: [Object, String],
  display: o.any,
  value: [Object, Array, String]
}, Oe = {
  selectedKey: "",
  motionKey: ""
}, Ke = ye(we, Oe), Je = /* @__PURE__ */ fe({
  props: {
    ...Ke
  },
  name: "TreeNode",
  setup(l, {}) {
    ge();
    const u = me(), {
      context: r
    } = Se();
    be({});
    const L = (e) => {
      const {
        onNodeSelect: n
      } = r.value;
      n(e, l);
    }, R = ke(L, 500, {
      leading: !0,
      trailing: !1
    }), m = (e) => {
      const {
        onNodeExpand: n
      } = r.value;
      e && e.stopPropagation(), e.stopImmediatePropagation(), n(e, l);
    }, C = (e) => {
      var a;
      if (D())
        return;
      const {
        onNodeCheck: n
      } = r.value;
      e.stopPropagation(), (a = e.stopImmediatePropagation) == null || a.call(e), n(e, l);
    }, G = (e) => {
      j(e) && C(e);
    }, S = (e) => {
      const {
        onNodeRightClick: n
      } = r.value;
      n(e, l);
    }, k = (e) => {
      const {
        expandAction: n
      } = r.value;
      if (n === "doubleClick") {
        R(e);
        return;
      }
      L(e), n === "click" && m(e);
    }, H = (e) => {
      j(e) && k(e);
    }, N = (e) => {
      const {
        expandAction: n,
        onNodeDoubleClick: a
      } = r.value;
      e.stopPropagation(), e.stopImmediatePropagation(), z(a) && a(e, l), n === "doubleClick" && m(e);
    }, V = (e) => {
      const {
        onNodeDragStart: n
      } = r.value;
      e.stopPropagation(), n(e, {
        ...l,
        nodeInstance: u.value
      });
      try {
        e.dataTransfer.setData("text/plain", "");
      } catch {
      }
    }, W = (e) => {
      const {
        onNodeDragEnter: n
      } = r.value;
      e.preventDefault(), e.stopPropagation(), n(e, {
        ...l,
        nodeInstance: u.value
      });
    }, X = (e) => {
      const {
        onNodeDragOver: n
      } = r.value;
      e.preventDefault(), e.stopPropagation(), n(e, {
        ...l,
        nodeInstance: u.value
      });
    }, _ = (e) => {
      const {
        onNodeDragLeave: n
      } = r.value;
      e.stopPropagation(), n(e, {
        ...l,
        nodeInstance: u.value
      });
    }, q = (e) => {
      const {
        onNodeDragEnd: n
      } = r.value;
      e.stopPropagation(), n(e, {
        ...l,
        nodeInstance: u.value
      });
    }, J = (e) => {
      const {
        onNodeDrop: n
      } = r.value;
      e.preventDefault(), e.stopPropagation(), n(e, {
        ...l,
        nodeInstance: u.value
      });
    }, Q = () => {
      const {
        children: e
      } = l;
      return e || [];
    }, $ = () => {
      const {
        isLeaf: e,
        loaded: n
      } = l, {
        loadData: a
      } = r.value, i = Q().length !== 0;
      return e === !1 ? !1 : e || !a && !i || a && n && !i;
    }, D = () => {
      const {
        disabled: e
      } = l, {
        treeDisabled: n
      } = r.value;
      return e === !1 ? !1 : !!(n || e);
    };
    function T() {
      const e = !$(), {
        loading: n,
        expanded: a,
        showLine: i
      } = l;
      return n ? s(Ee, {
        wrapperClassName: `${t}-spin-icon`
      }, null) : e ? s($e, {
        role: "button",
        "aria-label": `${a ? "Expand" : "Collapse"} the tree item`,
        className: `${t}-expand-icon`,
        size: "small",
        onClick: m
      }, null) : i ? Y() : s("span", {
        class: `${t}-empty-icon`
      }, null);
    }
    function U() {
      const {
        checked: e,
        halfChecked: n,
        eventKey: a
      } = l, i = D();
      return s("div", {
        role: "none",
        onClick: C,
        onKeypress: G
      }, [s(Ie, {
        "aria-label": "Toggle the checked state of checkbox",
        value: a,
        indeterminate: n,
        checked: e,
        disabled: !!i
      }, null)]);
    }
    const Y = () => $() ? s("span", {
      class: y(`${t}-switcher`)
    }, [s("span", {
      class: `${t}-switcher-leaf-line`
    }, null)]) : null;
    function Z() {
      const {
        directory: e,
        treeIcon: n
      } = r.value, {
        expanded: a,
        icon: i,
        data: b
      } = l;
      return i || (n ? typeof n == "function" ? n(l) : n : e ? $() ? s(De, {
        className: `${t}-item-icon`
      }, null) : a ? s(xe, {
        className: `${t}-item-icon`
      }, null) : s(Pe, {
        className: `${t}-item-icon`
      }, null) : null);
    }
    function ee() {
      const {
        emptyContent: e
      } = l, n = y(t, {
        [`${t}-empty`]: !0
      });
      return s("ul", {
        class: n
      }, [s("li", {
        class: `${t}-label ${t}-label-empty`,
        "x-semi-prop": "emptyContent"
      }, [e])]);
    }
    const ne = () => {
      const {
        renderLabel: e
      } = r.value, {
        label: n,
        keyword: a,
        data: i,
        filtered: b,
        treeNodeFilterProp: x
      } = l;
      return z(e) ? e(n, i, a) : M(n) && b && a ? Le({
        sourceString: n,
        searchWords: [a],
        option: {
          highlightTag: "span",
          highlightClassName: `${t}-highlight`
        }
      }) : n;
    };
    return () => {
      const {
        eventKey: e,
        expanded: n,
        selected: a,
        checked: i,
        halfChecked: b,
        loading: x,
        active: te,
        level: f,
        empty: oe,
        filtered: ae,
        treeNodeFilterProp: Fe,
        // eslint-disable-next-line no-unused-vars
        display: Be,
        style: h,
        isEnd: P,
        showLine: le,
        ...g
      } = l;
      if (oe)
        return ee();
      const {
        multiple: w,
        draggable: d,
        renderFullLabel: p,
        dragOverNodeKey: I,
        dropPosition: E,
        labelEllipsis: re
      } = r.value, se = P[P.length - 1], c = D(), ie = I === e && E === 0, O = I === e && E === -1, K = I === e && E === 1, F = y(t, {
        [`${t}-level-${f + 1}`]: !0,
        [`${t}-fullLabel-level-${f + 1}`]: p,
        [`${t}-collapsed`]: !n,
        [`${t}-disabled`]: !!c,
        [`${t}-selected`]: a,
        [`${t}-active`]: !w && te,
        [`${t}-ellipsis`]: re,
        [`${t}-drag-over`]: !c && ie,
        [`${t}-draggable`]: !c && d && !p,
        // When draggable + renderFullLabel is enabled, the default style
        [`${t}-fullLabel-draggable`]: !c && d && p,
        // When draggable + renderFullLabel is turned on, the style of dragover
        [`${t}-fullLabel-drag-over-gap-top`]: !c && O && p,
        [`${t}-fullLabel-drag-over-gap-bottom`]: !c && K && p,
        [`${t}-tree-node-last-leaf`]: se
      }), de = {
        onClick: k,
        onContextMenu: S,
        onDoubleClick: N,
        className: F,
        onExpand: m,
        data: g.data,
        level: f,
        onCheck: C,
        style: h,
        expandIcon: T(),
        checkStatus: {
          checked: i,
          halfChecked: b
        },
        expandStatus: {
          expanded: n,
          loading: x
        },
        filtered: ae,
        searchWord: g.keyword
      }, B = {
        onDblclick: N,
        onDragstart: d ? V : void 0,
        onDragenter: d ? W : void 0,
        onDragover: d ? X : void 0,
        onDragleave: d ? _ : void 0,
        onDrop: d ? J : void 0,
        onDragend: d ? q : void 0,
        draggable: !c && d || void 0
      };
      if (p) {
        const v = p({
          ...de
        });
        return d ? he(v, {
          ref: u,
          ...B
        }) : Ne(h) ? v : cloneElement(v, {
          style: {
            ...A(v, ["props", "style"]),
            ...h
          }
        });
      }
      const ce = y(`${t}-label`, {
        [`${t}-drag-over-gap-top`]: !c && O,
        [`${t}-drag-over-gap-bottom`]: !c && K
      }), ue = A(g, ["data", "length"]), pe = M(g.pos) ? Number(g.pos.split("-")[f + 1]) + 1 : 1;
      return s("li", ve({
        class: F,
        role: "treeitem",
        "aria-disabled": c,
        "aria-checked": i,
        "aria-selected": a,
        "aria-setsize": ue,
        "aria-posinset": pe,
        "aria-expanded": n,
        "aria-level": f + 1,
        "data-key": e,
        ref: u,
        style: h
      }, {
        onClick: k,
        onKeypress: H,
        onContextmenu: S,
        onDblclick: N,
        ...B
      }), [s(Te, {
        showLine: le,
        prefixcls: t,
        level: f,
        isEnd: P
      }, null), T(), s("span", {
        class: ce
      }, [w ? U() : null, Z(), s("span", {
        class: `${t}-label-text`
      }, [ne()])])]);
    };
  }
});
export {
  Je as default,
  Ke as vuePropsType
};
//# sourceMappingURL=treeNode.js.map
