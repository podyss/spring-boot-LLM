import { defineComponent as S, useSlots as E, reactive as K, watch as q, createVNode as D, isVNode as k } from "vue";
import { isEqual as h } from "lodash";
import b from "./collapse";
function j(t) {
  return typeof t == "function" || Object.prototype.toString.call(t) === "[object Object]" && !k(t);
}
const g = (t) => t.key, A = {
  flattenNodes: {
    type: Array,
    required: !0
  },
  motionKeys: {
    type: Object,
    required: !0
  },
  motionType: {
    type: String,
    required: !1
  },
  flattenList: {
    type: Array,
    required: !1
  },
  searchTargetIsDeep: Boolean,
  renderTreeNode: {
    type: Function,
    required: !0
  },
  onMotionEnd: {
    type: Function,
    required: !1
  },
  role: String
}, O = /* @__PURE__ */ S({
  props: {
    ...A
  },
  name: "NodeList",
  setup(t, {}) {
    E();
    const s = K({
      transitionNodes: []
    });
    function T(n) {
      const {
        flattenNodes: o = [],
        motionKeys: i,
        motionType: c,
        flattenList: l = []
      } = n, f = !h(s.cachedMotionKeys, i) || !h(s.cachedData.map((r) => r.key), o.map((r) => r.key)), y = [...i];
      if (!f || !y.length)
        return null;
      const e = [], d = [];
      let a = 0, u = {};
      return (c === "hide" && l ? l : o).forEach((r, N) => {
        const m = g(r);
        i.has(m) ? (d.push(r), m === y[0] && (a = N)) : e.push(r);
      }), e.splice(a, 0, d), u = {
        transitionNodes: e,
        cachedData: o,
        cachedMotionKeys: i,
        cachedMotionType: c
      }, u;
    }
    q([() => t.flattenNodes, () => t.motionKeys, () => t.motionType, () => t.flattenList], () => {
      const n = T({
        ...t
      });
      n && Object.keys(n).forEach((o) => {
        s[o] = n[o];
      });
    }, {
      immediate: !0
    });
    const M = () => {
      typeof t.onMotionEnd == "function" && t.onMotionEnd(), s.transitionNodes = [];
    };
    return () => {
      const {
        flattenNodes: n,
        motionType: o,
        searchTargetIsDeep: i,
        renderTreeNode: c
      } = t, {
        transitionNodes: l
      } = s;
      return /*@ts-ignore*/ (l.length && !i ? l : n).map((e) => {
        const d = Array.isArray(e);
        if (d && !e.length)
          return null;
        if (d && e.length) {
          let a;
          const u = g(e[0]);
          return D(b, {
            motionType: o === "show" ? "enter" : "leave",
            key: `motion-${u}`,
            onMotionEnd: M,
            motion: !!o
          }, j(a = e.map((p) => c(p))) ? a : {
            default: () => [a]
          });
        }
        return c(e);
      });
    };
  }
});
export {
  O as default,
  A as vuePropsType
};
//# sourceMappingURL=nodeList.js.map
