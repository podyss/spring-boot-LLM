{"version":3,"file":"nodeList.js","sources":["../../src/components/tree/nodeList.tsx"],"sourcesContent":["import { isEqual } from 'lodash';\nimport Collapse from './collapse';\nimport type { FlattenNode, NodeListProps, NodeListState, TransitionNodes } from './interface';\nimport {\n  type ComponentObjectPropsOptions,\n  type CSSProperties,\n  defineComponent,\n  h,\n  type PropType, type Reactive,\n  reactive,\n  useSlots,\n  type VNode,\n  watch,\n} from 'vue';\nimport { CombineProps } from '../interface';\n\nconst getTreeNodeKey = (treeNode: FlattenNode) => {\n  return treeNode.key;\n};\n\nexport const vuePropsType: CombineProps<NodeListProps> = {\n  flattenNodes: {\n    type: Array,\n    required: true\n  },\n  motionKeys: {\n    type: Object,\n    required: true\n  },\n  motionType: {\n    type: String,\n    required: false\n  },\n  flattenList: {\n    type: Array,\n    required: false\n  },\n  searchTargetIsDeep: Boolean,\n  renderTreeNode: {\n    type: Function as PropType<NodeListProps['renderTreeNode']>,\n    required: true\n  },\n  onMotionEnd: {\n    type: Function as PropType<NodeListProps['onMotionEnd']>,\n    required: false\n  },\n  role: String,\n};\nconst NodeList = defineComponent({\n  props: { ...vuePropsType },\n  name: 'NodeList',\n  setup(props, {}) {\n    const slots = useSlots();\n\n    const state = reactive<NodeListState>({\n      transitionNodes: [],\n    });\n\n    function getDerivedStateFromProps(props: NodeListProps) {\n      const { flattenNodes = [], motionKeys, motionType, flattenList = [] } = props;\n      const hasChanged =\n        !isEqual(state.cachedMotionKeys, motionKeys) ||\n        !isEqual(\n          (state.cachedData as unknown as NodeListState['cachedData']).map((i) => i.key),\n          flattenNodes.map((i) => i.key)\n        );\n      const motionArr = [...motionKeys];\n      if (!hasChanged || !motionArr.length) {\n        return null;\n      }\n      const transitionNodes: TransitionNodes<FlattenNode> = [];\n      const transitionRange: FlattenNode[] = [];\n      let rangeStart = 0;\n      let newState = {};\n      const lookUpTarget = motionType === 'hide' && flattenList ? flattenList : flattenNodes;\n      lookUpTarget.forEach((treeNode, ind) => {\n        const nodeKey = getTreeNodeKey(treeNode);\n        if (motionKeys.has(nodeKey)) {\n          transitionRange.push(treeNode);\n          if (nodeKey === motionArr[0]) {\n            rangeStart = ind;\n          }\n        } else {\n          transitionNodes.push(treeNode);\n        }\n      });\n      transitionNodes.splice(rangeStart, 0, transitionRange);\n      newState = {\n        transitionNodes,\n        cachedData: flattenNodes,\n        cachedMotionKeys: motionKeys,\n        cachedMotionType: motionType,\n      };\n      return newState;\n    }\n\n    watch(\n      [() => props.flattenNodes, () => props.motionKeys, () => props.motionType, () => props.flattenList],\n      () => {\n        const newState = getDerivedStateFromProps({ ...props });\n        newState &&\n          Object.keys(newState).forEach((key) => {\n            state[key] = newState[key];\n          });\n      },\n      { immediate: true }\n    );\n\n    const onMotionEnd = () => {\n      typeof props.onMotionEnd === 'function' && props.onMotionEnd();\n      state.transitionNodes = [];\n    };\n\n    return () => {\n      const { flattenNodes, motionType, searchTargetIsDeep, renderTreeNode } = props;\n      const { transitionNodes } = state;\n      const mapData: TransitionNodes<FlattenNode> | FlattenNode[] =\n        //@ts-ignore\n        transitionNodes.length && !searchTargetIsDeep ? transitionNodes  : flattenNodes;\n      const options = mapData.map((treeNode) => {\n        const isMotionNode = Array.isArray(treeNode);\n        if (isMotionNode && !(treeNode as FlattenNode[]).length) {\n          return null;\n        }\n        if (isMotionNode && (treeNode as FlattenNode[]).length) {\n          const nodeKey = getTreeNodeKey(treeNode[0]);\n          return (\n            <Collapse\n              motionType={motionType === 'show' ? 'enter' : 'leave'}\n              key={`motion-${nodeKey}`}\n              onMotionEnd={onMotionEnd}\n              motion={Boolean(motionType)}\n            >\n              {treeNode.map((node) => {\n                return renderTreeNode(node);\n              })}\n            </Collapse>\n          );\n        }\n        return renderTreeNode(treeNode as FlattenNode);\n      });\n      return options as VNode[];\n    };\n  },\n});\n\nexport default NodeList;\n"],"names":["_isSlot","s","Object","prototype","toString","call","_isVNode","getTreeNodeKey","treeNode","key","vuePropsType","flattenNodes","type","Array","required","motionKeys","motionType","String","flattenList","searchTargetIsDeep","Boolean","renderTreeNode","Function","onMotionEnd","role","NodeList","defineComponent","props","name","setup","useSlots","state","reactive","transitionNodes","getDerivedStateFromProps","hasChanged","isEqual","cachedMotionKeys","cachedData","map","i","motionArr","length","transitionRange","rangeStart","newState","lookUpTarget","forEach","ind","nodeKey","has","push","splice","cachedMotionType","watch","keys","immediate","isMotionNode","isArray","_slot","_createVNode","Collapse","node","default"],"mappings":";;;AAaa,SAAAA,EAAAC,GAAA;AAAA,SAAA,OAAAA,KAAA,cAAAC,OAAAC,UAAAC,SAAAC,KAAAJ,CAAA,MAAAK,qBAAAA,CAAAA,EAAAL,CAAA;AAAA;AAGb,MAAMM,IAAkBC,CAAAA,MACfA,EAASC,KAGLC,IAA4C;AAAA,EACvDC,cAAc;AAAA,IACZC,MAAMC;AAAAA,IACNC,UAAU;AAAA,EACX;AAAA,EACDC,YAAY;AAAA,IACVH,MAAMV;AAAAA,IACNY,UAAU;AAAA,EACX;AAAA,EACDE,YAAY;AAAA,IACVJ,MAAMK;AAAAA,IACNH,UAAU;AAAA,EACX;AAAA,EACDI,aAAa;AAAA,IACXN,MAAMC;AAAAA,IACNC,UAAU;AAAA,EACX;AAAA,EACDK,oBAAoBC;AAAAA,EACpBC,gBAAgB;AAAA,IACdT,MAAMU;AAAAA,IACNR,UAAU;AAAA,EACX;AAAA,EACDS,aAAa;AAAA,IACXX,MAAMU;AAAAA,IACNR,UAAU;AAAA,EACX;AAAA,EACDU,MAAMP;AACR,GACMQ,IAAWC,gBAAAA,EAAgB;AAAA,EAC/BC,OAAO;AAAA,IAAE,GAAGjB;AAAAA,EAAc;AAAA,EAC1BkB,MAAM;AAAA,EACNC,MAAMF,GAAO,IAAI;AACDG,IAAAA,EAAU;AAExB,UAAMC,IAAQC,EAAwB;AAAA,MACpCC,iBAAiB,CAAA;AAAA,IACnB,CAAC;AAED,aAASC,EAAyBP,GAAsB;AACtD,YAAM;AAAA,QAAEhB,cAAAA,IAAe,CAAE;AAAA,QAAEI,YAAAA;AAAAA,QAAYC,YAAAA;AAAAA,QAAYE,aAAAA,IAAc,CAAA;AAAA,MAAI,IAAGS,GAClEQ,IACJ,CAACC,EAAQL,EAAMM,kBAAkBtB,CAAU,KAC3C,CAACqB,EACEL,EAAMO,WAAsDC,IAAKC,CAAAA,MAAMA,EAAE/B,GAAG,GAC7EE,EAAa4B,IAAKC,CAAAA,MAAMA,EAAE/B,GAAG,CAC/B,GACIgC,IAAY,CAAC,GAAG1B,CAAU;AAChC,UAAI,CAACoB,KAAc,CAACM,EAAUC;AAC5B,eAAO;AAET,YAAMT,IAAgD,CAAA,GAChDU,IAAiC,CAAA;AACvC,UAAIC,IAAa,GACbC,IAAW,CAAA;AAEfC,cADqB9B,MAAe,UAAUE,IAAcA,IAAcP,GAC7DoC,QAAQ,CAACvC,GAAUwC,MAAQ;AACtC,cAAMC,IAAU1C,EAAeC,CAAQ;AACvC,QAAIO,EAAWmC,IAAID,CAAO,KACxBN,EAAgBQ,KAAK3C,CAAQ,GACzByC,MAAYR,EAAU,CAAC,MACzBG,IAAaI,MAGff,EAAgBkB,KAAK3C,CAAQ;AAAA,MAEjC,CAAC,GACDyB,EAAgBmB,OAAOR,GAAY,GAAGD,CAAe,GACrDE,IAAW;AAAA,QACTZ,iBAAAA;AAAAA,QACAK,YAAY3B;AAAAA,QACZ0B,kBAAkBtB;AAAAA,QAClBsC,kBAAkBrC;AAAAA,SAEb6B;AAAAA,IACT;AAEAS,IAAAA,EACE,CAAC,MAAM3B,EAAMhB,cAAc,MAAMgB,EAAMZ,YAAY,MAAMY,EAAMX,YAAY,MAAMW,EAAMT,WAAW,GAClG,MAAM;AACJ,YAAM2B,IAAWX,EAAyB;AAAA,QAAE,GAAGP;AAAAA,MAAM,CAAC;AACtDkB,MAAAA,KACE3C,OAAOqD,KAAKV,CAAQ,EAAEE,QAAStC,CAAAA,MAAQ;AACrCsB,QAAAA,EAAMtB,CAAG,IAAIoC,EAASpC,CAAG;AAAA,MAC3B,CAAC;AAAA,IACL,GACA;AAAA,MAAE+C,WAAW;AAAA,IAAK,CACpB;AAEA,UAAMjC,IAAcA,MAAM;AACxB,aAAOI,EAAMJ,eAAgB,cAAcI,EAAMJ,YAAW,GAC5DQ,EAAME,kBAAkB;;AAG1B,WAAO,MAAM;AACX,YAAM;AAAA,QAAEtB,cAAAA;AAAAA,QAAcK,YAAAA;AAAAA,QAAYG,oBAAAA;AAAAA,QAAoBE,gBAAAA;AAAAA,MAAgB,IAAGM,GACnE;AAAA,QAAEM,iBAAAA;AAAAA,MAAiB,IAAGF;AA0B5B,6BAvBEE,EAAgBS,UAAU,CAACvB,IAAqBc,IAAmBtB,GAC7C4B,IAAK/B,CAAAA,MAAa;AACxC,cAAMiD,IAAe5C,MAAM6C,QAAQlD,CAAQ;AAC3C,YAAIiD,KAAgB,CAAEjD,EAA2BkC;AAC/C,iBAAO;AAET,YAAIe,KAAiBjD,EAA2BkC,QAAQ;AAAA,cAAAiB;AACtD,gBAAMV,IAAU1C,EAAeC,EAAS,CAAC,CAAC;AAC1C,iBAAAoD,EAAAC,GAAA;AAAA,YAAA,YAEgB7C,MAAe,SAAS,UAAU;AAAA,YAAO,KAChD,UAAUiC,CAAO;AAAA,YAAE,aACX1B;AAAAA,YAAW,QAChBH,EAAQJ;AAAAA,UAAWhB,GAAAA,EAAA2D,IAE1BnD,EAAS+B,IAAKuB,CAAAA,MACNzC,EAAeyC,CAAI,CAC3B,CAAC,IAAAH,IAAA;AAAA,YAAAI,SAAAA,MAAA,CAAAJ,CAAA;AAAA,UAAA,CAAA;AAAA,QAGR;AACA,eAAOtC,EAAeb,CAAuB;AAAA,MAC/C,CAAC;AAAA;EAGL;AACF,CAAC;"}