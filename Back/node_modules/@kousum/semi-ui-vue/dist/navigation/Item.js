import { defineComponent as q, reactive as J, createVNode as c, Fragment as Q, mergeProps as F, isVNode as Y, cloneVNode as ee } from "vue";
import { useBaseComponent as te } from "../_base/baseComponent";
import * as o from "../PropTypes";
import K from "classnames";
import { noop as N, times as oe } from "lodash";
import j from '@douyinfe/semi-foundation/lib/es/utils/isNullOrUndefined';
import { cloneDeep as le, isSemiIcon as ne } from "../_utils";
import ae from '@douyinfe/semi-foundation/lib/es/navigation/itemFoundation';
import { cssClasses as B, strings as s } from '@douyinfe/semi-foundation/lib/es/navigation/constants';
import se from "../tooltip";
import { DropdownItem as ie } from "../dropdown";
import { useNavContext as re } from "./nav-context/Consumer";
import ue from '@douyinfe/semi-foundation/lib/es/utils/getDataAttr';
function A(l) {
  return typeof l == "function" || Object.prototype.toString.call(l) === "[object Object]" && !Y(l);
}
const a = `${B.PREFIX}-item`, ce = {
  text: o.node,
  itemKey: [o.string, o.number],
  onClick: {
    type: o.func,
    default: N
  },
  onMouseEnter: {
    type: o.func,
    default: N
  },
  onMouseLeave: {
    type: o.func,
    default: N
  },
  icon: o.node,
  className: o.string,
  toggleIcon: o.string,
  style: o.object,
  forwardRef: {
    type: o.func,
    default: N
  },
  indent: {
    type: [o.bool, o.number],
    default: !1
  },
  isCollapsed: {
    type: o.bool,
    default: !1
  },
  // Is it in a state of folding to the side
  isSubNav: {
    type: o.bool,
    default: !1
  },
  // Whether to navigate for children
  link: o.string,
  linkOptions: o.object,
  disabled: {
    type: o.bool,
    default: !1
  },
  items: Array,
  level: Number,
  maxHeight: Number,
  tabIndex: {
    type: o.number,
    default: 0
  },
  tooltipHideDelay: o.number,
  tooltipShowDelay: o.number
}, he = /* @__PURE__ */ q({
  props: {
    ...ce
  },
  name: "NavItem",
  setup(l, {
    attrs: de,
    slots: h
  }) {
    const {
      context: t
    } = re(), D = J({
      tooltipShow: !1
    }), {
      adapter: V
    } = te(l, D), $ = new ae(I());
    function I() {
      return {
        ...V(),
        cloneDeep: le,
        updateTooltipShow: (e) => D.tooltipShow = e,
        updateSelected: (e) => g("updateSelectedKeys", [l.itemKey]),
        updateGlobalSelectedKeys: (e) => g("updateSelectedKeys", [...e]),
        getSelectedKeys: () => t.value && t.value.selectedKeys,
        getSelectedKeysIsControlled: () => t.value && t.value.selectedKeysIsControlled,
        notifyGlobalOnSelect: (...e) => g("onSelect", ...e),
        notifyGlobalOnClick: (...e) => g("onClick", ...e),
        notifyClick: (...e) => l.onClick(...e),
        notifyMouseEnter: (...e) => l.onMouseEnter(...e),
        notifyMouseLeave: (...e) => l.onMouseLeave(...e),
        getIsCollapsed: () => l.isCollapsed || !!(t.value && t.value.isCollapsed) || !1,
        getSelected: () => !!(t.value && t.value.selectedKeys && t.value.selectedKeys.includes(l.itemKey)),
        getIsOpen: () => !!(t.value && t.value.openKeys && t.value.openKeys.includes(l.itemKey))
      };
    }
    function g(e, ...i) {
      return e && t.value && typeof t.value[e] == "function" ? t.value[e](...i) : null;
    }
    function b(e, i, u = !1, p = 0) {
      if (l.isSubNav || !e && t.value.mode === s.MODE_HORIZONTAL)
        return null;
      let n = "large";
      i === s.ICON_POS_RIGHT && (n = "default");
      const y = K(`${a}-icon`, {
        [`${a}-icon-toggle-${t.value.toggleIconPosition}`]: u,
        [`${a}-icon-info`]: !u
      });
      return c("i", {
        class: y,
        key: p
      }, [ne(e) ? ee(e, n ? {
        size: n
      } : {}) : e]);
    }
    const P = (e) => {
      l.forwardRef && l.forwardRef(e);
    }, z = (e) => {
      const {
        text: i,
        tooltipHideDelay: u,
        tooltipShowDelay: p
      } = l, n = u ?? t.value.tooltipHideDelay, y = p ?? t.value.tooltipShowDelay;
      return c(se, {
        content: i,
        position: "right",
        trigger: "hover",
        mouseEnterDelay: y,
        mouseLeaveDelay: n
      }, A(e) ? e : {
        default: () => [e]
      });
    }, x = (e) => {
      $.handleClick(e);
    }, E = (e) => $.handleKeyPress(e);
    return () => {
      var H;
      const {
        text: e,
        icon: i,
        toggleIcon: u,
        className: p,
        isSubNav: n,
        style: y,
        indent: T,
        onMouseEnter: M,
        onMouseLeave: w,
        link: k,
        linkOptions: W,
        disabled: v,
        level: R = 0,
        tabIndex: X
      } = l, G = (H = h.default) == null ? void 0 : H.call(h), {
        mode: L,
        isInSubNav: C,
        prefixCls: Z,
        limitIndent: U
      } = t.value, d = I().getIsCollapsed(), O = I().getSelected();
      let r = null;
      if (!j(G))
        r = G;
      else {
        let m = null;
        if (L === s.MODE_VERTICAL && !U && !d) {
          const S = i && !T ? R : R - 1;
          m = oe(S, (_) => b(null, s.ICON_POS_RIGHT, !1, _));
        }
        r = c(Q, null, [m, t.value.toggleIconPosition === s.TOGGLE_ICON_LEFT && b(u, s.ICON_POS_RIGHT, !0, "key-toggle-pos-right"), i || T || C ? b(i, s.ICON_POS_LEFT, !1, "key-position-left") : null, j(e) ? "" : c("span", {
          class: `${B.PREFIX}-item-text`
        }, [e]), t.value.toggleIconPosition === s.TOGGLE_ICON_RIGHT && b(u, s.ICON_POS_RIGHT, !0, "key-toggle-pos-right")]);
      }
      typeof k == "string" && (r = c("a", F({
        class: `${Z}-item-link`,
        href: k,
        tabindex: -1
      }, W), [r]));
      let f = "";
      if (C && (d || L === s.MODE_HORIZONTAL)) {
        const m = K({
          [a]: !0,
          [`${a}-sub`]: n,
          [`${a}-selected`]: O,
          [`${a}-collapsed`]: d,
          [`${a}-disabled`]: v
        });
        f = c(ie, {
          selected: O,
          active: O,
          ref: P,
          className: m,
          onClick: x,
          onMouseenter: M,
          onMouseleave: w,
          disabled: v,
          onKeyDown: E
        }, A(r) ? r : {
          default: () => [r]
        });
      } else {
        const m = K(`${p || `${a}-normal`}`, {
          [a]: !0,
          [`${a}-sub`]: n,
          [`${a}-selected`]: O && !n,
          [`${a}-collapsed`]: d,
          [`${a}-disabled`]: v,
          [`${a}-has-link`]: typeof k == "string"
        }), S = {
          "aria-disabled": v
        };
        if (n) {
          const _ = I().getIsOpen();
          S["aria-expanded"] = _;
        }
        f = c("li", F({
          role: n ? null : "menuitem",
          tabindex: n ? -1 : X
        }, S, {
          style: y,
          ref: P,
          class: m,
          onClick: x,
          onMouseenter: M,
          onMouseleave: w,
          onKeypress: E
        }, ue(l)), [r]);
      }
      return (d && !C && !n || d && n && v) && (f = z(f)), typeof t.value.renderWrapper == "function" ? t.value.renderWrapper({
        itemElement: f,
        isSubNav: n,
        isInSubNav: C,
        props: l
      }) : f;
    };
  }
});
export {
  he as default,
  ce as vuePropsType
};
//# sourceMappingURL=Item.js.map
