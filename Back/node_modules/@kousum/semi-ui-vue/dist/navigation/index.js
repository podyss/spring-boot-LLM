import { defineComponent as B, useSlots as W, reactive as he, watch as D, watchEffect as Ce, isVNode as j, createVNode as a, mergeProps as C, Fragment as Ke } from "vue";
import { useBaseComponent as ge, useHasInProps as Se } from "../_base/baseComponent";
import * as t from "../PropTypes";
import { vuePropsMake as be } from "../PropTypes";
import k from "classnames";
import { noop as A, get as V } from "lodash";
import ve from '@douyinfe/semi-foundation/lib/es/navigation/foundation';
import { numbers as N, cssClasses as Oe, strings as Ie } from '@douyinfe/semi-foundation/lib/es/navigation/constants';
import Y from "./SubNav";
import R from "./Item";
import P from "./Footer";
import E from "./Header";
import De from "./nav-context";
import '@douyinfe/semi-foundation/lib/es/navigation/navigation.css';
import Ae from "../locale/localeConsumer";
import { getFragmentChildren as Ne } from "../_utils";
function F(n) {
  return typeof n == "function" || Object.prototype.toString.call(n) === "[object Object]" && !j(n);
}
const Pe = {
  // Initial expanded SubNav navigation key array
  defaultOpenKeys: Array,
  openKeys: Array,
  // Initial selected navigation key array
  defaultSelectedKeys: Array,
  subDropdownProps: Object,
  selectedKeys: Array,
  // Navigation type, now supports vertical, horizontal
  mode: String,
  // Triggered when selecting a navigation item
  onSelect: t.func,
  // Triggered when clicking a navigation item
  onClick: t.func,
  // SubNav expand/close callback
  onOpenChange: t.func,
  // Array of options (nested options can continue)
  items: t.array,
  // Is it in the state of being stowed to the sidebar
  isCollapsed: {
    type: t.bool,
    default: void 0
  },
  defaultIsCollapsed: {
    type: t.bool,
    default: void 0
  },
  onCollapseChange: t.func,
  multiple: {
    type: t.bool,
    default: void 0
  },
  onDeselect: t.func,
  subNavMotion: [t.bool, t.object, t.func],
  subNavCloseDelay: t.number,
  subNavOpenDelay: t.number,
  tooltipShowDelay: t.number,
  tooltipHideDelay: t.number,
  children: t.node,
  style: t.object,
  bodyStyle: t.object,
  className: t.string,
  toggleIconPosition: t.string,
  prefixCls: t.string,
  header: t.node,
  footer: t.node,
  limitIndent: {
    type: t.bool,
    default: void 0
  },
  getPopupContainer: t.func,
  expandIcon: t.node,
  renderWrapper: t.func
}, Ee = {
  subNavCloseDelay: N.DEFAULT_SUBNAV_CLOSE_DELAY,
  subNavOpenDelay: N.DEFAULT_SUBNAV_OPEN_DELAY,
  tooltipHideDelay: N.DEFAULT_TOOLTIP_HIDE_DELAY,
  tooltipShowDelay: N.DEFAULT_TOOLTIP_SHOW_DELAY,
  onCollapseChange: A,
  onSelect: A,
  onClick: A,
  onOpenChange: A,
  toggleIconPosition: "right",
  limitIndent: !0,
  prefixCls: Oe.PREFIX,
  subNavMotion: !0,
  // isOpen: false,
  mode: Ie.MODE_VERTICAL
  // defaultOpenKeys: [],
  // defaultSelectedKeys: [],
  // items: [],
}, z = be(Pe, Ee), we = /* @__PURE__ */ B({
  props: {
    ...z,
    children: Array
  },
  name: "NavigationIndex",
  setup(n, {
    slots: x
  }) {
    W();
    let S = !0;
    const s = he({
      isCollapsed: !1,
      itemKeysMap: {},
      items: [],
      openKeys: [],
      selectedKeys: []
    }), {
      adapter: L,
      isControlled: _,
      getDataAttr: X
    } = ge(n, s);
    let T = {
      isCollapsed: !!(_("isCollapsed") ? n.isCollapsed : n.defaultIsCollapsed),
      // calc state
      openKeys: [],
      items: [],
      itemKeysMap: {},
      // itemKey to parentKeys
      selectedKeys: []
    };
    Object.keys(T).forEach((e) => {
      s[e] = T[e];
    });
    function M(e) {
      return function(...o) {
        const l = new Set(s[e]);
        o.forEach((r) => r && l.add(r)), s[e] = Array.from(l);
      };
    }
    function H(e) {
      return function(...o) {
        const l = new Set(s[e]);
        o.forEach((r) => r && l.delete(r)), s[e] = Array.from(l);
      };
    }
    function Z() {
      return {
        ...L(),
        notifySelect: (...e) => n.onSelect(...e),
        notifyOpenChange: (...e) => n.onOpenChange(...e),
        setIsCollapsed: (e) => s.isCollapsed = e,
        notifyCollapseChange: (...e) => {
          n.onCollapseChange(...e);
        },
        updateItems: (e) => s.items = [...e],
        setItemKeysMap: (e) => s.itemKeysMap = {
          ...e
        },
        addSelectedKeys: M("selectedKeys"),
        removeSelectedKeys: H("selectedKeys"),
        /**
         * when `includeParentKeys` is `true`, select a nested nav item will select parent nav sub
         */
        updateSelectedKeys: (e, o = !0) => {
          let l = e;
          if (o) {
            const r = u.selectLevelZeroParentKeys(null, e);
            l = Array.from(new Set(e.concat(r)));
          }
          s.selectedKeys = l;
        },
        updateOpenKeys: (e) => s.openKeys = [...e],
        addOpenKeys: M("openKeys"),
        removeOpenKeys: H("openKeys"),
        setItemsChanged: (e) => {
          S = e;
        }
      };
    }
    const p = Z(), u = new ve(p);
    if (n.items && n.items.length || n.children) {
      const e = u.init("constructor");
      let o = {
        ...T,
        ...e
      };
      Object.keys(o).forEach((l) => {
        s[l] = o[l];
      });
    }
    D(() => n.isCollapsed, (e) => {
      s.isCollapsed = e, u.handleItemsChange(!1);
    }), D(() => n.selectedKeys, (e) => {
      if (e) {
        p.updateSelectedKeys(n.selectedKeys);
        const o = u.getWillOpenKeys(s.itemKeysMap);
        p.updateOpenKeys(o);
      }
    }), D(() => n.openKeys, (e) => {
      e && p.updateOpenKeys(n.openKeys);
    }), D([() => n.items], (e, o, l) => {
      u.init("");
    }, {}), Ce(() => {
      n.children && u.init("");
    });
    function U(e = [], o = 0) {
      const {
        expandIcon: l,
        subDropdownProps: r
      } = n;
      return a(Ke, null, [e.map((d, b) => {
        if (Array.isArray(d.items) && d.items.length) {
          let K;
          return a(Y, C({
            key: d.itemKey || String(o) + b
          }, d, {
            level: o,
            expandIcon: l,
            subDropdownProps: r
          }), F(K = U(d.items, o + 1)) ? K : {
            default: () => [K]
          });
        } else
          return a(R, C({
            key: d.itemKey || String(o) + b
          }, d, {
            level: o
          }), null);
      })]);
    }
    const q = () => {
      u.handleCollapseChange();
    };
    return () => {
      const e = n.children, {
        mode: o,
        onOpenChange: l,
        onSelect: r,
        onClick: $,
        style: d,
        className: b,
        subNavCloseDelay: K,
        subNavOpenDelay: G,
        subNavMotion: J,
        tooltipShowDelay: Q,
        tooltipHideDelay: ee,
        prefixCls: i,
        bodyStyle: te,
        footer: y,
        header: f,
        toggleIconPosition: ne,
        limitIndent: oe,
        renderWrapper: _e,
        getPopupContainer: Te,
        ...Fe
      } = p.getProps(), {
        selectedKeys: se,
        openKeys: le,
        items: ae,
        isCollapsed: v
      } = s, {
        updateOpenKeys: re,
        addOpenKeys: ie,
        removeOpenKeys: de,
        updateSelectedKeys: ce,
        addSelectedKeys: pe,
        removeSelectedKeys: ue
      } = p, ye = {
        ...d
      };
      let c = e;
      const O = [], I = [];
      if (j(y) ? O.push(a(P, {
        key: 0
      }, F(y) ? y : {
        default: () => [y]
      })) : y && typeof y == "object" && O.push(a(P, C({
        key: 0
      }, y), null)), j(f) ? I.push(a(E, {
        key: 0
      }, F(f) ? f : {
        default: () => [f]
      })) : f && typeof f == "object" && I.push(a(E, C({
        key: 0
      }, f), null)), Array.isArray(c) && c.length) {
        c = [...c];
        let g = c.length;
        for (let m = 0; m < g; m++) {
          const h = c[m];
          h.type === P || V(h, "type.elementType") === "NavFooter" ? (O.push(h), c.splice(m, 1), m--, g--) : (h.type === E || V(h, "type.elementType") === "NavHeader") && (I.push(h), c.splice(m, 1), m--, g--);
        }
      }
      const fe = k(i, b, {
        [`${i}-collapsed`]: v,
        [`${i}-horizontal`]: o === "horizontal",
        [`${i}-vertical`]: o === "vertical"
      }), me = k(`${i}-header-list-outer`, {
        [`${i}-header-list-outer-collapsed`]: v
      });
      return S && p.setCache("itemElems", U(ae)), a(Ae, {
        componentName: "Navigation"
      }, {
        default: (g) => a(De.Provider, {
          value: {
            subNavCloseDelay: K,
            subNavOpenDelay: G,
            subNavMotion: J,
            tooltipShowDelay: Q,
            tooltipHideDelay: ee,
            openKeys: le,
            openKeysIsControlled: _("openKeys") && o === "vertical" && !v,
            // canUpdateOpenKeys: mode === 'vertical' && !isCollapsed,
            canUpdateOpenKeys: !0,
            selectedKeys: se,
            selectedKeysIsControlled: _("selectedKeys"),
            isCollapsed: v,
            onCollapseChange: q,
            mode: o,
            onSelect: r,
            onOpenChange: l,
            updateOpenKeys: re,
            addOpenKeys: ie,
            removeOpenKeys: de,
            updateSelectedKeys: ce,
            addSelectedKeys: pe,
            removeSelectedKeys: ue,
            onClick: $,
            locale: g,
            prefixCls: i,
            toggleIconPosition: ne,
            limitIndent: oe
          }
        }, {
          default: () => [a("div", C({
            class: fe,
            style: ye
          }, X()), [a("div", {
            class: `${i}-inner`
          }, [a("div", {
            class: me
          }, [I, a("div", {
            style: te,
            class: `${i}-list-wrapper`
          }, [a("ul", {
            role: "menu",
            "aria-orientation": o,
            class: `${i}-list`
          }, [p.getCache("itemElems"), c])])]), O])])]
        })
      });
    };
  }
}), Le = /* @__PURE__ */ B({
  props: {
    ...z
  },
  name: "Navigation",
  setup(n, {}) {
    const x = W(), {
      getProps: S
    } = Se(), s = we;
    return () => {
      const L = Ne(x);
      return a(s, C(S(n), {
        children: L
      }), null);
    };
  }
}), w = Le;
w.Item = R;
w.Header = E;
w.Footer = P;
w.Sub = Y;
export {
  w as default,
  z as vuePropsType
};
//# sourceMappingURL=index.js.map
