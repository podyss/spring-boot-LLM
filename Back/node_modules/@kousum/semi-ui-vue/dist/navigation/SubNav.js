import { createVNode as n, defineComponent as Q, useSlots as w, ref as H, reactive as Y, mergeProps as ee, isVNode as A, cloneVNode as L } from "vue";
import { useBaseComponent as oe } from "../_base/baseComponent";
import * as t from "../PropTypes";
import { vuePropsMake as te } from "../PropTypes";
import D from "classnames";
import '@douyinfe/semi-foundation/lib/es/navigation/navigation.css';
import ne from '@douyinfe/semi-foundation/lib/es/utils/isNullOrUndefined';
import le from '@douyinfe/semi-foundation/lib/es/navigation/subNavFoundation';
import { numbers as se, strings as i, cssClasses as ie } from '@douyinfe/semi-foundation/lib/es/navigation/constants';
import { IconChevronUp as ae, IconChevronDown as E, IconChevronRight as $ } from "@kousum/semi-icons-vue";
import re from "./Item";
import ue, { DropdownMenu as de } from "../dropdown";
import pe from "./nav-context";
import { get as ce, times as fe } from "lodash";
import me from "../collapsible";
import ve from "../_cssAnimation";
import { useNavContext as Oe } from "./nav-context/Consumer";
function be(m) {
  return typeof m == "function" || Object.prototype.toString.call(m) === "[object Object]" && !A(m);
}
const Ce = {
  /**
   * Unique identification
   */
  itemKey: [t.string, t.number],
  /**
   * Copywriting
   */
  text: t.node,
  expandIcon: t.node,
  /**
   * Whether child navigation is expanded
   */
  isOpen: t.bool,
  /**
   * Whether it is in the state of being stowed to the sidebar
   */
  isCollapsed: t.bool,
  /**
   * Whether to keep the left Icon placeholder
   */
  indent: [t.bool, t.number],
  /**
   * The icon name of the right control switch (on and off status)
   */
  toggleIcon: t.node,
  style: t.object,
  /**
   * Icon name on the left
   */
  icon: t.node,
  /**
   * Maximum height (for animation)
   */
  maxHeight: t.number,
  onMouseEnter: t.func,
  onMouseLeave: t.func,
  // Is it disabled
  disabled: t.bool,
  level: t.number,
  dropdownStyle: t.object,
  className: t.string,
  dropdownProps: t.object,
  subDropdownProps: t.object
}, Ie = {
  level: 0,
  indent: !1,
  isCollapsed: !1,
  isOpen: !1,
  maxHeight: se.DEFAULT_SUBNAV_MAX_HEIGHT,
  toggleIcon: {
    open: n(ae, null, null),
    closed: n(E, null, null)
  },
  disabled: !1
}, ge = te(Ce, Ie), $e = /* @__PURE__ */ Q({
  props: {
    ...ge
  },
  name: "SubNav",
  setup(m, {}) {
    const K = w(), {
      context: o
    } = Oe(), _ = H(), G = H(), R = Y({
      isHovered: !1
    }), {
      adapter: k
    } = oe(m, R), b = V();
    b.setCache("firstMounted", !0);
    const T = new le(b), j = (e) => {
      G.value = e;
    }, U = (e) => {
      _.value = e;
    };
    function g(e, ...s) {
      return e && o.value && typeof o.value[e] == "function" ? o.value[e](...s) : null;
    }
    function V() {
      return {
        ...k(),
        updateIsHovered: (e) => R.isHovered = e,
        getOpenKeys: () => o.value && o.value.openKeys,
        getOpenKeysIsControlled: () => o.value && o.value.openKeysIsControlled,
        getCanUpdateOpenKeys: () => o.value && o.value.canUpdateOpenKeys,
        updateOpen: (e) => g(e ? "addOpenKeys" : "removeOpenKeys", m.itemKey),
        notifyGlobalOpenChange: (...e) => g("onOpenChange", ...e),
        notifyGlobalOnSelect: (...e) => g("onSelect", ...e),
        notifyGlobalOnClick: (...e) => g("onClick", ...e),
        getIsSelected: (e) => !!(!ne(e) && ce(o.value, "selectedKeys", []).includes(String(e))),
        getIsOpen: () => !!(o.value && o.value.openKeys && o.value.openKeys.includes(String(m.itemKey)))
      };
    }
    const Z = (e) => {
      T.handleClick(e, _.value);
    }, F = (e) => {
      T.handleKeyPress(e, _.value);
    }, z = (e) => T.handleDropdownVisibleChange(e);
    function y(e, s, v, r = !1, c = 0) {
      const {
        prefixCls: u
      } = o.value;
      let l = "large";
      s === i.ICON_POS_RIGHT && (l = "default");
      const a = D(`${u}-item-icon`, {
        [`${u}-item-icon-toggle-${o.value.toggleIconPosition}`]: r,
        [`${u}-item-icon-info`]: !r
      }), d = b.getIsOpen(), p = A(e) ? v ? n(ve, {
        animationState: d ? "enter" : "leave",
        startClassName: `${ie.PREFIX}-icon-rotate-${d ? "180" : "0"}`,
        children: ({
          animationClassName: f
        }) => L(e, {
          size: l,
          class: f
        })
      }, null) : L(e, {
        size: l
      }) : null;
      return n("i", {
        key: c,
        class: a
      }, [p]);
    }
    function B() {
      const {
        text: e,
        icon: s,
        itemKey: v,
        indent: r,
        disabled: c,
        level: u,
        expandIcon: l
      } = m, {
        mode: a,
        isInSubNav: d,
        isCollapsed: p,
        prefixCls: f,
        subNavMotion: P,
        limitIndent: N
      } = o.value, S = b.getIsOpen(), M = D(`${f}-sub-title`, {
        [`${f}-sub-title-selected`]: b.getIsSelected(v),
        [`${f}-sub-title-disabled`]: c
      });
      let I = !1, O = "";
      p ? d ? O = n($, null, null) : O = null : a === i.MODE_HORIZONTAL ? d ? O = n($, null, null) : O = l || n(E, {
        "aria-hidden": !0
      }, null) : (P && (I = !0), O = l || n(E, {
        "aria-hidden": !0
      }, null));
      let C = null;
      if (a === i.MODE_VERTICAL && !N && !p) {
        const q = s && !r ? u : u - 1;
        C = fe(q, (J) => y(null, i.ICON_POS_RIGHT, !1, !1, J));
      }
      const h = !p && d && a === i.MODE_HORIZONTAL || p && d;
      return n("div", {
        role: "menuitem",
        tabindex: h ? -1 : 0,
        ref: U,
        class: M,
        onClick: Z,
        onKeypress: F,
        "aria-expanded": S ? "true" : "false"
      }, [n("div", {
        class: `${f}-item-inner`
      }, [C, o.value.toggleIconPosition === i.TOGGLE_ICON_LEFT && y(O, i.ICON_POS_RIGHT, I, !0, "key-toggle-position-left"), s || r || d && a !== i.MODE_HORIZONTAL ? y(s, i.ICON_POS_LEFT, !1, !1, "key-inSubNav-position-left") : null, n("span", {
        class: `${f}-item-text`
      }, [e]), o.value.toggleIconPosition === i.TOGGLE_ICON_RIGHT && y(O, i.ICON_POS_RIGHT, I, !0, "key-toggle-position-right")])]);
    }
    function X() {
      const {
        isCollapsed: e,
        mode: s,
        subNavMotion: v,
        prefixCls: r
      } = o.value, c = b.getIsOpen(), u = s === i.MODE_HORIZONTAL, l = D(`${r}-sub`, {
        [`${r}-sub-open`]: c,
        [`${r}-sub-popover`]: e || u
      }), a = n(me, {
        motion: v,
        isOpen: c,
        keepDOM: !1,
        fade: !0
      }, {
        default: () => [e ? null : n("ul", {
          class: l
        }, {
          default: K.default
        })]
      });
      return u ? null : v ? a : c && !e ? n("ul", {
        class: l
      }, {
        default: K.default
      }) : null;
    }
    function W(e = "") {
      var h, x;
      let s = e;
      const v = (x = (h = w()).default) == null ? void 0 : x.call(h), {
        dropdownStyle: r,
        disabled: c,
        subDropdownProps: u,
        dropdownProps: l
      } = m, {
        mode: a,
        isInSubNav: d,
        isCollapsed: p,
        subNavCloseDelay: f,
        subNavOpenDelay: P,
        prefixCls: N,
        getPopupContainer: S
      } = o.value, M = b.getIsOpen(), I = b.getOpenKeysIsControlled(), O = D({
        [`${N}-popover`]: p
      }), C = {
        trigger: "hover",
        style: r
      };
      return I && (C.trigger = "custom", C.visible = M), S && (C.getPopupContainer = S), (p || a === i.MODE_HORIZONTAL) && (s = c ? s : n(ue, ee({
        className: O,
        render: n(de, null, {
          default: () => [n("li", {
            class: `${N}-popover-crumb`
          }, null), v]
        }),
        position: a === i.MODE_HORIZONTAL && !d ? "bottomLeft" : "rightTop",
        mouseEnterDelay: P,
        mouseLeaveDelay: f,
        onVisibleChange: z
      }, l || u, C), be(e) ? e : {
        default: () => [e]
      })), s;
    }
    return () => {
      const {
        itemKey: e,
        style: s,
        onMouseEnter: v,
        onMouseLeave: r,
        disabled: c,
        text: u
      } = m, {
        mode: l,
        isCollapsed: a,
        prefixCls: d
      } = o.value;
      let p = B();
      const f = X();
      return (a || l === i.MODE_HORIZONTAL) && (p = W(p)), n(re, {
        style: s,
        isSubNav: !0,
        itemKey: e,
        forwardRef: j,
        isCollapsed: a,
        className: `${d}-sub-wrap`,
        onMouseEnter: v,
        onMouseLeave: r,
        disabled: c,
        text: u
      }, {
        default: () => [n(pe.Provider, {
          value: {
            ...o.value,
            isInSubNav: !0
          }
        }, {
          default: () => [p, f]
        })]
      });
    };
  }
});
export {
  $e as default,
  ge as vuePropsType
};
//# sourceMappingURL=SubNav.js.map
