import { defineComponent as re, reactive as se, watch as ue, createVNode as h, mergeProps as ae, nextTick as I } from "vue";
import * as t from "../PropTypes";
import { vuePropsMake as ie } from "../PropTypes";
import S from "classnames";
import le from "../input";
import D from '@douyinfe/semi-foundation/lib/es/utils/isNullOrUndefined';
import fe from '@douyinfe/semi-foundation/lib/es/utils/isBothNaN';
import ce from '@douyinfe/semi-foundation/lib/es/inputNumber/foundation';
import { useBaseComponent as me } from "../_base/baseComponent";
import { cssClasses as de, numbers as x, strings as pe } from '@douyinfe/semi-foundation/lib/es/inputNumber/constants';
import { IconChevronUp as be, IconChevronDown as he } from "@kousum/semi-icons-vue";
import '@douyinfe/semi-foundation/lib/es/inputNumber/inputNumber.css';
import { noop as m, isNaN as ve, isString as ge } from "lodash";
import { propTypes as Ce } from "../input/index";
const ye = {
  ...Ce,
  "aria-label": t.string,
  "aria-labelledby": t.string,
  "aria-invalid": [t.bool, t.string],
  "aria-errormessage": t.string,
  "aria-describedby": t.string,
  "aria-required": t.bool,
  autofocus: t.bool,
  className: t.string,
  defaultValue: [t.number, t.string],
  disabled: t.bool,
  formatter: t.func,
  forwardedRef: t.any,
  hideButtons: t.bool,
  innerButtons: t.bool,
  insetLabel: t.node,
  insetLabelId: t.string,
  keepFocus: t.bool,
  max: t.number,
  min: t.number,
  parser: t.func,
  precision: t.number,
  prefixCls: t.string,
  pressInterval: t.number,
  pressTimeout: t.number,
  preventScroll: t.bool,
  shiftStep: t.number,
  size: t.string,
  step: t.number,
  style: t.object,
  suffix: {
    type: t.any,
    default: void 0
  },
  value: [t.number, t.string],
  onBlur: t.func,
  onChange: t.func,
  onDownClick: t.func,
  onFocus: t.func,
  onKeyDown: t.func,
  onNumberChange: t.func,
  onUpClick: t.func
}, we = {
  forwardedRef: m,
  innerButtons: !1,
  keepFocus: !1,
  max: 1 / 0,
  min: -1 / 0,
  prefixCls: de.PREFIX,
  pressInterval: x.DEFAULT_PRESS_TIMEOUT,
  pressTimeout: x.DEFAULT_PRESS_TIMEOUT,
  shiftStep: x.DEFAULT_SHIFT_STEP,
  size: pe.DEFAULT_SIZE,
  step: x.DEFAULT_STEP,
  onBlur: m,
  onChange: m,
  onDownClick: m,
  onFocus: m,
  onKeyDown: m,
  onNumberChange: m,
  onUpClick: m
}, Ie = ie(ye, we), ze = /* @__PURE__ */ re({
  props: {
    ...Ie
  },
  name: "InputNumber",
  setup(s, {}) {
    let M, B, L, A, T;
    const l = se({
      value: "",
      number: null,
      // Current parsed numbers
      focusing: !!s.autofocus || !1,
      hovering: !1
    });
    let a = null, E = !1;
    const {
      adapter: _
    } = me(s, l);
    function R() {
      return {
        ..._(),
        setValue: (e, n) => {
          l.value = e, I(() => {
            n == null || n();
          });
        },
        setNumber: (e, n) => {
          l.number = e, I(() => {
            n == null || n();
          });
        },
        setFocusing: (e, n) => {
          l.focusing = e, I(() => {
            n == null || n();
          });
        },
        setHovering: (e) => l.hovering = e,
        notifyChange: (...e) => s.onChange(...e),
        notifyNumberChange: (...e) => s.onNumberChange(...e),
        notifyBlur: (e) => s.onBlur(e),
        notifyFocus: (e) => s.onFocus(e),
        notifyUpClick: (e, n) => s.onUpClick(e, n),
        notifyDownClick: (e, n) => s.onDownClick(e, n),
        notifyKeyDown: (e) => s.onKeyDown(e),
        registerGlobalEvent: (e, n) => {
          e && typeof n == "function" && (p.unregisterGlobalEvent(e), p.setCache(e, n), document.addEventListener(e, n));
        },
        unregisterGlobalEvent: (e) => {
          if (e) {
            const n = p.getCache(e);
            document.removeEventListener(e, n), p.setCache(e, null);
          }
        },
        recordCursorPosition: () => {
          try {
            a && (M = a.selectionStart, B = a.selectionEnd, L = a.value, A = a.value.substring(0, M), T = a.value.substring(B));
          } catch (e) {
            console.warn(e);
          }
        },
        restoreByAfter: (e) => {
          if (D(e))
            return !1;
          const n = a.value, r = n.lastIndexOf(e);
          return r === -1 ? !1 : r + e.length === n.length ? (p.fixCaret(r, r), !0) : !1;
        },
        restoreCursor: (e = T) => D(e) ? !1 : Array.prototype.some.call(e, (n, r) => {
          const f = e.substring(r);
          return p.restoreByAfter(f);
        }),
        fixCaret: (e, n) => {
          if (!(e === void 0 || n === void 0 || !a || !a.value))
            try {
              const r = a.selectionStart, f = a.selectionEnd;
              (e !== r || n !== f) && a.setSelectionRange(e, n);
            } catch {
            }
        },
        setClickUpOrDown: (e) => {
          E = e;
        },
        updateStates: (e, n) => {
          Object.keys(e).forEach((r) => {
            l[r] = e[r];
          }), I(() => {
            n == null || n();
          });
        }
      };
    }
    const p = R();
    let o = new ce(p);
    ue([() => s.value, () => s.preventScroll, () => l.focusing], (e, [n, r, f]) => {
      const {
        value: i,
        preventScroll: v
      } = s, {
        focusing: y
      } = l;
      let u;
      if (i !== n && !fe(i, n)) {
        if (D(i) || i === "")
          u = "", o.updateStates({
            value: u,
            number: null
          });
        else {
          let d = i;
          typeof i == "number" && (d = o.doFormat(i));
          const c = o.doParse(d, !1, !0, !0), g = typeof i == "number" ? i : o.doParse(d, !1, !1, !1);
          if (y)
            if (o.isValidNumber(c) && c !== l.number) {
              const b = {
                number: c
              };
              E && (b.value = o.doFormat(b.number, !0), u = b.value), o.updateStates(b, () => p.restoreCursor());
            } else ve(g) ? (u = o.doFormat(d, !1), o.updateStates({
              value: d
            })) : (u = o.doFormat(g, !1), o.updateStates({
              value: u
            }));
          else o.isValidNumber(c) ? (u = o.doFormat(c), o.updateStates({
            number: c,
            value: u
          })) : (u = "", o.updateStates({
            number: null,
            value: u
          }));
        }
        u && ge(u) && u !== String(s.value) && o.notifyChange(u, null);
      }
      E && s.keepFocus && l.focusing && document.activeElement !== a && a.focus({
        preventScroll: v
      });
    }, {
      immediate: !0
    });
    const K = (e) => {
      const {
        forwardedRef: n
      } = s;
      a = e == null ? void 0 : e.getDom(), n && typeof n == "object" ? n.current = e : typeof n == "function" && n(e);
    }, O = (e) => o.handleInputFocus(e), V = (e, n) => o.handleInputChange(e, n), z = (e) => o.handleInputBlur(e), j = (e) => o.handleInputKeyDown(e), G = (e) => o.handleInputMouseEnter(e), H = (e) => o.handleInputMouseLeave(e), q = (e) => o.handleInputMouseMove(e), X = (e) => {
      o.handleUpClick(e);
    }, Z = (e) => {
      o.handleDownClick(e);
    }, U = (e) => {
      o.handleMouseUp(e);
    }, N = (e) => {
      o.handleMouseLeave(e);
    }, k = () => {
      const {
        prefixCls: e,
        disabled: n,
        innerButtons: r,
        max: f,
        min: i
      } = s, {
        hovering: v,
        focusing: y,
        number: u
      } = l, d = n || u === f, c = n || u === i, g = S(`${e}-number-suffix-btns`, {
        [`${e}-number-suffix-btns-inner`]: r,
        [`${e}-number-suffix-btns-inner-hover`]: r && v && !y
      }), b = S(`${e}-number-button`, `${e}-number-button-up`, {
        [`${e}-number-button-up-disabled`]: n,
        [`${e}-number-button-up-not-allowed`]: d
      }), P = S(`${e}-number-button`, `${e}-number-button-down`, {
        [`${e}-number-button-down-disabled`]: n,
        [`${e}-number-button-down-not-allowed`]: c
      });
      return h("div", {
        class: g
      }, [h("span", {
        class: b,
        onMousedown: d ? m : X,
        onMouseup: U,
        onMouseleave: N
      }, [h(be, {
        size: "extra-small"
      }, null)]), h("span", {
        class: P,
        onMousedown: c ? m : Z,
        onMouseup: U,
        onMouseleave: N
      }, [h(he, {
        size: "extra-small"
      }, null)])]);
    }, J = () => {
      const {
        innerButtons: e,
        suffix: n
      } = s, {
        hovering: r,
        focusing: f
      } = l;
      return e && (r || f) ? k() : n;
    };
    return () => {
      const {
        disabled: e,
        className: n,
        prefixCls: r,
        min: f,
        max: i,
        step: v,
        shiftStep: y,
        precision: u,
        formatter: d,
        parser: c,
        forwardedRef: g,
        onUpClick: b,
        onDownClick: P,
        pressInterval: Se,
        pressTimeout: xe,
        suffix: Ee,
        size: F,
        hideButtons: Q,
        innerButtons: W,
        style: Y,
        onNumberChange: Fe,
        keepFocus: De,
        defaultValue: Me,
        ...ee
      } = s, {
        value: ne,
        number: $
      } = l, te = S(n, `${r}-number`, {
        [`${r}-number-size-${F}`]: F
      }), oe = k(), w = {
        "aria-disabled": e,
        step: v
      };
      return $ && (w["aria-valuenow"] = $), i !== 1 / 0 && (w["aria-valuemax"] = i), f !== -1 / 0 && (w["aria-valuemin"] = f), h("div", {
        class: te,
        style: Y,
        onMousemove: (C) => q(C),
        onMouseenter: (C) => G(C),
        onMouseleave: (C) => H(C)
      }, [h(le, ae({
        role: "spinbutton"
      }, {
        ...w,
        ...ee,
        size: F,
        disabled: e,
        ref: K,
        value: ne,
        onFocus: O,
        onChange: V,
        onBlur: z,
        onKeyDown: j,
        suffix: J()
      }), null), Q || W ? null : oe]);
    };
  }
});
export {
  ze as default,
  Ie as vuePropsType
};
//# sourceMappingURL=index.js.map
