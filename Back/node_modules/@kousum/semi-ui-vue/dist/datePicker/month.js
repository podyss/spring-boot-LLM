import { defineComponent as z, ref as J, reactive as Q, onMounted as Z, onUnmounted as ee, watch as te, createVNode as y, nextTick as ne } from "vue";
import w from "classnames";
import * as d from "../PropTypes";
import { vuePropsMake as se } from "../PropTypes";
import ae from '@douyinfe/semi-foundation/lib/es/datePicker/monthFoundation';
import { cssClasses as i, numbers as N } from '@douyinfe/semi-foundation/lib/es/datePicker/constants';
import { useBaseComponent as re } from "../_base/baseComponent";
import { isAfter as F, isBefore as q, isSameDay as g, isBetween as O } from '@douyinfe/semi-foundation/lib/es/datePicker/_utils/index';
import { noop as k, stubFalse as B, isFunction as W } from "lodash";
import { parseISO as oe } from "date-fns";
const ie = i.PREFIX, de = {
  forwardRef: void 0,
  localeCode: void 0,
  month: {
    type: d.object,
    default: /* @__PURE__ */ new Date(),
    required: !0
  },
  selected: {
    type: d.object,
    default: /* @__PURE__ */ new Set(),
    required: !0
  },
  rangeStart: {
    type: d.string,
    default: "",
    required: !0
  },
  rangeEnd: {
    type: d.string,
    default: "",
    required: !0
  },
  offsetRangeStart: {
    type: d.string,
    required: !0
  },
  offsetRangeEnd: {
    type: d.string,
    required: !0
  },
  onDayClick: {
    type: d.func,
    default: k,
    required: !0
  },
  onDayHover: {
    type: d.func,
    default: k,
    required: !0
  },
  weekStartsOn: {
    type: d.number,
    default: N.WEEK_START_ON,
    required: !0
  },
  disabledDate: {
    type: d.func,
    default: B,
    required: !0
  },
  weeksRowNum: {
    type: d.number,
    default: 0,
    required: !0
  },
  onWeeksRowNumChange: {
    type: d.func,
    default: k,
    required: !0
  },
  renderDate: {
    type: d.func,
    required: !0
  },
  renderFullDate: {
    type: d.func,
    required: !0
  },
  // Real-time hover date
  hoverDay: {
    type: d.string,
    required: !0
  },
  startDateOffset: {
    type: d.func,
    required: !0
  },
  endDateOffset: {
    type: d.func,
    required: !0
  },
  rangeInputFocus: {
    type: [d.string, d.bool],
    required: !0
  },
  focusRecordsRef: {
    type: d.object,
    required: !0
  },
  multiple: {
    type: d.bool,
    required: !0
  },
  locale: {
    type: Object,
    required: !0
  },
  style: d.object,
  className: d.string
}, ue = {
  month: /* @__PURE__ */ new Date(),
  selected: /* @__PURE__ */ new Set(),
  rangeStart: "",
  rangeEnd: "",
  onDayClick: k,
  onDayHover: k,
  onWeeksRowNumChange: k,
  weekStartsOn: N.WEEK_START_ON,
  disabledDate: B,
  weeksRowNum: 0
}, le = se(de, ue), Ae = /* @__PURE__ */ z({
  props: {
    ...le
  },
  name: "Month",
  setup(c, {
    slots: ce
  }) {
    const x = J(), R = Q({
      weekdays: [],
      month: {
        weeks: [],
        monthText: ""
      },
      todayText: "",
      weeksRowNum: c.weeksRowNum
    }), {
      adapter: M
    } = re(c, R);
    let m;
    function G() {
      return {
        ...M(),
        updateToday: (t) => R.todayText = t,
        setWeekDays: (t) => R.weekdays = t,
        setWeeksRowNum: (t, a) => {
          R.weeksRowNum = t, ne(() => {
            a();
          });
        },
        updateMonthTable: (t) => R.month = t,
        notifyDayClick: (t) => c.onDayClick(t),
        notifyDayHover: (t) => c.onDayHover(t),
        notifyWeeksRowNumChange: (t) => c.onWeeksRowNumChange(t)
      };
    }
    m = new ae(G()), Z(() => {
      m.init();
    }), ee(() => {
      m.destroy();
    }), te(() => c.month, () => {
      m.getMonthTable();
    }, {
      immediate: !0
    });
    function L(t) {
      const {
        rangeInputFocus: a
      } = c, {
        fullDate: n,
        todayText: r,
        selected: o,
        disabledDate: s,
        rangeStart: u,
        rangeEnd: e
      } = t, f = {
        rangeStart: u,
        rangeEnd: e,
        rangeInputFocus: a
      }, D = n === r, E = o.has(n);
      let l = s && s(oe(n), f);
      return !l && c.rangeInputFocus === "rangeStart" && e && c.focusRecordsRef && c.focusRecordsRef.value.rangeEnd && (l = F(n, e.trim().split(/\s+/)[0])), !l && c.rangeInputFocus === "rangeEnd" && u && c.focusRecordsRef && c.focusRecordsRef.value.rangeStart && (l = q(n, u.trim().split(/\s+/)[0])), {
        isToday: D,
        // Today
        isSelected: E,
        // Selected
        isDisabled: l
        // Disabled
      };
    }
    function V(t) {
      const {
        rangeStart: a,
        rangeEnd: n,
        fullDate: r,
        hoverDay: o,
        offsetRangeStart: s,
        offsetRangeEnd: u,
        rangeInputFocus: e
      } = t, f = !!(a || n), D = !!(a && n), E = s || u;
      if (!f)
        return {};
      const l = g(o, r);
      let S, _, A, v, T;
      a && (A = g(r, a), e === "rangeEnd" && (S = O(r, {
        start: a,
        end: o
      }))), n && (v = g(r, n), e === "rangeStart" && (_ = O(r, {
        start: o,
        end: n
      }))), !D && f && (T = l);
      let H;
      E || (H = S || _ || l);
      let p, h, b, C, Y, I;
      return D && (p = O(r, {
        start: a,
        end: n
      }), E || (h = A && F(a, o), b = v && q(n, o), C = l && e === "rangeStart", Y = l && e === "rangeEnd", I = l && O(o, {
        start: a,
        end: n
      }))), {
        isHoverDay: l,
        // Is the current hover date
        isSelectedStart: A,
        // Select Start
        isSelectedEnd: v,
        // End of selection
        isInRange: p,
        // Range within the selected date
        isHover: H,
        // Date between selection and hover date
        isSelectedStartAfterHover: h,
        // Choose to start behind the hover
        isSelectedEndBeforeHover: b,
        // Choose to end in front of the hover
        isHoverDayInRange: I,
        // Hover date within range
        isHoverDayInStartSelection: C,
        // Hover date when starting Date is selected
        isHoverDayInEndSelection: Y,
        // Hover date when endDate is selected
        isHoverDayAroundOneSelected: T
        // Hover date and select a date
      };
    }
    function j(t) {
      const {
        offsetRangeStart: a,
        offsetRangeEnd: n,
        rangeStart: r,
        rangeEnd: o,
        fullDate: s,
        hoverDay: u
      } = t;
      if (!(a || n))
        return {};
      const f = O(s, {
        start: r,
        end: o
      }), D = g(u, s), E = r && g(s, r), l = o && g(s, o), S = !!(r && o), _ = g(s, a), A = g(s, n), v = D;
      let T, H;
      return S && (T = f && D), !!(a && n) && (H = E || O(s, {
        start: a,
        end: n
      }) || l), {
        isOffsetRangeStart: _,
        // Week selection start
        isOffsetRangeEnd: A,
        // End of week selection
        isHoverInOffsetRange: T,
        // Hover in the week selection
        isHoverDayOffset: v,
        // Week selection hover day
        isInOffsetRange: H
        // Include start and end within the week selection (start and end styles are the same as other dates, so start and end are included)
      };
    }
    function K(t, a) {
      const {
        fullDate: n
      } = t, {
        hoverDay: r,
        rangeStart: o,
        rangeEnd: s,
        todayText: u,
        offsetRangeStart: e,
        offsetRangeEnd: f,
        disabledDate: D,
        selected: E,
        rangeInputFocus: l
      } = a, S = L({
        fullDate: n,
        todayText: u,
        hoverDay: r,
        selected: E,
        disabledDate: D,
        rangeStart: o,
        rangeEnd: s
      }), _ = V({
        fullDate: n,
        rangeStart: o,
        rangeEnd: s,
        hoverDay: r,
        offsetRangeStart: e,
        offsetRangeEnd: f,
        rangeInputFocus: l,
        ...S
      }), A = j({
        offsetRangeStart: e,
        offsetRangeEnd: f,
        rangeStart: o,
        rangeEnd: s,
        fullDate: n,
        hoverDay: r,
        ...S,
        ..._
      });
      return {
        ...S,
        ..._,
        ...A
      };
    }
    function P() {
      const {
        locale: t
      } = c, a = w(i.WEEKDAY), n = w(`${ie}-weekday-item`), {
        weekdays: r
      } = R, o = r.map((s) => t.weeks[s]);
      return y("div", {
        role: "row",
        class: a
      }, [o.map((s, u) => y("div", {
        role: "columnheader",
        key: s + u,
        class: n
      }, [s]))]);
    }
    function U() {
      const {
        month: t
      } = R, {
        weeks: a
      } = t, {
        weeksRowNum: n
      } = c;
      let r = {};
      n && (r = {
        height: n * N.WEEK_HEIGHT
      });
      const o = w(i.WEEKS);
      return y("div", {
        class: o,
        style: r
      }, [a.map((s, u) => $(s, u))]);
    }
    function $(t, a) {
      const n = i.WEEK;
      return y("div", {
        role: "row",
        class: n,
        key: a
      }, [t.map((r, o) => X(r, o))]);
    }
    function X(t, a) {
      const {
        todayText: n
      } = R, {
        renderFullDate: r,
        renderDate: o
      } = c, {
        fullDate: s,
        dayNumber: u
      } = t;
      if (!s)
        return y("div", {
          role: "gridcell",
          tabindex: -1,
          key: u + a,
          class: i.DAY
        }, [y("span", null, null)]);
      const e = K(t, {
        todayText: n,
        ...c
      }), f = w(i.DAY, {
        [i.DAY_TODAY]: e.isToday,
        [i.DAY_IN_RANGE]: e.isInRange,
        [i.DAY_HOVER]: e.isHover,
        [i.DAY_SELECTED]: e.isSelected,
        [i.DAY_SELECTED_START]: e.isSelectedStart,
        [i.DAY_SELECTED_END]: e.isSelectedEnd,
        [i.DAY_DISABLED]: e.isDisabled,
        // offsetDate class
        [i.DAY_HOVER_DAY]: e.isHoverDayOffset,
        [i.DAY_IN_OFFSET_RANGE]: e.isInOffsetRange,
        [i.DAY_SELECTED_RANGE_HOVER]: e.isHoverInOffsetRange,
        [i.DAY_OFFSET_RANGE_START]: e.isOffsetRangeStart,
        [i.DAY_OFFSET_RANGE_END]: e.isOffsetRangeEnd,
        // range input class
        [i.DAY_SELECTED_START_AFTER_HOVER]: e.isSelectedStartAfterHover,
        [i.DAY_SELECTED_END_BEFORE_HOVER]: e.isSelectedEndBeforeHover,
        [i.DAY_HOVER_DAY_BEFORE_RANGE]: e.isHoverDayInStartSelection,
        [i.DAY_HOVER_DAY_AFTER_RANGE]: e.isHoverDayInEndSelection,
        [i.DAY_HOVER_DAY_AROUND_SINGLE_SELECTED]: e.isHoverDayAroundOneSelected
      }), D = w({
        [`${i.DAY}-main`]: !0
      }), E = [u, s, e], l = W(r);
      return y("div", {
        role: "gridcell",
        tabindex: e.isDisabled ? -1 : 0,
        "aria-disabled": e.isDisabled,
        "aria-selected": e.isSelected,
        "aria-label": s,
        class: l ? i.DAY : f,
        title: s,
        key: u + a,
        onClick: (S) => !e.isDisabled && m.handleClick(t),
        onMouseenter: () => m.handleHover(t),
        onMouseleave: () => m.handleHover()
      }, [l ? (
        // @ts-ignore
        r(...E)
      ) : y("div", {
        class: D
      }, [W(o) ? o(u, s) : y("span", null, [u])])]);
    }
    return () => {
      const {
        forwardRef: t,
        multiple: a
      } = c, n = P(), r = U(), o = w(i.MONTH);
      return y("div", {
        role: "grid",
        "aria-multiselectable": a,
        ref: t || x,
        class: o
      }, [n, r]);
    };
  }
});
export {
  Ae as default,
  le as vuePropsType
};
//# sourceMappingURL=month.js.map
