import { defineComponent as Ce, useSlots as Re, reactive as ye, onMounted as me, onUnmounted as be, createVNode as l, Fragment as K } from "vue";
import T from "classnames";
import { get as Fe } from "lodash";
import Pe from '@douyinfe/semi-foundation/lib/es/datePicker/inputFoundation';
import { cssClasses as V, strings as q } from '@douyinfe/semi-foundation/lib/es/datePicker/constants';
import { noop as c } from '@douyinfe/semi-foundation/lib/es/utils/function';
import Se from '@douyinfe/semi-foundation/lib/es/utils/isNullOrUndefined';
import { IconCalendar as Ee, IconCalendarClock as xe, IconClear as we } from "@kousum/semi-icons-vue";
import { useBaseComponent as ve } from "../_base/baseComponent";
import D from "../input/index";
import { InsetDateInput as W, InsetTimeInput as G } from "./insetInput";
import * as n from "../PropTypes";
import { vuePropsMake as $e } from "../PropTypes";
const Te = {
  borderless: {
    type: n.bool,
    default: !1
  },
  onClick: {
    type: n.func,
    default: c
  },
  onChange: {
    type: n.func,
    default: c
  },
  onEnterPress: {
    type: n.func,
    default: c
  },
  onBlur: {
    type: n.func,
    default: c
  },
  onClear: {
    type: n.func,
    default: c
  },
  onFocus: {
    type: n.func,
    default: c
  },
  value: n.array,
  disabled: n.bool,
  type: {
    type: n.string,
    default: "date"
  },
  showClear: {
    type: n.bool,
    default: !0
  },
  format: n.string,
  // Attributes not used
  inputStyle: {
    type: n.object,
    default: () => ({})
  },
  inputReadOnly: {
    type: n.bool,
    default: !1
  },
  // Text box can be entered
  insetLabel: n.node,
  validateStatus: n.string,
  prefix: n.node,
  prefixCls: {
    type: n.string,
    default: V.PREFIX
  },
  dateFnsLocale: n.any,
  // Foundation useful to
  placeholder: n.any,
  rangeInputFocus: [n.string, n.bool],
  rangeInputStartRef: n.object,
  rangeInputEndRef: n.object,
  rangeSeparator: {
    type: n.string,
    default: q.DEFAULT_SEPARATOR_RANGE
  },
  insetInput: [n.bool, n.object],
  insetInputValue: n.object,
  defaultPickerValue: n.any,
  clearIcon: n.node,
  inputValue: n.string,
  block: n.bool,
  insetLabelId: n.string,
  multiple: n.bool,
  size: n.string,
  autofocus: n.bool,
  onRangeBlur: n.func,
  onRangeClear: n.func,
  onRangeEndTabPress: n.func,
  inputRef: n.object,
  showClearIgnoreDisabled: n.bool,
  onInsetInputChange: n.func,
  panelType: n.string,
  density: n.string,
  onRangeInputClear: n.func,
  style: n.object,
  className: n.string,
  text: n.string,
  handleInsetDateFocus: n.func,
  handleInsetTimeFocus: n.func,
  suffix: n.node,
  inputCls: String
}, Ve = {
  showClear: !0,
  onClick: c,
  onChange: c,
  onEnterPress: c,
  onBlur: c,
  onClear: c,
  onFocus: c,
  type: "date",
  inputStyle: {},
  inputReadOnly: !1,
  prefixCls: V.PREFIX,
  rangeSeparator: q.DEFAULT_SEPARATOR_RANGE
}, ke = $e(Te, Ve), He = /* @__PURE__ */ Ce({
  props: {
    ...ke
  },
  name: "dateInput",
  setup(r, {}) {
    Re();
    const A = ye({
      isFocusing: !1
    }), {
      adapter: H
    } = ve(r, A);
    function J() {
      return {
        ...H(),
        updateIsFocusing: (e) => A.isFocusing = e,
        notifyClick: (...e) => r.onClick(...e),
        notifyChange: (...e) => r.onChange(...e),
        notifyEnter: (...e) => r.onEnterPress(...e),
        notifyBlur: (...e) => r.onBlur(...e),
        notifyClear: (...e) => r.onClear(...e),
        notifyFocus: (...e) => r.onFocus(...e),
        notifyRangeInputClear: (...e) => r.onRangeClear(...e),
        notifyRangeInputFocus: (...e) => r.onFocus(...e),
        notifyTabPress: (...e) => r.onRangeEndTabPress(...e),
        notifyInsetInputChange: (e) => r.onInsetInputChange(e)
      };
    }
    me(() => {
      i.init();
    }), be(() => {
      i.destroy();
    });
    const i = new Pe(J());
    function Q(e) {
      return e && e.length ? i.formatShowText(e) : "";
    }
    const Y = (e, t) => i.handleChange(e, t), Z = (e) => i.handleInputComplete(e), ee = (e) => i.handleInputClear(e), B = (e, t, o) => {
      const a = z(e, t);
      i.handleChange(a, o);
    }, ne = (e) => {
      i.handleRangeInputClear(e);
    }, j = (e, t, o) => {
      const a = z(t, o);
      i.handleRangeInputEnterPress(e, a);
    }, te = (e) => {
      i.handleRangeInputEndKeyPress(e);
    }, S = (e, t) => {
      i.handleRangeInputFocus(e, t);
    }, k = (e) => {
      S(e, "rangeStart");
    }, w = (e) => {
      i.handleInsetInputChange(e);
    }, z = (e, t) => {
      const {
        rangeSeparator: o
      } = r;
      return `${e}${o}${t}`;
    };
    function ae() {
      const {
        prefix: e,
        insetLabel: t,
        prefixCls: o,
        disabled: a,
        rangeInputFocus: d
      } = r, s = e || t;
      return s ? l("div", {
        class: `${o}-range-input-prefix`,
        onClick: (f) => !a && !d && k(f),
        "x-semi-prop": "prefix,insetLabel"
      }, [s]) : null;
    }
    function re(e, t) {
      const {
        disabled: o,
        rangeSeparator: a
      } = r, d = T({
        [`${V.PREFIX}-range-input-separator`]: !0,
        [`${V.PREFIX}-range-input-separator-active`]: (e || t) && !o
      });
      return l("span", {
        onClick: (s) => !o && k(s),
        class: d
      }, [a]);
    }
    function oe(e, t) {
      const {
        showClear: o,
        prefixCls: a,
        disabled: d,
        clearIcon: s,
        showClearIgnoreDisabled: f
      } = r;
      return (e || t) && o && !(d && !f) ? l("div", {
        role: "button",
        tabindex: 0,
        "aria-label": "Clear range input value",
        class: `${a}-range-input-clearbtn`,
        onMousedown: (C) => ne(C)
      }, [s || l(we, {
        "aria-hidden": !0
      }, null)]) : null;
    }
    function le(e) {
      const {
        prefixCls: t,
        disabled: o,
        rangeInputFocus: a
      } = r;
      return e ? l("div", {
        class: `${t}-range-input-suffix`,
        onClick: (s) => !o && !a && k(s)
      }, [e]) : null;
    }
    function se(e) {
      const {
        // this.props
        placeholder: t,
        inputStyle: o,
        disabled: a,
        inputReadOnly: d,
        autofocus: s,
        size: f,
        // compute props
        text: y,
        suffix: b,
        inputCls: C,
        // range only props
        rangeInputStartRef: h,
        rangeInputEndRef: F,
        rangeInputFocus: E,
        prefixCls: p,
        rangeSeparator: x,
        borderless: R
      } = e, [g, I = ""] = y.split(x) || [], P = f === "large" ? "default" : "small", m = Array.isArray(t) ? t : [t, t], [L, O] = m, M = T(`${p}-range-input-wrapper-start`, `${p}-range-input-wrapper`, {
        [`${p}-range-input-wrapper-active`]: E === "rangeStart" && !a,
        [`${p}-range-input-wrapper-start-with-prefix`]: r.prefix || r.insetLabel,
        [`${p}-borderless`]: R
      }), U = T(`${p}-range-input-wrapper-end`, `${p}-range-input-wrapper`, {
        [`${p}-range-input-wrapper-active`]: E === "rangeEnd" && !a,
        [`${p}-borderless`]: R
      });
      return l(K, null, [ae(), l("div", {
        onClick: (u) => !a && S(u, "rangeStart"),
        class: `${C} ${M}`
      }, [l(D, {
        borderless: R,
        size: P,
        style: o,
        disabled: a,
        readonly: d,
        placeholder: L,
        value: g,
        onChange: (u, v) => B(u, I, v),
        onEnterPress: (u) => j(u, g, I),
        onFocus: (u) => S(u, "rangeStart"),
        autoFocus: s,
        forwardRef: h
      }, null)]), re(g, I), l("div", {
        class: `${C} ${U}`,
        onClick: (u) => !a && S(u, "rangeEnd")
      }, [l(D, {
        borderless: R,
        size: P,
        style: o,
        disabled: a,
        readonly: d,
        placeholder: O,
        value: I,
        onChange: (u, v) => B(g, u, v),
        onEnterPress: (u) => j(u, g, I),
        onFocus: (u) => S(u, "rangeEnd"),
        onKeyDown: te,
        forwardRef: F
      }, null)]), oe(g, I), le(b)]);
    }
    function N() {
      const {
        type: e
      } = r;
      return e.includes("Range") && e !== "monthRange";
    }
    function ue() {
      const {
        type: e,
        handleInsetDateFocus: t,
        handleInsetTimeFocus: o,
        value: a,
        insetInputValue: d,
        prefixCls: s,
        rangeInputStartRef: f,
        rangeInputEndRef: y,
        density: b,
        insetInput: C
      } = r, h = i.getInsetInputValue({
        value: a,
        insetInputValue: d
      }), {
        dateStart: F,
        dateEnd: E,
        timeStart: p,
        timeEnd: x
      } = Fe(C, "placeholder", {}), {
        datePlaceholder: R,
        timePlaceholder: g
      } = i.getInsetInputPlaceholder(), I = `${s}-inset-input-wrapper`, P = `${s}-inset-input-separator`;
      return l("div", {
        class: I,
        "x-type": e
      }, [l(W, {
        forwardRef: f,
        insetInputValue: h,
        placeholder: F ?? R,
        valuePath: "monthLeft.dateInput",
        onChange: w,
        onFocus: (m) => t(m, "rangeStart")
      }, null), l(G, {
        disabled: !h.monthLeft.dateInput,
        insetInputValue: h,
        placeholder: p ?? g,
        type: e,
        valuePath: "monthLeft.timeInput",
        onChange: w,
        onFocus: o
      }, null), N() && l(K, null, [l("div", {
        class: P
      }, [b === "compact" ? null : "-"]), l(W, {
        forwardRef: y,
        insetInputValue: h,
        placeholder: E ?? R,
        valuePath: "monthRight.dateInput",
        onChange: w,
        onFocus: (m) => t(m, "rangeEnd")
      }, null), l(G, {
        disabled: !h.monthRight.dateInput,
        insetInputValue: h,
        placeholder: x ?? g,
        type: e,
        valuePath: "monthRight.timeInput",
        onChange: w,
        onFocus: o
      }, null)])]);
    }
    function ie() {
      const {
        placeholder: e,
        type: t,
        value: o,
        inputValue: a,
        inputStyle: d,
        disabled: s,
        showClear: f,
        inputReadOnly: y,
        insetLabel: b,
        validateStatus: C,
        block: h,
        prefixCls: F,
        multiple: E,
        // Whether to allow multiple values for email and file types
        dateFnsLocale: p,
        // No need to pass to input
        onBlur: x,
        onClear: R,
        onFocus: g,
        prefix: I,
        autofocus: P,
        size: m,
        inputRef: L,
        // range input support props, no need passing to not range type
        rangeInputStartRef: O,
        rangeInputEndRef: M,
        onRangeClear: U,
        onRangeBlur: u,
        onRangeEndTabPress: v,
        rangeInputFocus: Le,
        rangeSeparator: de,
        insetInput: De,
        insetInputValue: Ae,
        defaultPickerValue: Be,
        showClearIgnoreDisabled: pe,
        ...ce
      } = r, ge = l(Ee, {
        "aria-hidden": !0
      }, null), fe = l(xe, {
        "aria-hidden": !0
      }, null), X = t.includes("Time") ? fe : ge;
      let $ = "";
      Se(a) ? o && ($ = Q(o)) : $ = a;
      const _ = T({
        [`${F}-input-readonly`]: y,
        [`${F}-monthRange-input`]: t === "monthRange"
      }), Ie = {
        ...r,
        text: $,
        suffix: X,
        inputCls: _
      }, he = {
        ...ce,
        inputRef: L,
        insetLabel: b,
        disabled: s,
        showClearIgnoreDisabled: pe,
        readonly: y,
        className: _,
        style: d,
        hideSuffix: f,
        placeholder: t === "monthRange" && Array.isArray(e) ? e[0] + de + e[1] : e,
        onEnterPress: Z,
        onChange: Y,
        onClear: ee,
        suffix: X,
        showClear: f,
        value: $,
        validateStatus: C,
        prefix: I,
        autoFocus: P,
        size: m,
        onBlur: x,
        onFocus: g
      };
      return N() ? se(Ie) : l(D, he, null);
    }
    return () => {
      const {
        insetInput: e
      } = r;
      return e ? ue() : ie();
    };
  }
});
export {
  He as default,
  ke as vuePropsType
};
//# sourceMappingURL=dateInput.js.map
