import { defineComponent as He, useSlots as We, reactive as qe, ref as F, watch as G, onMounted as Qe, onUnmounted as Ke, createVNode as d, nextTick as Ue, mergeProps as ae, isVNode as Je } from "vue";
import Z from "classnames";
import { noop as b, stubFalse as oe, isFunction as et, isEqual as re, pick as ie, get as z, isDate as le } from "lodash";
import tt from '@douyinfe/semi-foundation/lib/es/datePicker/foundation';
import { cssClasses as f, numbers as se, strings as x } from '@douyinfe/semi-foundation/lib/es/datePicker/constants';
import { numbers as nt } from '@douyinfe/semi-foundation/lib/es/popover/constants';
import { useBaseComponent as at } from "../_base/baseComponent";
import ot from "../popover/index";
import ue from "./dateInput";
import rt from "./monthsGrid";
import it from "./quickControl";
import lt from "./footer";
import st, { vuePropsType as ut } from "../trigger";
import ct from "./yearAndMonth";
import '@douyinfe/semi-foundation/lib/es/datePicker/datePicker.css';
import * as t from "../PropTypes";
import { vuePropsMake as dt } from "../PropTypes";
import { useConfigContext as pt } from "../configProvider/context/Consumer";
function ft(a) {
  return typeof a == "function" || Object.prototype.toString.call(a) === "[object Object]" && !Je(a);
}
const gt = Object.keys(ut), mt = {
  "aria-describedby": t.string,
  "aria-errormessage": t.string,
  "aria-invalid": [t.bool, t.string],
  "aria-labelledby": t.string,
  "aria-required": t.bool,
  borderless: t.bool,
  type: String,
  size: String,
  density: String,
  defaultValue: [t.string, t.number, t.object, t.array],
  value: [t.string, t.number, t.object, t.array],
  defaultPickerValue: [t.string, t.number, t.object, t.array],
  disabledTime: t.func,
  disabledTimePicker: t.bool,
  hideDisabledOptions: t.bool,
  format: t.string,
  disabled: t.bool,
  multiple: t.bool,
  max: t.number,
  // only work when multiple is true
  placeholder: [t.string, t.array],
  presets: t.array,
  onChange: t.func,
  onChangeWithDateFirst: t.bool,
  weekStartsOn: t.number,
  disabledDate: t.func,
  timePickerOpts: t.object,
  // When dateTime, dateTimeRange, pass through the props to timePicker
  showClear: t.bool,
  // Whether to show the clear button
  onOpenChange: t.func,
  open: t.bool,
  defaultOpen: t.bool,
  motion: [t.bool, t.func, t.object],
  className: t.string,
  prefixCls: t.string,
  prefix: t.node,
  insetLabel: t.node,
  insetLabelId: t.string,
  zIndex: t.number,
  position: String,
  getPopupContainer: t.func,
  onCancel: t.func,
  onConfirm: t.func,
  needConfirm: t.bool,
  inputStyle: t.object,
  timeZone: [t.string, t.number],
  triggerRender: t.func,
  stopPropagation: [t.bool, t.string],
  autoAdjustOverflow: t.bool,
  onBlur: t.func,
  onFocus: t.func,
  onClear: t.func,
  style: t.object,
  autoFocus: t.bool,
  inputReadOnly: t.bool,
  // Text box can be entered
  validateStatus: String,
  renderDate: t.func,
  renderFullDate: t.func,
  spacing: t.number,
  startDateOffset: t.func,
  endDateOffset: t.func,
  autoSwitchDate: t.bool,
  dropdownClassName: t.string,
  dropdownStyle: t.object,
  topSlot: [t.func, ...t.node],
  rightSlot: [t.func, ...t.node],
  leftSlot: [t.func, ...t.node],
  bottomSlot: [t.func, ...t.node],
  dateFnsLocale: t.object,
  // isRequired, but no need to add isRequired key. ForwardStatics function pass static properties to index.jsx, so there is no need for user to pass the prop.
  // Support synchronous switching of months
  syncSwitchMonth: t.bool,
  // Callback function for panel date switching
  onPanelChange: t.func,
  rangeSeparator: t.string,
  preventScroll: t.bool,
  yearAndMonthOpts: t.object,
  locale: Object,
  clearIcon: t.node,
  presetPosition: t.string,
  dropdownMargin: t.oneOfType([t.number, t.object]),
  id: t.string,
  onPresetClick: t.func,
  onClickOutSide: t.func,
  localeCode: t.string,
  insetInput: [t.bool, t.object],
  startYear: t.number,
  endYear: t.number
}, ht = {
  onChangeWithDateFirst: !0,
  borderless: !1,
  autoAdjustOverflow: !0,
  stopPropagation: !0,
  motion: !0,
  prefixCls: f.PREFIX,
  presetPosition: "bottom",
  // position: 'bottomLeft',
  zIndex: nt.DEFAULT_Z_INDEX,
  type: "date",
  size: "default",
  density: "default",
  multiple: !1,
  defaultOpen: !1,
  disabledHours: b,
  disabledMinutes: b,
  disabledSeconds: b,
  hideDisabledOptions: !1,
  onBlur: b,
  onFocus: b,
  onClear: b,
  onCancel: b,
  onConfirm: b,
  onChange: b,
  onOpenChange: b,
  onPanelChange: b,
  onPresetClick: b,
  weekStartsOn: se.WEEK_START_ON,
  disabledDate: oe,
  disabledTime: oe,
  inputReadOnly: !1,
  spacing: se.SPACING,
  autoSwitchDate: !0,
  syncSwitchMonth: !1,
  rangeSeparator: x.DEFAULT_SEPARATOR_RANGE,
  insetInput: !1,
  onClickOutSide: b
}, bt = dt(mt, ht), Vt = /* @__PURE__ */ He({
  props: {
    ...bt
  },
  name: "DatePicker",
  setup(a, {
    expose: ce
  }) {
    We();
    let E;
    const l = qe({
      panelShow: a.open || a.defaultOpen,
      isRange: !1,
      inputValue: null,
      // Staging input values
      value: [],
      // The currently selected date, each date is a Date object
      cachedSelectedValue: [],
      // Save last selected date, maybe include null
      prevTimeZone: null,
      rangeInputFocus: void 0,
      // Optional'rangeStart ',' rangeEnd ', false
      autofocus: a.autoFocus || Q(a.type, a.triggerRender) && (a.open || a.defaultOpen),
      insetInputValue: null,
      triggerDisabled: void 0
    }), H = F(), W = F(), de = F(), q = F(), O = F(), S = F(), I = F({
      rangeStart: !1,
      rangeEnd: !1
    }), {
      adapter: pe,
      isControlled: fe,
      getDataAttr: ge
    } = at(a, l);
    function me() {
      return {
        ...pe(),
        togglePanel: (e, n) => {
          l.panelShow = e, e || (I.value.rangeEnd = !1, I.value.rangeStart = !1), Ue(n);
        },
        registerClickOutSide: () => {
          E && (P.unregisterClickOutSide(), E = null), E = (e) => {
            const n = H.value, o = W.value, i = e.target, s = e.composedPath && e.composedPath() || [i];
            !(n && n.contains(i)) && !(o && o.contains(i)) && !(s.includes(n) || s.includes(o)) && (a.onClickOutSide(e), P.needConfirm() || r.closePanel());
          }, document.addEventListener("mousedown", E);
        },
        unregisterClickOutSide: () => {
          document.removeEventListener("mousedown", E);
        },
        notifyBlur: (...e) => a.onBlur(...e),
        notifyFocus: (...e) => {
          a.onFocus(...e);
        },
        notifyClear: (...e) => a.onClear(...e),
        notifyChange: (...e) => a.onChange(...e),
        notifyCancel: (...e) => a.onCancel(...e),
        notifyConfirm: (...e) => a.onConfirm(...e),
        notifyOpenChange: (...e) => a.onOpenChange(...e),
        notifyPresetsClick: (...e) => a.onPresetClick(...e),
        updateValue: (e) => l.value = e,
        updatePrevTimezone: (e) => l.prevTimeZone = e,
        updateCachedSelectedValue: (e) => {
          let n = e;
          e && !Array.isArray(e) && (n = [...e]), l.cachedSelectedValue = n;
        },
        updateInputValue: (e) => {
          l.inputValue = e;
        },
        updateInsetInputValue: (e) => {
          const {
            insetInput: n
          } = a;
          n && !re(e, l.insetInputValue) && (l.insetInputValue = e);
        },
        needConfirm: () => ["dateTime", "dateTimeRange"].includes(a.type) && a.needConfirm === !0,
        typeIsYearOrMonth: () => ["month", "year", "monthRange"].includes(a.type),
        // setMotionEnd: motionEnd => state.motionEnd = motionEnd,
        setRangeInputFocus: (e) => {
          const {
            preventScroll: n
          } = a;
          switch (e !== l.rangeInputFocus && (l.rangeInputFocus = e), e) {
            case "rangeStart":
              const o = O.value;
              o && o.focus({
                preventScroll: n
              }), setTimeout(() => {
                I.value.rangeStart = !0;
              }, 0);
              break;
            case "rangeEnd":
              const i = S.value;
              i && i.focus({
                preventScroll: n
              }), setTimeout(() => {
                I.value.rangeEnd = !0;
              }, 0);
              break;
            default:
              return;
          }
        },
        couldPanelClosed: () => I.value.rangeStart && I.value.rangeEnd,
        isEventTarget: (e) => e && e.target === e.currentTarget,
        setInsetInputFocus: () => {
          const {
            preventScroll: e
          } = a, {
            rangeInputFocus: n
          } = l;
          switch (n) {
            case "rangeEnd":
              if (document.activeElement !== S.value) {
                const o = S.value;
                o && o.focus({
                  preventScroll: e
                });
              }
              break;
            case "rangeStart":
            default:
              if (document.activeElement !== S.value) {
                const o = O.value;
                o && o.focus({
                  preventScroll: e
                });
              }
              break;
          }
        },
        setInputFocus: () => {
          const {
            preventScroll: e
          } = a, n = q.value;
          n && n.focus({
            preventScroll: e
          });
        },
        setInputBlur: () => {
          const e = q.value;
          e && e.blur();
        },
        setRangeInputBlur: () => {
          const {
            rangeInputFocus: e
          } = l;
          if (e === "rangeStart") {
            const n = O.value;
            n && n.blur();
          } else if (e === "rangeEnd") {
            const n = S.value;
            n && n.blur();
          }
          P.setRangeInputFocus(!1);
        },
        setTriggerDisabled: (e) => {
          l.triggerDisabled = e;
        }
      };
    }
    const P = me(), r = new tt(P);
    P.setCache("cachedSelectedValue", null);
    function Q(e, n) {
      return /range/i.test(e) && !et(n);
    }
    G(() => a.value, (e, n, o) => {
      K([n, a.timeZone]);
    }, {
      immediate: !0
    }), G(() => a.timeZone, (e, n, o) => {
      K([a.value, n]);
    }, {
      immediate: !0
    });
    function K([e, n]) {
      re(e, a.value) ? a.timeZone !== n && r.initFromProps({
        value: l.value,
        timeZone: a.timeZone,
        prevTimeZone: n
      }) : r.initFromProps({
        ...a
      });
    }
    G(() => a.open, () => {
      r.initPanelOpenStatus(), a.open || r.clearRangeInputFocus();
    }, {
      immediate: !0
    }), Qe(() => {
    }), Ke(() => {
    });
    function he() {
      r.open();
    }
    function be() {
      r.close();
    }
    function Ce(e) {
      r.focus(e);
    }
    function Pe() {
      r.blur();
    }
    ce({
      open: he,
      close: be,
      focus: Ce,
      blur: Pe
    });
    const Ie = (e) => H.value = e, Se = (e, n) => r.handleSelectedChange(e, n), ye = (e) => r.handleYMSelectedChange(e), U = (e, ...n) => r.disabledDisposeDate(e, ...n), ve = (e, ...n) => r.disabledDisposeTime(e, ...n);
    function Re(e, n, o) {
      const {
        type: i,
        multiple: s,
        max: u,
        weekStartsOn: c,
        timePickerOpts: g,
        defaultPickerValue: p,
        format: m,
        hideDisabledOptions: h,
        disabledTimePicker: C,
        renderDate: y,
        renderFullDate: D,
        startDateOffset: k,
        endDateOffset: T,
        autoSwitchDate: w,
        density: N,
        syncSwitchMonth: L,
        onPanelChange: v,
        timeZone: j,
        triggerRender: _,
        insetInput: A,
        presetPosition: B,
        yearAndMonthOpts: Y,
        startYear: X,
        endYear: R
      } = a, {
        cachedSelectedValue: M,
        rangeInputFocus: $
      } = l;
      return d(rt, {
        ref: de,
        locale: e,
        localeCode: n,
        dateFnsLocale: o,
        weekStartsOn: c,
        type: i,
        multiple: s,
        max: u,
        format: m,
        disabledDate: U,
        hideDisabledOptions: h,
        disabledTimePicker: C,
        disabledTime: ve,
        defaultValue: M,
        defaultPickerValue: p,
        timePickerOpts: g,
        isControlledComponent: !P.needConfirm() && fe("value"),
        onChange: Se,
        renderDate: y,
        renderFullDate: D,
        startDateOffset: k,
        endDateOffset: T,
        autoSwitchDate: w,
        density: N,
        rangeInputFocus: $,
        setRangeInputFocus: we,
        isAnotherPanelHasOpened: Ve,
        syncSwitchMonth: L,
        onPanelChange: v,
        timeZone: j,
        focusRecordsRef: I,
        triggerRender: _,
        insetInput: A,
        presetPosition: B,
        renderQuickControls: V(),
        renderDateInput: J(),
        yearAndMonthOpts: Y,
        startYear: X,
        endYear: R
      }, null);
    }
    function V() {
      const {
        presets: e,
        type: n,
        presetPosition: o,
        insetInput: i,
        locale: s
      } = a;
      return d(it, {
        type: n,
        presets: e,
        insetInput: i,
        presetPosition: o,
        onPresetClick: (u, c) => r.handlePresetClick(u, c),
        locale: s
      }, null);
    }
    function J() {
      const {
        insetInput: e,
        dateFnsLocale: n,
        density: o,
        type: i,
        format: s,
        rangeSeparator: u,
        defaultPickerValue: c
      } = a, {
        insetInputValue: g,
        value: p
      } = l;
      return e ? d(ue, ae({
        dateFnsLocale: n,
        format: s,
        insetInputValue: g,
        rangeSeparator: u,
        type: i,
        value: p,
        handleInsetDateFocus: Ye,
        handleInsetTimeFocus: Ne,
        onInsetInputChange: Ee,
        rangeInputStartRef: O,
        rangeInputEndRef: S,
        density: o,
        defaultPickerValue: c
      }, {
        insetInput: e
      }), null) : null;
    }
    const Fe = (...e) => r.handleInputChange(...e), Ee = (e) => r.handleInsetInputChange(e), Oe = (e) => r.handleInputComplete(e), De = (e) => r.handleInputBlur(z(e, "target.value"), e), ee = (...e) => {
      r.handleInputFocus(...e);
    }, ke = (e) => r.handleInputClear(e), Te = (e) => {
      r.handleTriggerWrapperClick(e);
    }, we = (e) => r.handleSetRangeFocus(e), Ae = (e, n) => r.handleRangeInputBlur(e, n), Me = (e) => r.handleRangeInputClear(e), xe = (e) => r.handleRangeEndTabPress(e), Ve = (e) => e === "rangeStart" ? I.value.rangeEnd : I.value.rangeStart, Ye = (e, n) => {
      const o = z(this, "monthGrid.current.foundation");
      o && (o.showDatePanel(x.PANEL_TYPE_LEFT), o.showDatePanel(x.PANEL_TYPE_RIGHT)), ee(e, n);
    }, Ne = () => {
      const e = z(this, "monthGrid.current.foundation");
      e && (e.showTimePicker(x.PANEL_TYPE_LEFT), e.showTimePicker(x.PANEL_TYPE_RIGHT));
    }, Le = (e) => {
      r.handlePanelVisibleChange(e);
    };
    function je(e) {
      const {
        clearIcon: n,
        type: o,
        format: i,
        multiple: s,
        disabled: u,
        showClear: c,
        insetLabel: g,
        insetLabelId: p,
        placeholder: m,
        validateStatus: h,
        inputStyle: C,
        prefix: y,
        locale: D,
        dateFnsLocale: k,
        triggerRender: T,
        size: w,
        inputReadOnly: N,
        rangeSeparator: L,
        insetInput: v,
        defaultPickerValue: j,
        borderless: _
      } = a, {
        value: A,
        inputValue: B,
        rangeInputFocus: Y,
        triggerDisabled: X
      } = l, R = Q(o, T), M = u || v && X, $ = Z(`${f.PREFIX}-input`, {
        [`${f.PREFIX}-range-input`]: R,
        [`${f.PREFIX}-range-input-${w}`]: R && w,
        [`${f.PREFIX}-range-input-active`]: R && Y && !M,
        [`${f.PREFIX}-range-input-disabled`]: R && M,
        [`${f.PREFIX}-range-input-${h}`]: R && h,
        [`${f.PREFIX}-borderless`]: _
      }), te = m || D.placeholder[o], ne = {
        ...e,
        showClearIgnoreDisabled: !!v,
        placeholder: te,
        clearIcon: n,
        disabled: M,
        inputValue: B,
        value: A,
        defaultPickerValue: j,
        onChange: Fe,
        onEnterPress: Oe,
        // TODO: remove in next major version
        block: !0,
        inputStyle: C,
        showClear: c,
        insetLabel: g,
        insetLabelId: p,
        type: o,
        format: i,
        multiple: s,
        validateStatus: h,
        inputReadOnly: N || !!v,
        // onClick: handleOpenPanel,
        onBlur: De,
        onFocus: ee,
        onClear: ke,
        prefix: y,
        size: w,
        autofocus: l.autofocus,
        dateFnsLocale: k,
        rangeInputFocus: Y,
        rangeSeparator: L,
        onRangeBlur: Ae,
        onRangeClear: Me,
        onRangeEndTabPress: xe,
        rangeInputStartRef: v ? null : O,
        rangeInputEndRef: v ? null : S
      };
      return d("div", {
        role: "combobox",
        "aria-label": Array.isArray(A) && A.length ? "Change date" : "Choose date",
        "aria-disabled": u,
        onClick: Te,
        class: $
      }, [typeof T == "function" ? d(st, ae(ie(ne, ...gt), {
        triggerRender: T,
        componentName: "DatePicker",
        componentProps: {
          ...P.getProps()
        }
      }), null) : d(ue, ne, null)]);
    }
    const _e = (e) => r.handleConfirm(), Be = (e) => r.handleCancel(), Xe = (e, n) => P.needConfirm() ? d(lt, {
      prefixCls: a.prefixCls,
      locale: e,
      localeCode: n,
      onConfirmClick: _e,
      onCancelClick: Be
    }, null) : null, $e = (e, n, o) => {
      const {
        dropdownClassName: i,
        dropdownStyle: s,
        density: u,
        topSlot: c,
        bottomSlot: g,
        presetPosition: p,
        type: m,
        leftSlot: h,
        rightSlot: C
      } = a, y = Z(f.PREFIX, {
        [f.PANEL_YAM]: P.typeIsYearOrMonth(),
        [`${f.PREFIX}-compact`]: u === "compact"
      }, i);
      return d("div", {
        ref: W,
        class: y,
        style: s,
        "x-type": m
      }, [d("div", {
        class: `${f.PREFIX}-container`
      }, [h && d("div", {
        class: `${f.PREFIX}-leftSlot`,
        "x-semi-prop": "leftSlot"
      }, [h]), d("div", null, [c && d("div", {
        class: `${f.PREFIX}-topSlot`,
        "x-semi-prop": "topSlot"
      }, [c]), p === "top" && m !== "monthRange" && V(), P.typeIsYearOrMonth() ? Ge(e, n) : Re(e, n, o), p === "bottom" && m !== "monthRange" && V(), g && d("div", {
        class: `${f.PREFIX}-bottomSlot`,
        "x-semi-prop": "bottomSlot"
      }, [g])]), C && d("div", {
        class: `${f.PREFIX}-rightSlot`,
        "x-semi-prop": "rightSlot"
      }, [C])]), Xe(e, n)]);
    }, Ge = (e, n) => {
      const {
        density: o,
        presetPosition: i,
        yearAndMonthOpts: s,
        type: u,
        startYear: c,
        endYear: g
      } = a, p = l.value[0], m = {
        left: 0,
        right: 0
      }, h = {
        left: 0,
        right: 0
      };
      if (le(p) && (m.left = p.getFullYear(), h.left = p.getMonth() + 1), u === "monthRange") {
        const C = l.value[1];
        le(C) && (m.right = C.getFullYear(), h.right = C.getMonth() + 1);
      }
      return d(ct, {
        locale: e,
        localeCode: n,
        disabledDate: U,
        noBackBtn: !0,
        monthCycled: !0,
        onSelect: ye,
        currentYear: m,
        currentMonth: h,
        density: o,
        presetPosition: i,
        renderQuickControls: V(),
        renderDateInput: J(),
        type: u,
        yearAndMonthOpts: s,
        startYear: c,
        endYear: g
      }, null);
    }, {
      context: Ze
    } = pt(), ze = (e) => {
      const {
        panelShow: n
      } = l, i = Ze.value.direction === "rtl" ? "bottomRight" : "bottomLeft", {
        motion: s,
        zIndex: u,
        position: c = i,
        getPopupContainer: g,
        locale: p,
        localeCode: m,
        dateFnsLocale: h,
        stopPropagation: C,
        autoAdjustOverflow: y,
        spacing: D,
        dropdownMargin: k
      } = a;
      return d(ot, {
        getPopupContainer: g,
        autoAdjustOverflow: y,
        zIndex: u,
        motion: s,
        margin: k,
        content: $e(p, m, h),
        trigger: "custom",
        position: c,
        visible: n,
        stopPropagation: C,
        spacing: D,
        onVisibleChange: Le
      }, ft(e) ? e : {
        default: () => [e]
      });
    };
    return () => {
      const {
        style: e,
        className: n,
        prefixCls: o,
        type: i,
        ...s
      } = a, u = {
        style: e,
        class: Z(n, {
          [o]: !0
        }),
        ref: Ie,
        "aria-invalid": a["aria-invalid"],
        "aria-errormessage": a["aria-errormessage"],
        "aria-labelledby": a["aria-labelledby"],
        "aria-describedby": a["aria-describedby"],
        "aria-required": a["aria-required"],
        ...ge()
      }, c = [];
      i.toLowerCase().includes("range") || c.push("borderless");
      const g = je(ie(a, c)), p = ze(g);
      return d("div", u, [p]);
    };
  }
});
export {
  Vt as default,
  bt as vuePropsTypeDatePickerProps
};
//# sourceMappingURL=datePicker.js.map
