import { defineComponent as de, reactive as me, onMounted as fe, watch as V, nextTick as q, createVNode as u, mergeProps as ue } from "vue";
import S from "classnames";
import * as n from "../PropTypes";
import { vuePropsMake as he } from "../PropTypes";
import { format as A, isSameDay as ge } from "date-fns";
import Pe from '@douyinfe/semi-foundation/lib/es/datePicker/monthsGridFoundation';
import { cssClasses as pe, numbers as Te, strings as l } from '@douyinfe/semi-foundation/lib/es/datePicker/constants';
import { compatibleParse as $ } from '@douyinfe/semi-foundation/lib/es/datePicker/_utils/parser';
import { stubFalse as Re, noop as Ee } from "lodash";
import { useBaseComponent as ye } from "../_base/baseComponent";
import we from "./navigation";
import ke from "./month";
import De from "../timePicker/Combobox";
import Ce from "./yearAndMonth";
import { IconCalendar as Oe, IconClock as Le } from "@kousum/semi-icons-vue";
import { getDefaultFormatTokenByType as be } from '@douyinfe/semi-foundation/lib/es/datePicker/_utils/getDefaultFormatToken';
import Ye from '@douyinfe/semi-foundation/lib/es/datePicker/_utils/getDefaultPickerDate';
const y = pe.PREFIX, Se = {
  type: n.string,
  defaultValue: n.array,
  defaultPickerValue: n.oneOfType([n.string, n.number, n.object, n.array]),
  multiple: n.bool,
  max: n.number,
  // only work when multiple is true
  weekStartsOn: n.number,
  disabledDate: n.func,
  disabledTime: n.func,
  disabledTimePicker: n.bool,
  hideDisabledOptions: n.bool,
  navPrev: n.node,
  navNext: n.node,
  onMaxSelect: n.func,
  timePickerOpts: n.object,
  // Whether the outer datePicker is a controlled component
  isControlledComponent: n.bool,
  rangeStart: n.oneOfType([n.string]),
  rangeInputFocus: n.oneOfType([n.bool, n.string]),
  locale: n.object,
  localeCode: n.string,
  format: n.string,
  renderDate: n.func,
  renderFullDate: n.func,
  startDateOffset: n.func,
  endDateOffset: n.func,
  autoSwitchDate: n.bool,
  density: n.string,
  dateFnsLocale: n.any,
  timeZone: n.oneOfType([n.string, n.number]),
  // Support synchronous switching of months
  syncSwitchMonth: n.bool,
  // Callback function for panel date switching
  onPanelChange: n.func,
  focusRecordsRef: n.object,
  triggerRender: n.func,
  presetPosition: n.string,
  renderQuickControls: n.node,
  renderDateInput: n.node,
  style: [Object, String],
  className: String,
  motionEnd: n.bool,
  splitPanels: Boolean,
  onChange: Function,
  setRangeInputFocus: Function,
  isAnotherPanelHasOpened: Function,
  insetInput: {
    type: Boolean,
    required: !0
  },
  yearAndMonthOpts: Object,
  startYear: Number,
  endYear: Number
}, _e = {
  type: "date",
  rangeStart: "",
  multiple: !1,
  weekStartsOn: Te.WEEK_START_ON,
  disabledDate: Re,
  onMaxSelect: Ee,
  locale: {}
}, Ae = he(Se, _e), Ze = /* @__PURE__ */ de({
  props: {
    ...Ae
  },
  name: "MonthsGrid",
  setup(s, {
    slots: Fe
  }) {
    const X = s.format || be(s.type), {
      nowDate: j,
      nextDate: K
    } = Ye({
      defaultPickerValue: s.defaultPickerValue,
      format: X,
      dateFnsLocale: s.dateFnsLocale
    }), Z = {
      // Direct use of full date string storage, mainly considering the month rendering comparison to save a conversion
      // The selected value for single or multiple selection, full date string, eg. {'2019-10-01', '2019-10-02'}
      selected: /* @__PURE__ */ new Set()
    }, z = {
      monthLeft: {
        pickerDate: j,
        showDate: j,
        isTimePickerOpen: !1,
        isYearPickerOpen: !1
      },
      monthRight: {
        pickerDate: K,
        showDate: K,
        isTimePickerOpen: !1,
        isYearPickerOpen: !1
      },
      maxWeekNum: 0,
      // Maximum number of weeks left and right for manual height adjustment
      hoverDay: "",
      // Real-time hover date
      rangeStart: s.rangeStart,
      // Start date for range selection
      rangeEnd: "",
      // End date of range selection
      currentPanelHeight: 0,
      // current month panel height,
      offsetRangeStart: "",
      offsetRangeEnd: ""
    }, r = me({
      ...Z,
      ...z
    }), {
      adapter: J
    } = ye(s, r), i = new Pe(k());
    function U() {
      return {
        updateDaySelected: (e) => r.selected = e
      };
    }
    function ee() {
      return {
        setRangeStart: (e) => r.rangeStart = e,
        setRangeEnd: (e) => r.rangeEnd = e,
        setHoverDay: (e) => r.hoverDay = e,
        setWeeksHeight: (e) => r.maxWeekNum = e,
        setOffsetRangeStart: (e) => r.offsetRangeStart = e,
        setOffsetRangeEnd: (e) => r.offsetRangeEnd = e
      };
    }
    function k() {
      return {
        ...J(),
        ...U(),
        ...ee(),
        updateMonthOnLeft: (e) => r.monthLeft = e,
        updateMonthOnRight: (e) => r.monthRight = e,
        notifySelectedChange: (e, t) => {
          s.onChange(e, t);
        },
        notifyMaxLimit: (e) => s.onMaxSelect(e),
        notifyPanelChange: (e, t) => s.onPanelChange(e, t),
        setRangeInputFocus: (e) => s.setRangeInputFocus(e),
        isAnotherPanelHasOpened: (e) => s.isAnotherPanelHasOpened(e)
      };
    }
    fe(() => {
    }), V(() => s.defaultValue, (e) => {
      i.updateSelectedFromProps(e);
    }, {
      immediate: !0
    }), V(() => s.defaultPickerValue, (e) => {
      i.initDefaultPickerValue();
    }, {
      immediate: !0
    }), V(r, (e, t, o) => {
      if (i.isRangeType()) {
        const c = D(t) && C(t), d = D(t) && !C(t) || !D(t) && C(t), T = D() && C(), m = D() && !C() || !D() && C();
        d && T ? (r.currentPanelHeight = H(), q(() => {
          W();
        })) : c && m && W();
      }
    }, {
      immediate: !0
    });
    const _ = (e, t) => {
      typeof e == "string" && e.length && k().setCache(e, t);
    };
    function D(e) {
      const {
        monthLeft: t
      } = e || r;
      return !!(t && (t.isTimePickerOpen || t.isYearPickerOpen));
    }
    function C(e) {
      const {
        monthRight: t
      } = e || r;
      return !!(t && (t.isTimePickerOpen || t.isYearPickerOpen));
    }
    const H = () => {
      const e = k().getCache(`wrap-${l.PANEL_TYPE_LEFT}`), t = k().getCache(`wrap-${l.PANEL_TYPE_RIGHT}`), o = k().getCache(`switch-${l.PANEL_TYPE_LEFT}`), P = k().getCache(`switch-${l.PANEL_TYPE_RIGHT}`), c = e && e.getBoundingClientRect(), d = t && t.getBoundingClientRect();
      let T = c && c.height || 0, m = d && d.height || 0;
      return o && (T += o.getBoundingClientRect().height), P && (m += P.getBoundingClientRect().height), Math.max(T, m);
    };
    function G(e, t) {
      let o = S(`${y}-month-grid-${t}`);
      const {
        monthLeft: P,
        monthRight: c,
        currentPanelHeight: d
      } = r, {
        insetInput: T
      } = s, m = t === l.PANEL_TYPE_RIGHT ? c : P, {
        isTimePickerOpen: p,
        isYearPickerOpen: h
      } = m, g = ne(e, t), a = h ? u("div", {
        class: `${y}-yam`
      }, [re(t, m)]) : null, E = p ? u("div", {
        class: `${y}-tpk`
      }, [ie(t, m)]) : null, f = {}, Y = k().getCache(`wrap-${l.PANEL_TYPE_LEFT}`), O = k().getCache(`wrap-${l.PANEL_TYPE_RIGHT}`), L = t === l.PANEL_TYPE_RIGHT ? O : Y;
      return i.isRangeType() ? ((h || p) && (f.minWidth = L.getBoundingClientRect().width, f.minWidth = typeof f.minWidth == "string" ? f.minWidth : f.minWidth + "px"), D() && C() && !T && (f.minHeight = d || H(), f.minHeight = f.minHeight + "px")) : s.type !== "year" && s.type !== "month" && (p || h) && (o = S(o, `${y}-yam-showing`)), u("div", {
        class: o,
        key: t,
        style: f,
        "x-open-type": !(h || p) ? "date" : h ? "year" : "time"
      }, [a, E, i.isRangeType() ? g : h || p ? null : g, se(t)]);
    }
    function te(e, t) {
      t.stopImmediatePropagation(), i.showYearPicker(e);
    }
    function ne(e, t) {
      const {
        selected: o,
        rangeStart: P,
        rangeEnd: c,
        hoverDay: d,
        maxWeekNum: T,
        offsetRangeStart: m,
        offsetRangeEnd: p
      } = r, {
        weekStartsOn: h,
        disabledDate: g,
        locale: a,
        localeCode: E,
        renderDate: f,
        renderFullDate: Y,
        startDateOffset: O,
        endDateOffset: L,
        density: b,
        rangeInputFocus: w,
        syncSwitchMonth: B,
        multiple: M
      } = s;
      let N = "";
      if (e) {
        const R = e ? A(e, "yyyy") : "", ce = e ? A(e, "L") : "", le = a && a.months && a.months[ce], Q = a.monthText;
        N = Q && Q.replace("${year}", R).replace("${month}", le);
      }
      let I = {};
      const F = t === l.PANEL_TYPE_RIGHT ? r.monthRight : r.monthLeft, v = i.isRangeType(), x = v && B;
      return v && F && (F.isYearPickerOpen || F.isTimePickerOpen) && (I = {
        visibility: "hidden",
        position: "absolute",
        pointerEvents: "none"
      }), u("div", {
        ref: (R) => _(`wrap-${t}`, R),
        style: I
      }, [u(we, {
        forwardRef: (R) => _(`nav-${t}`, R),
        monthText: N,
        density: b,
        onMonthClick: (R) => te(t, R),
        onPrevMonth: () => i.prevMonth(t),
        onNextMonth: () => i.nextMonth(t),
        onNextYear: () => i.nextYear(t),
        onPrevYear: () => i.prevYear(t),
        shouldBimonthSwitch: x,
        panelType: t
      }, null), u(ke, {
        locale: a,
        localeCode: E,
        forwardRef: (R) => _(`month-${t}`, R),
        disabledDate: g,
        weekStartsOn: h,
        month: e,
        selected: o,
        rangeStart: P,
        rangeEnd: c,
        rangeInputFocus: w,
        offsetRangeStart: m,
        offsetRangeEnd: p,
        hoverDay: d,
        weeksRowNum: T,
        renderDate: f,
        renderFullDate: Y,
        onDayClick: (R) => i.handleDayClick(R, t),
        onDayHover: (R) => i.handleDayHover(R, t),
        onWeeksRowNumChange: (R) => oe(R, t),
        startDateOffset: O,
        endDateOffset: L,
        focusRecordsRef: s.focusRecordsRef,
        multiple: M
      }, null)]);
    }
    const oe = (e, t) => {
      const o = t === l.PANEL_TYPE_RIGHT, P = t === l.PANEL_TYPE_RIGHT, c = D() && C();
      i.isRangeType() && !c && (r.weeksRowNum = e, r.currentPanelHeight = H(), q(() => {
        (D() && P || C() && o) && W();
      }));
    }, W = () => {
      [`timepicker-${l.PANEL_TYPE_LEFT}`, `timepicker-${l.PANEL_TYPE_RIGHT}`, `yam-${l.PANEL_TYPE_LEFT}`, `yam-${l.PANEL_TYPE_RIGHT}`].forEach((t) => {
        const o = k().getCache(t);
        o && typeof o.reselect == "function" && o.reselect();
      });
    }, ae = () => i.getYAMOpenType();
    function ie(e, t) {
      const {
        type: o,
        locale: P,
        format: c,
        hideDisabledOptions: d,
        timePickerOpts: T,
        dateFnsLocale: m
      } = s, {
        pickerDate: p
      } = t, h = S(`${y}-time`), g = {
        ...T,
        hideDisabledOptions: d
      }, a = i.calcDisabledTime(e);
      a && ["disabledHours", "disabledMinutes", "disabledSeconds"].forEach((w) => {
        a[w] && (g[w] = a[w]);
      });
      const {
        rangeStart: E,
        rangeEnd: f
      } = r, Y = i.getValidDateFormat();
      let O, L;
      o === "dateTimeRange" && E && f && ge(O = $(E, Y, void 0, m), L = $(f, Y, void 0, m)) && (e === l.PANEL_TYPE_RIGHT ? E && (g.startDate = O) : f && (g.endDate = L));
      const b = P.selectTime;
      return u("div", {
        class: h
      }, [u(De, ue({
        ref: (w) => _(`timepicker-${e}`, w),
        panelHeader: b,
        format: c || l.FORMAT_TIME_PICKER,
        timeStampValue: p,
        onChange: (w) => i.handleTimeChange(w, e)
      }, g), null)]);
    }
    function re(e, t) {
      const {
        pickerDate: o
      } = t, {
        locale: P,
        localeCode: c,
        density: d,
        yearAndMonthOpts: T,
        startYear: m,
        endYear: p
      } = s, h = o.getFullYear(), g = o.getMonth() + 1;
      return u(Ce, {
        ref: (a) => _(`yam-${e}`, a),
        locale: P,
        localeCode: c,
        currentYear: {
          left: h,
          right: 0
        },
        currentMonth: {
          left: g,
          right: 0
        },
        onSelect: (a) => i.toYearMonth(e, new Date(a.currentYear.left, a.currentMonth.left - 1)),
        onBackToMain: () => {
          i.showDatePanel(e);
          const a = k().getCache(`wrap-${e}`);
          a && (a.style.height = "auto");
        },
        density: d,
        yearAndMonthOpts: T,
        startYear: m,
        endYear: p
      }, null);
    }
    function se(e) {
      const {
        rangeStart: t,
        rangeEnd: o,
        monthLeft: P,
        monthRight: c
      } = r, {
        type: d,
        locale: T,
        disabledTimePicker: m,
        density: p,
        dateFnsLocale: h,
        insetInput: g
      } = s;
      if (!d.includes("Time") || g)
        return null;
      let a, E;
      const {
        FORMAT_SWITCH_DATE: f
      } = T.localeFormatToken, Y = i.getValidTimeFormat(), O = i.getValidDateFormat();
      e === l.PANEL_TYPE_LEFT ? (a = P, E = t ? A($(t, O, void 0, h), f) : "") : (a = c, E = o ? A($(o, O, void 0, h), f) : "");
      const {
        isTimePickerOpen: L,
        showDate: b
      } = a, w = b ? A(b, f) : "", B = b ? A(b, Y) : "", M = ["default"].includes(p), N = S(`${y}-switch`), I = S({
        [`${y}-switch-date`]: !0,
        [`${y}-switch-date-active`]: !L
      }), F = S({
        [`${y}-switch-time`]: !0,
        [`${y}-switch-time-disabled`]: m,
        [`${y}-switch-date-active`]: L
      }), v = S(`${y}-switch-text`);
      return u("div", {
        class: N,
        ref: (x) => k().setCache(`switch-${e}`, x)
      }, [u("div", {
        role: "button",
        "aria-label": "Switch to date panel",
        class: I,
        onClick: (x) => i.showDatePanel(e)
      }, [M && u(Oe, {
        "aria-hidden": !0
      }, null), u("span", {
        class: v
      }, [E || w])]), u("div", {
        role: "button",
        "aria-label": "Switch to time panel",
        class: F,
        onClick: (x) => i.showTimePicker(e, !0)
      }, [M && u(Le, {
        "aria-hidden": !0
      }, null), u("span", {
        class: v
      }, [B])])]);
    }
    return () => {
      const {
        monthLeft: e,
        monthRight: t
      } = r, {
        type: o,
        insetInput: P,
        presetPosition: c,
        renderQuickControls: d,
        renderDateInput: T
      } = s, m = S({
        [`${y}-month-grid`]: !0
      }), p = l.PANEL_TYPE_LEFT, h = l.PANEL_TYPE_RIGHT;
      let g = null;
      o === "date" || o === "dateTime" ? g = G(e.pickerDate, p) : o === "dateRange" || o === "dateTimeRange" ? g = [G(e.pickerDate, p), G(t.pickerDate, h)] : (o === "year" || o === "month") && (g = "year month");
      const a = ae();
      return u("div", {
        style: {
          display: "flex"
        }
      }, [c === "left" && d, u("div", null, [T, u("div", {
        class: m,
        "x-type": o,
        "x-panel-yearandmonth-open-type": a,
        "x-insetinput": P ? "true" : "false",
        "x-preset-position": d === null ? "null" : c,
        ref: (E) => _("monthGrid", E)
      }, [g])]), c === "right" && d]);
    };
  }
});
export {
  Ze as default,
  Ae as vuePropsType
};
//# sourceMappingURL=monthsGrid.js.map
