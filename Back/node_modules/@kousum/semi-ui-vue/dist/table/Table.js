import { defineComponent as St, useSlots as bt, ref as j, reactive as Rt, watch as Ce, onMounted as Ct, onBeforeUnmount as xt, toRaw as Et, createVNode as h, mergeProps as ee, Fragment as xe, isVNode as te } from "vue";
import * as n from "../PropTypes";
import { vuePropsMake as Tt } from "../PropTypes";
import M from "classnames";
import { noop as V, isObject as I, isPlainObject as Kt, debounce as Ft, some as oe, difference as Ee, get as b, flattenDeep as At, find as Pt, isFunction as ne, includes as Dt, omit as Te, findIndex as Ke, each as Lt, pick as vt } from "lodash";
import { flattenColumns as le, mergeQueries as kt, equalWith as Ot, getAllDisabledRowKeys as Ht, assignColumnKeys as It, shouldShowEllipsisTitle as Nt } from '@douyinfe/semi-foundation/lib/es/table/utils';
import _t from '@douyinfe/semi-foundation/lib/es/utils/Store';
import Fe from '@douyinfe/semi-foundation/lib/es/table/foundation';
import { cssClasses as Wt, numbers as Oe, strings as D } from '@douyinfe/semi-foundation/lib/es/table/constants';
import '@douyinfe/semi-foundation/lib/es/table/table.css';
import Bt from "../spin";
import Ae from "../locale/localeConsumer";
import Pe from "./getColumns";
import $t from "./TableContextProvider";
import De from "./ColumnSelection";
import zt from "./TablePagination";
import Ut, { ColumnFilterVueProps as jt } from "./ColumnFilter";
import Mt from "./ColumnSorter";
import Vt from "./CustomExpandIcon";
import qt from "./HeadTable";
import Gt from "./Body";
import { cloneDeep as q, mergeComponents as Le, logger as ve, mergeColumns as ke } from "./utils";
import { useHasInProps as Yt, useBaseComponent as Qt } from "../_base/baseComponent";
import { useTableContext as Zt } from "./tableContext/Consumer";
const Xt = {
  children: n.any,
  className: n.string,
  style: n.object,
  prefixCls: n.string,
  components: n.any,
  bordered: n.bool,
  loading: n.bool,
  size: n.string,
  // @ts-ignore
  tableLayout: n.string,
  columns: n.array,
  hideExpandedColumn: n.bool,
  id: n.string,
  expandIcon: n.oneOfType([n.bool, n.func, n.node]),
  expandCellFixed: n.bool,
  title: n.oneOfType([n.string, n.node, n.func]),
  onHeaderRow: n.func,
  showHeader: n.bool,
  indentSize: n.number,
  rowKey: n.oneOfType([n.func, n.string, n.number]),
  onRow: n.func,
  onExpandedRowsChange: n.func,
  onExpand: n.func,
  rowExpandable: n.func,
  expandedRowRender: n.func,
  expandedRowKeys: n.array,
  defaultExpandAllRows: n.bool,
  expandAllRows: n.bool,
  defaultExpandAllGroupRows: n.bool,
  expandAllGroupRows: n.bool,
  defaultExpandedRowKeys: n.array,
  pagination: n.oneOfType([n.object, n.bool]),
  renderPagination: n.func,
  footer: n.oneOfType([n.func, n.string, n.node]),
  empty: n.node,
  dataSource: n.array,
  childrenRecordName: n.string,
  // children data property name
  rowSelection: n.oneOfType([n.object, n.bool]),
  onChange: n.func,
  scroll: n.object,
  groupBy: n.oneOfType([n.string, n.number, n.func]),
  renderGroupSection: n.oneOfType([n.func]),
  onGroupedRow: n.func,
  clickGroupedRowToExpand: n.bool,
  virtualized: n.oneOfType([n.object, n.bool]),
  dropdownPrefixCls: n.string,
  // TODO: future api
  expandRowByClick: n.bool,
  // TODO: future api
  getVirtualizedListRef: n.func,
  // TODO: future api
  bodyWrapperRef: [n.func, n.object],
  sticky: [Boolean, Object],
  direction: n.string
}, Jt = {
  // rowExpandable: stubTrue,
  tableLayout: "",
  dataSource: [],
  prefixCls: Wt.PREFIX,
  rowSelection: null,
  className: "",
  childrenRecordName: "children",
  size: "default",
  loading: !1,
  bordered: !1,
  expandCellFixed: !1,
  hideExpandedColumn: !0,
  showHeader: !0,
  indentSize: Oe.DEFAULT_INDENT_WIDTH,
  onChange: V,
  pagination: !0,
  rowKey: "key",
  defaultExpandedRowKeys: [],
  defaultExpandAllRows: !1,
  defaultExpandAllGroupRows: !1,
  expandAllRows: !1,
  expandAllGroupRows: !1,
  onFilterDropdownVisibleChange: V,
  onExpand: V,
  onExpandedRowsChange: V,
  expandRowByClick: !1
};
function To() {
  const He = Tt(Xt, Jt);
  return /* @__PURE__ */ St({
    props: {
      ...He
    },
    name: "Table",
    setup(i, {
      expose: Ie
    }) {
      const {
        getProps: Ne
      } = Yt();
      bt();
      let W, ae, ie, se, {
        context: _e
      } = Zt(), re = [], G = [], Y = /* @__PURE__ */ new Set();
      const de = X(i.columns, i.children), ce = le(de), Q = Fe.initColumnsFilteredValueAndSorterOrder(q(ce)), B = j(), ue = j(), O = j(), Z = j(), l = Rt({
        /**
         * Cached props
         */
        cachedColumns: de,
        // update cachedColumns after columns or children change
        cachedChildren: i.children,
        flattenColumns: ce,
        components: Le(i.components, i.virtualized),
        // cached components
        /**
         * State calculated based on prop
         */
        queries: Q,
        // flatten columns, update when sorting or filtering
        dataSource: [],
        // data after paging
        flattenData: [],
        expandedRowKeys: [...i.expandedRowKeys || [], ...i.defaultExpandedRowKeys || []],
        // cached expandedRowKeys
        rowSelection: i.rowSelection ? I(i.rowSelection) ? {
          ...i.rowSelection
        } : {} : null,
        pagination: i.pagination && typeof i.pagination == "object" ? {
          ...i.pagination
        } : i.pagination || !1,
        /**
         * Internal state
         */
        groups: null,
        allRowKeys: [],
        // row keys after paging
        disabledRowKeys: [],
        // disabled row keys after paging
        disabledRowKeysSet: /* @__PURE__ */ new Set(),
        allDisabledRowKeys: [],
        allDisabledRowKeysSet: /* @__PURE__ */ new Set(),
        headWidths: [],
        // header cell width
        bodyHasScrollBar: !1,
        prePropRowSelection: void 0,
        prePagination: void 0
      }), {
        adapter: We,
        getDataAttr: Be
      } = Qt(i, l);
      function $e() {
        return {
          ...We(),
          resetScrollY: () => {
            O.value && (O.value.scrollTop = 0);
          },
          setSelectedRowKeys: (e) => {
            l.rowSelection = {
              ...l.rowSelection,
              selectedRowKeys: [...e],
              selectedRowKeysSet: new Set(e)
            };
          },
          setDisabledRowKeys: (e) => {
            l.disabledRowKeys = e, l.disabledRowKeysSet = new Set(e);
          },
          setCurrentPage: (e) => {
            const {
              pagination: t
            } = l;
            typeof t == "object" ? l.pagination = {
              ...t,
              currentPage: e
            } : l.pagination = {
              currentPage: e
            };
          },
          setPagination: (e) => {
            l.pagination = e;
          },
          setGroups: (e) => {
            l.groups = e;
          },
          setDataSource: (e) => {
            l.dataSource = e;
          },
          setExpandedRowKeys: (e) => {
            l.expandedRowKeys = [...e];
          },
          setQuery: (e = {}) => {
            let t = [...l.queries];
            t = kt(e, t), l.queries = t;
          },
          // Update queries when filtering or sorting
          setQueries: (e) => l.queries = e,
          setFlattenData: (e) => l.flattenData = e,
          setAllRowKeys: (e) => l.allRowKeys = e,
          setHoveredRowKey: (e) => {
            ye.setState({
              hoveredRowKey: e
            });
          },
          setCachedFilteredSortedDataSource: (e) => {
            re = e;
          },
          setCachedFilteredSortedRowKeys: (e) => {
            G = e, Y = new Set(e);
          },
          setAllDisabledRowKeys: (e) => {
            const t = new Set(e);
            l.allDisabledRowKeys = e, l.allDisabledRowKeysSet = t;
          },
          getCurrentPage: () => b(l, "pagination.currentPage", 1),
          getCurrentPageSize: () => b(l, "pagination.pageSize", Oe.DEFAULT_PAGE_SIZE),
          getCachedFilteredSortedDataSource: () => re,
          getCachedFilteredSortedRowKeys: () => G,
          getCachedFilteredSortedRowKeysSet: () => Y,
          getAllDisabledRowKeys: () => l.allDisabledRowKeys,
          getAllDisabledRowKeysSet: () => l.allDisabledRowKeysSet,
          notifyFilterDropdownVisibleChange: (e, t) => Ve(t, "onFilterDropdownVisibleChange", e),
          notifyChange: (...e) => i.onChange(...e),
          notifyExpand: (...e) => i.onExpand(...e),
          notifyExpandedRowsChange: (...e) => i.onExpandedRowsChange(...e),
          notifySelect: (...e) => $("onSelect", ...e),
          notifySelectAll: (...e) => $("onSelectAll", ...e),
          notifySelectInvert: (...e) => $("onSelectInvert", ...e),
          notifySelectionChange: (...e) => $("onChange", ...e),
          isAnyColumnFixed: (e) => oe(X(e || i.columns, i.children), (t) => !!t.fixed),
          useFixedHeader: () => {
            const {
              scroll: e,
              sticky: t
            } = i;
            return !!(b(e, "y") || t);
          },
          getTableLayout: () => {
            let e = !1;
            const {
              flattenColumns: t
            } = l;
            return Array.isArray(t) && (e = t.some((o) => !!o.ellipsis || !!o.fixed)), P.useFixedHeader() && (e = !0), e ? "fixed" : "auto";
          },
          setHeadWidths: (e, t = 0) => {
            if (!Ot(l.headWidths[t], e)) {
              const o = [...l.headWidths];
              o[t] = [...e], l.headWidths = o;
            }
          },
          getHeadWidths: (e = 0) => l.headWidths.length && typeof e == "number" ? (l.headWidths[e] || []).map((o) => o.width) : [],
          // This method is called by row rendering function
          getCellWidths: (e, t = null, o = !1) => Array.isArray(e) && e.length && (t = t == null && l.headWidths.length ? At(l.headWidths) : [], Array.isArray(t) && t.length) ? e.reduce((a, s) => {
            const f = s.key === D.DEFAULT_KEY_COLUMN_SCROLLBAR && o ? null : Pt(t, (c) => c && c.key != null && c.key === s.key);
            return f && a.push(f.width), a;
          }, []) : [],
          mergedRowExpandable: (e) => {
            const {
              expandedRowRender: t,
              childrenRecordName: o,
              rowExpandable: a
            } = i, s = b(e, o), f = typeof t == "function", c = typeof a == "function", r = Array.isArray(s) && s.length, y = c && a(e);
            return (f || r) && (!c || y) || !(f || r) && y;
          },
          isAnyColumnUseFullRender: (e) => oe(e, (t) => {
            t.useFullRender;
          }),
          //TODO 类型没对上
          getNormalizeColumns: () => wt,
          getHandleColumns: () => be,
          getMergePagination: () => gt,
          setBodyHasScrollbar: (e) => {
            e !== l.bodyHasScrollBar && (l.bodyHasScrollBar = e);
          },
          stopPropagation(e) {
            e && typeof e == "object" && (typeof e.stopPropagation == "function" && e.stopPropagation(), e.nativeEvent && typeof e.nativeEvent.stopPropagation == "function" ? e.nativeEvent.stopPropagation() : typeof e.stopImmediatePropagation == "function" && e.stopImmediatePropagation());
          }
        };
      }
      const P = $e(), u = new Fe(P), ze = u.getFilteredSortedDataSource(i.dataSource, Q), Ue = Kt(i.pagination) ? i.pagination : {}, fe = u.getCurrentPageData(ze, Ue, Q);
      l.dataSource = fe.dataSource, l.pagination = fe.pagination;
      const ye = new _t({
        hoveredRowKey: null
      });
      let H = Ft(we, 150);
      function je(e) {
        const t = {}, {
          rowSelection: o,
          dataSource: a,
          childrenRecordName: s,
          rowKey: f,
          pagination: c
        } = e;
        if (e.columns && e.children && ve.warn("columns should not given by object and children at the same time"), e.columns && e.columns !== l.cachedColumns) {
          const r = le(e.columns);
          t.flattenColumns = r, t.queries = ke(l.queries, r, null, !1), t.cachedColumns = e.columns, t.cachedChildren = null;
        } else if (e.children && e.children !== l.cachedChildren) {
          const r = Pe(e.children), y = le(r), d = ke(l.queries, y, null, !1);
          t.flattenColumns = y, t.queries = [...d], t.cachedColumns = [...r], t.cachedChildren = e.children;
        }
        if (o !== l.prePropRowSelection) {
          let r = {};
          I(l.rowSelection) && (r = {
            ...r,
            ...l.rowSelection
          }), I(o) && (r = {
            ...r,
            ...o
          });
          const y = b(o, "selectedRowKeys"), d = b(o, "getCheckboxProps");
          if (y && Array.isArray(y) && (r.selectedRowKeysSet = new Set(y)), ne(d)) {
            const m = Ht({
              dataSource: a,
              getCheckboxProps: d,
              childrenRecordName: s,
              rowKey: f
            }), p = new Set(m);
            t.disabledRowKeys = m, t.disabledRowKeysSet = p, t.allDisabledRowKeys = m, t.allDisabledRowKeysSet = p;
          }
          t.rowSelection = r, t.prePropRowSelection = o;
        }
        if (c !== l.prePagination) {
          let r = {};
          I(l.pagination) && (r = {
            ...r,
            ...l.pagination
          }), I(c) && (r = {
            ...r,
            ...c
          }), t.pagination = r, t.prePagination = c;
        }
        return t;
      }
      Ce(() => i, () => {
        const e = je({
          ...i
        });
        e && Object.keys(e).forEach((t) => {
          l[t] = e[t];
        });
      }, {
        deep: !0,
        immediate: !0
      }), Ct(() => {
        N("left"), (P.isAnyColumnFixed() || i.showHeader && P.useFixedHeader()) && (we(), window.addEventListener("resize", H));
      }), Ce([() => i.expandedRowKeys, () => i.components, () => i.virtualized, () => i.expandAllRows, () => i.expandAllGroupRows, () => i.dataSource, () => l.cachedColumns, () => l.cachedChildren], (e, [t, o, a, s, f, c, r, y]) => {
        const {
          dataSource: d,
          expandedRowKeys: m,
          expandAllRows: p,
          expandAllGroupRows: w,
          virtualized: S,
          components: F,
          pagination: R
        } = i, {
          pagination: g,
          queries: C,
          cachedColumns: E,
          // @ts-ignore
          cachedChildren: T,
          groups: A
        } = l, x = {};
        if (Me(), Array.isArray(m) && m !== t && (l.expandedRowKeys = m), (F !== o || S !== a) && (l.components = Le(F, S)), (p !== s || w !== f) && u.initExpandedRowKeys({
          groups: A
        }), d !== c || E !== r || T !== y) {
          const v = [...d], K = u.getFilteredSortedDataSource(v, C), L = u.getAllDisabledRowKeys(K);
          u.setCachedFilteredSortedDataSource(K), u.setAllDisabledRowKeys(L), x.dataSource = K, i.groupBy && (x.groups = null);
        }
        if (d !== c && (x.pagination = typeof g != "boolean" ? {
          ...g,
          currentPage: (
            //@ts-ignore
            I(R) && R.currentPage ? R.currentPage : 1
          )
        } : g), Object.keys(x).length) {
          const {
            // eslint-disable-next-line @typescript-eslint/no-shadow
            pagination: v = null,
            queries: K = null,
            dataSource: L = null
          } = x, k = u.getCurrentPageData(L, v, K);
          P.setAllRowKeys(k.allRowKeys), P.setDisabledRowKeys(k.disabledRowKeys), "dataSource" in x && ((i.defaultExpandAllRows && k.groups && k.groups.size || i.expandAllRows || i.expandAllGroupRows) && u.initExpandedRowKeys(k), x.pagination = k.pagination);
          const U = Object.keys(x);
          for (const _ of U)
            l[_] = k[_];
        }
        (P.isAnyColumnFixed() || i.showHeader && P.useFixedHeader()) && (H || window.addEventListener("resize", H));
      }, {
        immediate: !0
      }), xt(() => {
        H && (window.removeEventListener("resize", H), H.cancel(), H = null);
      });
      function Me() {
        (i.rowSelection || i.expandedRowRender) && oe(i.dataSource, (e) => u.getRecordKey(e) == null) && ve.error('You must specify a key for each element in the dataSource or use "rowKey" to specify an attribute name as the primary key!');
      }
      const $ = (e, ...t) => {
        const o = b(l, ["rowSelection", e]);
        typeof o == "function" && o(...t);
      }, Ve = (e, t, ...o) => {
        if (e && t) {
          const a = u.getQuery(e), s = b(a, t, null);
          typeof s == "function" && s(...o);
        }
      }, qe = (e) => {
        Z.value = e;
      }, Ge = () => {
        const e = u.getCurrentPageData(), t = ["dataSource", "groups"].reduce((o, a) => (e[a] && (o[a] = e[a]), o), {});
        return q(t);
      };
      function X(e, t) {
        return !Array.isArray(e) || !e || !e.length ? Pe(t) : e;
      }
      const Ye = (...e) => u.getCellWidths(...e), Qe = (...e) => u.setHeadWidths(...e), Ze = (...e) => u.getHeadWidths(...e), Xe = (...e) => u.mergedRowExpandable(...e), Je = (...e) => u.setBodyHasScrollbar(...e), et = (e) => {
        var o;
        const {
          scroll: t = {}
        } = i;
        if ((o = window.navigator) != null && o.userAgent.match(/Trident\/7\./) && t.y) {
          e.preventDefault();
          const a = e.deltaY, {
            target: s
          } = e, f = O.value;
          let c = 0;
          W ? c = W + a : c = a, f && s !== f && (f.scrollTop = c);
        }
      }, pe = (e) => {
        var s;
        if (e.currentTarget !== e.target)
          return;
        const {
          target: t
        } = e, o = (s = Z.value) == null ? void 0 : s.$el, a = O.value;
        t.scrollLeft !== ae && (t === a && o ? o.scrollLeft = t.scrollLeft : t === o && a && (a.scrollLeft = t.scrollLeft), ge()), ae = t.scrollLeft;
      };
      function we() {
        nt(), ge();
      }
      const tt = (e) => {
        const {
          target: t
        } = e;
        if (e.currentTarget !== t)
          return;
        const {
          scroll: o = {}
        } = i, a = Z.value, s = O.value;
        if (t.scrollTop !== W && o.y && t !== a) {
          const {
            scrollTop: f
          } = t;
          s && t !== s && (s.scrollTop = f);
        }
        W = t.scrollTop;
      }, ot = (e) => {
        pe(e), tt(e);
      }, N = (e) => {
        const {
          prefixCls: t
        } = i, o = [`${t}-scroll-position-both`, `${t}-scroll-position-middle`, `${t}-scroll-position-left`, `${t}-scroll-position-right`];
        ie = e;
        const a = ue.value;
        if (a && a.nodeType)
          if (e === "both") {
            const s = [`${t}-scroll-position-left`, `${t}-scroll-position-right`];
            a.classList.remove(...Ee(o, s)), a.classList.add(...s);
          } else {
            const s = [`${t}-scroll-position-${e}`];
            a.classList.remove(...Ee(o, s)), a.classList.add(...s);
          }
      }, ge = () => {
        const e = O.value;
        if (e && e.children && e.children.length) {
          const t = e.scrollLeft === 0, o = Math.abs(e.scrollLeft) + 1 >= e.children[0].getBoundingClientRect().width - e.getBoundingClientRect().width;
          t && o ? N("both") : t ? N("left") : o ? N("right") : ie !== "middle" && N("middle");
        }
      }, nt = () => {
        B && B.value && (l.tableWidth = B.value.getBoundingClientRect().width);
      }, z = (e = {}, t = !1, o) => {
        const {
          rowSelection: a,
          allDisabledRowKeysSet: s
        } = l;
        if (a && typeof a == "object") {
          const {
            selectedRowKeys: f = [],
            selectedRowKeysSet: c = /* @__PURE__ */ new Set(),
            getCheckboxProps: r,
            disabled: y,
            renderCell: d
          } = a, m = G, p = Y, w = u.allIsSelected(c, s, m), F = u.hasRowSelected(f, p) && !w;
          if (t) {
            const R = b(a, "key", D.DEFAULT_KEY_COLUMN_SELECTION), g = h(De, {
              "aria-label": `${w ? "Deselect" : "Select"} all rows`,
              disabled: y,
              key: R,
              selected: w,
              indeterminate: F,
              onChange: (E, T) => {
                Se(E, T);
              }
            }, null), C = (E, T) => Se(E, T);
            return ne(d) ? d({
              selected: w,
              record: e,
              originNode: g,
              inHeader: t,
              disabled: y,
              indeterminate: F,
              selectAll: C
            }) : g;
          } else {
            const R = u.getRecordKey(e), g = c.has(R), E = h(De, {
              "aria-label": `${g ? "Deselect" : "Select"} this row`,
              getCheckboxProps: () => typeof r == "function" ? r(e) : {},
              selected: g,
              onChange: (A, x) => me(A, R, x)
            }, null), T = (A, x) => me(A, R, x);
            return ne(d) ? d({
              selected: g,
              record: e,
              index: o,
              originNode: E,
              inHeader: !1,
              disabled: y,
              indeterminate: F,
              selectRow: T
            }) : E;
          }
        }
        return null;
      }, lt = (e, t = {}, o) => z(t, !1, o), at = () => z(void 0, !0), it = (e = {}) => {
        const {
          rowSelection: t,
          prefixCls: o
        } = e;
        let a = {};
        if (t) {
          const s = ["selectedRowKeys", "selectedRowKeysSet"];
          a = {
            key: D.DEFAULT_KEY_COLUMN_SELECTION
          }, I(t) && (a = {
            ...a,
            ...Te(t, s)
          }), a.className = M(a.className, `${o}-column-selection`), a.title = at, a.render = lt;
        }
        return a;
      }, J = (e = {}, t = !1, o = null) => {
        const {
          expandedRowKeys: a
        } = l, {
          expandIcon: s
        } = i, f = typeof o == "string" || typeof o == "number" ? o : u.getRecordKey(e);
        return h(Vt, {
          key: f,
          componentType: t ? "tree" : "expand",
          expanded: Dt(a, f),
          expandIcon: s,
          onClick: (c, r) => he(c, f, r)
        }, null);
      }, he = (...e) => u.handleRowExpanded(...e), st = (e = {}) => {
        let t = null;
        const {
          prefixCls: o,
          expandCellFixed: a,
          expandIcon: s
        } = e;
        return t = {
          fixed: a,
          key: D.DEFAULT_KEY_COLUMN_EXPAND
        }, t.className = M(t.className, `${o}-column-expand`), t.render = s !== !1 ? (f = "", c, r) => P.mergedRowExpandable(c) ? J(c) : null : () => null, t;
      }, rt = (e = {}) => {
        const {
          prefixCls: t
        } = i;
        if (e && (e.sorter || e.filters || e.onFilter || e.useFullRender)) {
          let o = typeof e.sorter == "function" || e.sorter === !0, a = Array.isArray(e.filters) && e.filters.length || te(e.filterDropdown) || typeof e.renderFilterDropdown == "function", s = !1;
          const c = !("sortOrder" in e) && e.showSortTip === !0, {
            dataIndex: r,
            title: y,
            useFullRender: d
          } = e, m = o && !a && !d, p = u.getQuery(r), w = {}, S = [];
          d && (w.selection = z(null, !0));
          const F = b(p, "sortOrder"), R = b(p, "defaultSortOrder", !1), g = u.isSortOrderValid(F) ? F : R, C = Nt(e.ellipsis), E = typeof y != "function" && h("span", {
            class: `${t}-row-head-title`,
            key: D.DEFAULT_KEY_COLUMN_TITLE,
            title: C && typeof y == "string" ? y : void 0
          }, [y]);
          if (o) {
            const K = h(Mt, {
              key: D.DEFAULT_KEY_COLUMN_SORTER,
              sortOrder: g,
              sortIcon: e.sortIcon,
              onClick: d || a ? (L) => u.handleSort(e, L) : null,
              title: E,
              showTooltip: !m && c
            }, null);
            d && (w.sorter = K), s = !0, S.push(K);
          } else
            S.push(E);
          const T = b(p, "filteredValue"), A = b(p, "defaultFilteredValue"), x = T || A;
          if (a) {
            const K = h(Ut, ee({
              key: D.DEFAULT_KEY_COLUMN_FILTER
            }, {
              ...vt(p, ...Object.keys(jt)),
              onFilterDropdownVisibleChange: (L) => u.toggleShowFilter(r, L)
            }, {
              filteredValue: x,
              onSelect: (L) => {
                u.handleFilterSelect(r, L);
              }
            }), null);
            d && (w.filter = K), s = !0, S.push(K);
          }
          const v = typeof y == "function" ? () => y(w) : s ? h("div", {
            class: `${t}-operate-wrapper`
          }, [S]) : S;
          e = {
            ...e,
            title: v
          }, m && (e.clickToSort = (K) => {
            u.handleSort(e, K);
          }, e.sortOrder = g, e.showSortTip = c);
        }
        return e;
      }, me = (e, t, o) => {
        u.handleSelectRow(t, e, o);
      }, Se = (e, t) => {
        u.handleSelectAllRow(e, t);
      }, dt = (e, t) => {
        if (!e)
          return null;
        const o = u.memoizedPagination(e);
        return h(Ae, {
          componentName: "Table"
        }, {
          default: (a) => {
            const s = u.formatPaginationInfo(o, a.pageText);
            return h(zt, {
              info: s,
              pagination: o,
              renderPagination: t
            }, null);
          }
        });
      }, ct = (e = {}) => {
        let {
          title: t
        } = e;
        const {
          prefixCls: o,
          dataSource: a
        } = e;
        return typeof t == "function" && (t = t(a)), te(t) || typeof t == "string" ? h("div", {
          class: `${o}-title`,
          "x-semi-prop": "title"
        }, [t]) : null;
      }, ut = (e = {}) => {
        const {
          prefixCls: t,
          empty: o,
          dataSource: a
        } = e, s = `${t}-placeholder`;
        return u.isEmpty(a) ? h(Ae, {
          componentName: "Table",
          key: "emptyText"
        }, {
          default: (c, r) => h("div", {
            class: s
          }, [h("div", {
            class: `${t}-empty`,
            "x-semi-prop": "empty"
          }, [o || c.emptyText])])
        }) : null;
      }, ft = (e = {}) => {
        let {
          footer: t
        } = e;
        const {
          prefixCls: o,
          dataSource: a
        } = e;
        return typeof t == "function" && (t = t(a)), te(t) || typeof t == "string" ? h("div", {
          class: `${o}-footer`,
          key: "footer",
          "x-semi-prop": "footer"
        }, [t]) : null;
      }, yt = (e) => {
        const t = P.useFixedHeader(), o = ut(e);
        return [pt({
          ...e,
          fixed: !1,
          useFixedHeader: t,
          headerRef: qe,
          bodyRef: O,
          includeHeader: !t,
          emptySlot: o
        }), ft(e)];
      }, pt = (e) => {
        const {
          columns: t,
          filteredColumns: o,
          fixed: a,
          useFixedHeader: s,
          scroll: f,
          prefixCls: c,
          anyColumnFixed: r,
          includeHeader: y,
          showHeader: d,
          components: m,
          headerRef: p,
          bodyRef: w,
          onHeaderRow: S,
          rowSelection: F,
          dataSource: R,
          bodyHasScrollBar: g,
          disabledRowKeysSet: C,
          sticky: E
        } = e, T = b(F, "selectedRowKeysSet", /* @__PURE__ */ new Set()), A = P.getTableLayout(), x = a || s ? h(qt, {
          key: "head",
          tableLayout: A,
          ref: p,
          columns: o,
          prefixCls: c,
          fixed: a,
          handleBodyScroll: pe,
          components: m,
          scroll: f,
          showHeader: d,
          selectedRowKeysSet: T,
          onHeaderRow: S,
          dataSource: R,
          bodyHasScrollBar: g,
          sticky: E
        }, null) : null, v = h(Gt, ee(Te(e, ["rowSelection", "headWidths", "allDisabledRowKeys", "allDisabledRowKeysSet"]), {
          key: "body",
          forwardedRef: w,
          columns: o,
          fixed: a,
          prefixCls: c,
          handleWheel: et,
          handleBodyScroll: ot,
          anyColumnFixed: r,
          tableLayout: A,
          includeHeader: y,
          showHeader: d,
          scroll: f,
          components: m,
          store: ye,
          selectedRowKeysSet: T,
          disabledRowKeysSet: C
        }), null);
        return [x, v];
      };
      function be(e, t) {
        const {
          hideExpandedColumn: o,
          scroll: a,
          prefixCls: s,
          expandCellFixed: f,
          expandIcon: c,
          rowSelection: r
        } = i, y = "children";
        let d = q(t);
        const m = (p = []) => {
          Array.isArray(p) && p.length && Lt(p, (w, S, F) => {
            const R = rt(w), g = w[y];
            if (Array.isArray(g) && g.length) {
              const C = [...g];
              m(C), R[y] = C;
            }
            F[S] = R;
          });
        };
        if (m(d), !o) {
          const p = st({
            prefixCls: s,
            expandCellFixed: f,
            expandIcon: c
          }), w = Ke(d, (S) => S.key === D.DEFAULT_KEY_COLUMN_EXPAND);
          p && (w > -1 ? d[w] = {
            ...p,
            ...d[w]
          } : p.fixed === "right" ? d = [...d, p] : d = [p, ...d]);
        }
        if (r && !b(r, "hidden")) {
          const p = Ke(d, (S) => S.key === D.DEFAULT_KEY_COLUMN_SELECTION), w = it({
            rowSelection: r,
            prefixCls: s
          });
          p > -1 ? d[p] = {
            ...w,
            ...d[p]
          } : w.fixed === "right" ? d = [...d, w] : d = [w, ...d];
        }
        return It(d), d;
      }
      const wt = (e, t) => (console.error("TODO"), q(X(e, t)));
      function gt(e) {
        return {
          onChange: u.setPage,
          ...e
        };
      }
      return Ie({
        getCurrentPageData: Ge
      }), () => {
        let {
          scroll: e,
          prefixCls: t,
          className: o,
          style: a = {},
          bordered: s,
          id: f,
          pagination: c,
          virtualized: r,
          size: y,
          renderPagination: d,
          getVirtualizedListRef: m,
          loading: p,
          hideExpandedColumn: w,
          rowSelection: S,
          children: F,
          ...R
        } = Ne(i);
        const g = {
          ...i.style
        };
        let C;
        if (P.isAnyColumnUseFullRender(l.queries))
          C = be(l.queries, l.cachedColumns);
        else {
          const mt = S && !b(S, "hidden");
          C = u.memoizedWithFnsColumns(
            l.queries,
            l.cachedColumns,
            mt,
            w,
            // Update the columns after the body scrollbar changes to ensure that the head and body are aligned
            l.bodyHasScrollBar
          );
        }
        const E = u.memoizedFilterColumns(C), T = u.memoizedFlattenFnsColumns(C), A = P.isAnyColumnFixed(C), x = {
          ...Et(l)
        }, v = {
          ...R,
          ...x,
          // props not in rest
          virtualized: r,
          scroll: e,
          prefixCls: t,
          size: y,
          hideExpandedColumn: w,
          // renamed state
          columns: C,
          // calculated value
          anyColumnFixed: A,
          rowExpandable: Xe,
          pagination: l.pagination,
          dataSource: l.dataSource,
          rowSelection: l.rowSelection,
          expandedRowKeys: l.expandedRowKeys,
          renderExpandIcon: J,
          filteredColumns: E
        }, K = b(e, "x"), L = b(e, "y");
        r && (isNaN(parseInt("" + g.width)) ? g.width = K + "px" : g.width = typeof g.width == "string" ? g.width : g.width + "px");
        const k = M({
          [`${t}-${D.SIZE_SMALL}`]: y === D.SIZE_SMALL,
          [`${t}-${D.SIZE_MIDDLE}`]: y === D.SIZE_MIDDLE,
          [`${t}-virtualized`]: !!r,
          [`${t}-bordered`]: s,
          [`${t}-fixed-header`]: !!L,
          [`${t}-scroll-position-left`]: ["both", "left"].includes(se),
          [`${t}-scroll-position-right`]: ["both", "right"].includes(se)
        }), U = l.pagination && c ? dt(l.pagination, d) : null, _ = b(c, "position", "bottom"), Re = {
          ..._e.value,
          headWidths: l.headWidths,
          tableWidth: l.tableWidth,
          anyColumnFixed: A,
          flattenedColumns: T,
          renderExpandIcon: J,
          renderSelection: z,
          setHeadWidths: Qe,
          getHeadWidths: Ze,
          getCellWidths: Ye,
          handleRowExpanded: he,
          getVirtualizedListRef: m,
          setBodyHasScrollbar: Je
        };
        i.direction && (Re.direction = i.direction);
        const ht = Be();
        return h("div", ee({
          ref: B,
          class: M(o, `${t}-wrapper`, `${t}-wrapper-${i.direction}`),
          "data-column-fixed": A,
          style: g,
          id: f
        }, ht), [h($t, Re, {
          default: () => [h(Bt, {
            spinning: p,
            size: "large"
          }, {
            default: () => [h("div", {
              ref: ue,
              class: k
            }, [h(xe, {
              key: "pagination-top"
            }, [["top", "both"].includes(_) ? U : null]), " ", ct({
              title: i.title,
              dataSource: i.dataSource,
              prefixCls: i.prefixCls
            }), h("div", {
              class: `${t}-container`
            }, [yt({
              ...v
            })]), h(xe, {
              key: "pagination-bottom"
            }, [["bottom", "both"].includes(_) ? U : null])])]
          })]
        })]);
      };
    }
  });
}
export {
  Xt as TablePropTypes,
  To as default
};
//# sourceMappingURL=Table.js.map
