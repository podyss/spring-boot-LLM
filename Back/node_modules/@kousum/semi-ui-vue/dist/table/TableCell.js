import { defineComponent as Y, useSlots as Z, ref as ee, reactive as te, watch as ne, createVNode as C, mergeProps as oe, isVNode as _, Fragment as N } from "vue";
import D from "classnames";
import * as e from "../PropTypes";
import { vuePropsMake as le } from "../PropTypes";
import { noop as A, get as R, set as S, omit as ie, merge as se } from "lodash";
import { numbers as re, cssClasses as ce } from '@douyinfe/semi-foundation/lib/es/table/constants';
import fe from '@douyinfe/semi-foundation/lib/es/table/cellFoundation';
import { shouldShowEllipsisTitle as de, getRTLAlign as ae, getRTLFlexAlign as ue } from '@douyinfe/semi-foundation/lib/es/table/utils';
import { useBaseComponent as pe } from "../_base/baseComponent";
import { amendTableWidth as me } from "./utils";
import { useTableContext as xe } from "./tableContext/Consumer";
import { styleNum as ye } from "../_utils";
function ge(l) {
  return typeof l == "function" || Object.prototype.toString.call(l) === "[object Object]" && !_(l);
}
function U(l) {
  return l && !_(l) && Object.prototype.toString.call(l) === "[object Object]";
}
const be = {
  record: e.object,
  prefixCls: e.string,
  index: e.number,
  fixedLeft: e.oneOfType([e.bool, e.number]),
  lastFixedLeft: e.bool,
  fixedRight: e.oneOfType([e.bool, e.number]),
  firstFixedRight: e.bool,
  indent: e.number,
  indentSize: e.number,
  column: e.object,
  expandIcon: e.any,
  renderExpandIcon: e.func,
  hideExpandedColumn: e.bool,
  component: e.any,
  onClick: e.func,
  onDidUpdate: e.func,
  isSection: e.bool,
  width: e.oneOfType([e.string, e.number]),
  height: e.oneOfType([e.string, e.number]),
  selected: e.bool,
  expanded: e.bool,
  colIndex: e.number,
  disabled: e.bool,
  style: e.object,
  className: e.string
}, he = {
  indent: 0,
  indentSize: re.DEFAULT_INDENT_WIDTH,
  onClick: A,
  prefixCls: ce.PREFIX,
  component: "td",
  onDidUpdate: A,
  column: {}
}, Ce = le(be, he), Oe = /* @__PURE__ */ Y({
  props: {
    ...Ce
  },
  name: "TableCell",
  setup(l, {}) {
    Z();
    let {
      context: F
    } = xe();
    const O = ee(), $ = te({}), {
      adapter: z
    } = pe(l, $);
    function W() {
      return {
        ...z(),
        notifyClick: (...n) => {
          const {
            onClick: o
          } = l;
          typeof o == "function" && o(...n);
        }
      };
    }
    const I = W(), B = new fe(I);
    ne([() => l, $], () => {
      l.onDidUpdate(O.value);
    });
    const V = (n) => {
      B.handleClick(n);
      const o = I.getCache("customCellProps");
      o && typeof o.onClick == "function" && o.onClick(n);
    };
    function H() {
      var x, g, b, y;
      const {
        record: n,
        index: o,
        column: f = {},
        fixedLeft: a,
        fixedRight: s,
        width: p,
        height: m
      } = l;
      let t = {}, u = {};
      const {
        direction: r
      } = F.value, c = r === "rtl";
      if (a || typeof a == "number" ? S(t, c ? "style.right" : "style.left", typeof a == "number" ? a : 0) : (s || typeof s == "number") && S(t, c ? "style.left" : "style.right", typeof s == "number" ? s : 0), p != null && S(t, "style.width", p + "px"), m != null && S(t, "style.height", m + "px"), (x = t.style) != null && x.left && typeof ((g = t.style) == null ? void 0 : g.left) == "number" && (t.style.left = t.style.left + "px"), (b = t.style) != null && b.right && typeof ((y = t.style) == null ? void 0 : y.right) == "number" && (t.style.right = t.style.right + "px"), f.onCell) {
        u = f.onCell(n, o), I.setCache("customCellProps", {
          ...u
        }), t = {
          ...t,
          ...ie(u, ["style", "className", "onClick"])
        };
        const d = R(u, "style") || {};
        t.style = {
          ...t.style,
          ...d
        };
      }
      if (f.align) {
        const d = ae(f.align, r), h = ue(f.align, r);
        t.style = {
          ...t.style,
          textAlign: d,
          justifyContent: h
        };
      }
      return {
        tdProps: t,
        customCellProps: u
      };
    }
    function M(n) {
      const {
        record: o,
        indentSize: f,
        prefixCls: a,
        indent: s,
        index: p,
        expandIcon: m,
        renderExpandIcon: t,
        column: u = {}
      } = l, {
        dataIndex: r,
        render: c,
        useFullRender: T
      } = u;
      let i, x, g;
      typeof r == "number" ? i = R(o, r) : !r || r.length === 0 ? i = o : i = R(o, r);
      const b = s && f ? C("span", {
        style: {
          paddingLeft: `${f * s}px`
        },
        class: `${a}-row-indent indent-level-${s}`
      }, null) : null, y = typeof t == "function" ? t(o) : m;
      if (c) {
        const d = {
          expandIcon: y
        };
        if (T) {
          const {
            renderSelection: h
          } = F.value, L = typeof h == "function" ? h(o) : null;
          Object.assign(d, {
            selection: L,
            indentText: b
          });
        }
        i = c(i, o, p, d), U(i) && (n = i.props ? se(n, i.props) : n, x = n.colSpan, g = n.rowSpan, i = i.children);
      }
      return {
        text: i,
        indentText: b,
        rowSpan: g,
        colSpan: x,
        realExpandIcon: y,
        tdProps: n
      };
    }
    function X(n, o, f) {
      const {
        prefixCls: a,
        isSection: s,
        expandIcon: p,
        column: m = {}
      } = l, {
        tableWidth: t,
        anyColumnFixed: u
      } = F.value, {
        useFullRender: r
      } = m;
      let c = null;
      return r ? c = n : c = [C(N, {
        key: "indentText"
      }, [o]), C(N, {
        key: "expandIcon"
      }, [p ? f : null]), C(N, {
        key: "text"
      }, [n])], s && (c = C("div", {
        class: D(`${a}-section-inner`),
        style: {
          width: u ? ye(me(t)) : void 0
        }
      }, [c])), c;
    }
    const q = (n) => O.value = n;
    return () => {
      const {
        prefixCls: n,
        column: o = {},
        component: f,
        fixedLeft: a,
        fixedRight: s,
        lastFixedLeft: p,
        firstFixedRight: m,
        colIndex: t
      } = l, {
        direction: u
      } = F.value, r = u === "rtl", {
        className: c,
        ellipsis: T
      } = o, i = a || typeof a == "number", x = s || typeof s == "number", {
        tdProps: g,
        customCellProps: b
      } = H(), y = M(g);
      let {
        text: d
      } = y;
      const {
        indentText: h,
        rowSpan: L,
        colSpan: G,
        realExpandIcon: J,
        tdProps: K
      } = y;
      let E;
      if (de(T) && typeof d == "string" && (E = d), L === 0 || G === 0)
        return null;
      U(d) && (d = null);
      const w = X(d, h, J);
      let k, j, v, P;
      r ? (k = x, j = m, v = i, P = p) : (k = i, j = p, v = x, P = m);
      const Q = D(c, `${n}-row-cell`, R(b, "className"), {
        [`${n}-cell-fixed-left`]: k,
        [`${n}-cell-fixed-left-last`]: j,
        [`${n}-cell-fixed-right`]: v,
        [`${n}-cell-fixed-right-first`]: P,
        [`${n}-row-cell-ellipsis`]: T
      });
      return C(f, oe({
        role: "gridcell",
        "aria-colindex": t + 1,
        className: Q,
        onClick: V,
        title: E
      }, K, {
        ref: q
      }), ge(w) ? w : {
        default: () => [w]
      });
    };
  }
});
export {
  Oe as default,
  Ce as vuePropsType
};
//# sourceMappingURL=TableCell.js.map
