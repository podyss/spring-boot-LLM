import { defineComponent as xe, useSlots as be, ref as U, reactive as ve, watch as J, nextTick as Se, createVNode as b, mergeProps as W, Fragment as ge } from "vue";
import * as e from "../../PropTypes";
import { vuePropsMake as ze } from "../../PropTypes";
import { get as w, isEqual as Ce, size as P, isMap as Q, isFunction as Ee, pick as Z, each as Be, isNull as Te } from "lodash";
import j from "classnames";
import { VariableSizeList as Ke } from "@kousum/vue3-window";
import { isTreeTable as We, getDefaultVirtualizedRowConfig as ke, getRecord as _, getRecordKey as L, genExpandedRowKey as Ie, isExpanded as V, isSelected as Pe, isDisabled as je, arrayAdd as Le } from '@douyinfe/semi-foundation/lib/es/table/utils';
import Oe from '@douyinfe/semi-foundation/lib/es/table/bodyFoundation';
import { strings as Ae } from '@douyinfe/semi-foundation/lib/es/table/constants';
import { useBaseComponent as Ve } from "../../_base/baseComponent";
import { logger as H } from "../utils";
import He from "../ColGroup";
import Ne, { BaseRowPropTypes as De } from "./BaseRow";
import Fe from "./ExpandedRow";
import qe, { SectionRowPropTypes as $e } from "./SectionRow";
import Ge from "../TableHeader";
import { useTableContext as Me } from "../tableContext/Consumer";
const Ye = {
  anyColumnFixed: e.bool,
  childrenRecordName: e.string,
  columns: e.array,
  components: e.object,
  dataSource: e.array,
  disabledRowKeysSet: {
    type: e.object,
    required: !0
  },
  emptySlot: e.node,
  expandRowByClick: e.bool,
  expandedRowKeys: e.array,
  expandedRowRender: e.func,
  fixed: e.oneOfType([e.string, e.bool]),
  forwardedRef: e.oneOfType([e.object, e.func]),
  groups: e.object,
  handleBodyScroll: e.func,
  handleWheel: e.func,
  headerRef: e.oneOfType([e.object, e.func]),
  includeHeader: e.bool,
  onScroll: e.func,
  prefixCls: e.string,
  renderExpandIcon: {
    type: e.func,
    required: !0
  },
  rowExpandable: e.func,
  rowKey: e.oneOfType([e.string, e.bool, e.func]),
  scroll: e.object,
  selectedRowKeysSet: {
    type: e.object,
    required: !0
  },
  showHeader: e.bool,
  size: e.string,
  store: {
    type: e.object,
    required: !0
  },
  virtualized: e.oneOfType([e.bool, e.object]),
  tableWidth: e.number,
  tableLayout: e.any,
  expandIcon: e.any,
  expandCellFixed: e.any,
  title: e.any,
  indentSize: e.any,
  defaultExpandAllRows: e.any,
  expandAllRows: e.any,
  defaultExpandAllGroupRows: e.any,
  expandAllGroupRows: e.any,
  defaultExpandedRowKeys: e.any,
  footer: e.any,
  empty: e.any,
  groupBy: e.any,
  renderGroupSection: e.any,
  clickGroupedRowToExpand: e.any,
  dropdownPrefixCls: e.any,
  cachedColumns: e.any,
  cachedChildren: e.any,
  flattenColumns: e.any,
  queries: e.any,
  flattenData: e.any,
  pagination: e.any,
  allRowKeys: e.any,
  disabledRowKeys: e.any,
  bodyHasScrollBar: e.any,
  prePropRowSelection: e.any,
  prePagination: e.any,
  hideExpandedColumn: e.any,
  filteredColumns: e.any,
  useFixedHeader: e.any,
  bodyRef: e.any,
  onExpandedRowsChange: e.func,
  onExpand: e.func,
  onChange: e.func,
  onRow: e.func,
  bodyWrapperRef: [e.func, e.object],
  onGroupedRow: e.func,
  keepDOM: e.bool,
  style: e.object,
  className: e.string
}, Xe = ze(Ye, {}), fn = /* @__PURE__ */ xe({
  props: {
    ...Xe
  },
  name: "Body",
  setup(i, {}) {
    be();
    const T = U(), N = U();
    let C, O, K;
    const {
      context: R
    } = Me(), x = ve({
      virtualizedData: [],
      cache: {
        virtualizedScrollTop: null,
        virtualizedScrollLeft: null
      },
      cachedExpandBtnShouldInRow: null,
      cachedExpandRelatedProps: []
    });
    let k;
    k = J(() => R.value.getVirtualizedListRef, (n) => {
      var o, t;
      K = R.value.flattenedColumns, O = (t = (o = R.value).getCellWidths) == null ? void 0 : t.call(o, K), k == null || k();
    }, {
      immediate: !0
    }), C = null;
    const {
      adapter: ee
    } = Ve(i, {});
    function ne() {
      return {
        ...ee(),
        setVirtualizedData: (n, o) => {
          x.virtualizedData = n, Se(o);
        },
        setCachedExpandBtnShouldInRow: (n) => x.cachedExpandBtnShouldInRow = n,
        setCachedExpandRelatedProps: (n) => x.cachedExpandRelatedProps = n,
        observeBodyResize: (n) => {
          const {
            setBodyHasScrollbar: o
          } = R.value, t = () => {
            const l = () => {
              const {
                offsetWidth: a,
                clientWidth: d
              } = n, s = d < a;
              o(s);
            };
            (window.requestAnimationFrame || window.setTimeout)(l);
          };
          n && (w(window, "ResizeObserver") ? (C && (C.unobserve(n), C = null), C = new ResizeObserver(t), C.observe(n)) : H.warn("The current browser does not support ResizeObserver,and the table may be misaligned after plugging and unplugging the mouse and keyboard.You can try to refresh it."));
        },
        unobserveBodyResize: () => {
          const n = T.value;
          C && (C.unobserve(n), C = null);
        }
      };
    }
    const oe = ne(), I = new Oe(oe);
    J([() => i.virtualized, () => i.dataSource, () => i.expandedRowKeys, () => i.columns, () => i.scroll, () => x.cachedExpandRelatedProps], (n, [o, t, l, r, a, d]) => {
      const {
        virtualized: s,
        dataSource: m,
        expandedRowKeys: u,
        columns: c,
        scroll: h
      } = i;
      s && (t !== m || l !== u || r !== c) && I.initVirtualizedData();
      const p = Ae.EXPAND_RELATED_PROPS.map((g) => w(i, g, void 0));
      d && !Ce(p, d) && I.initExpandBtnShouldInRow(p);
      const f = w(h, "y"), v = T.value;
      f && f !== (a == null ? void 0 : a.y) && I.observeBodyResize(v);
    }, {
      immediate: !0
    });
    const D = (n) => {
      const {
        forwardedRef: o
      } = i;
      T.value = n, I.observeBodyResize(n), typeof o == "function" ? o(n) : o && typeof o == "object" && (o.value = n);
    }, te = (n) => {
      N.value = n;
      const {
        getVirtualizedListRef: o
      } = R.value;
      o && (i.virtualized ? o(N.value) : console.warn("getVirtualizedListRef only works with virtualized. See https://semi.design/en-US/show/table for more information."));
    }, le = (n) => {
      const {
        virtualized: o,
        size: t
      } = i, {
        virtualizedData: l
      } = x, r = w(l, n), a = ke(t, r.sectionRow), d = w(o, "itemSize", a.height);
      let s = d;
      return typeof d == "function" && (s = d(n, {
        expandedRow: w(r, "expandedRow", !1),
        sectionRow: w(r, "sectionRow", !1)
      })), s < a.minHeight && H.warn(`The computed real \`itemSize\` cannot be less than ${a.minHeight}`), s;
    }, ae = (n, o) => w(o, [n, "key"], n), re = (n, o, t) => {
      const {
        handleRowExpanded: l
      } = R.value;
      l(!t, n, o);
    }, F = (n = {}) => {
      const o = w(i.virtualized, "onScroll");
      typeof o == "function" && o(n);
    }, de = (n) => {
      const {
        handleBodyScroll: o
      } = i, t = w(n, "nativeEvent.target.scrollLeft"), l = w(n, "nativeEvent.target.scrollTop");
      l === x.cache.virtualizedScrollTop && F({
        horizontalScrolling: !0
      }), x.cache.virtualizedScrollLeft = t, x.cache.virtualizedScrollTop = l, typeof o == "function" && o(n);
    }, q = () => {
      const {
        getCellWidths: n
      } = R.value, {
        columns: o
      } = i, t = n(o);
      return Le(t, 0, P(o));
    }, ie = (n) => {
      const {
        index: o,
        style: t
      } = n, {
        virtualizedData: l,
        cachedExpandBtnShouldInRow: r
      } = x, {
        flattenedColumns: a
      } = R.value, d = w(l, [o], {}), {
        key: s,
        parentKeys: m,
        expandedRow: u,
        sectionRow: c,
        ...h
      } = d, y = q(), p = r, f = {
        ...i,
        style: {
          ...t,
          width: y + "px"
        },
        ...h,
        columns: a,
        index: o,
        expandBtnShouldInRow: p
      };
      return c ? $(f) : u ? G(f) : M(f);
    }, se = (n, {
      slots: o
    }) => {
      var t;
      return b("div", W(n, {
        onScroll: (...l) => {
          n.onScroll && n.onScroll(...l);
        },
        class: j(n.className, `${i.prefixCls}-tbody`),
        style: {
          ...n.style
        }
      }), [(t = o == null ? void 0 : o.default) == null ? void 0 : t.call(o)]);
    }, ce = (n, {
      slots: o
    }) => {
      var u;
      const {
        ...t
      } = n, {
        handleWheel: l,
        prefixCls: r,
        emptySlot: a,
        dataSource: d
      } = i, s = q(), m = j(`${r}`, `${r}-fixed`);
      return b("div", W(t, {
        onWheel: (...c) => {
          l && l(...c), t.onWheel && t.onWheel(...c);
        },
        onScroll: (...c) => {
          de(...c), t.onScroll && t.onScroll(...c);
        }
      }), [b("div", {
        style: {
          width: s + "px"
        },
        class: m
      }, [(u = o.default) == null ? void 0 : u.call(o)]), P(d) === 0 && a]);
    }, ue = (n) => {
      x.cache.virtualizedScrollLeft && T.value && (T.value.scrollLeft = x.cache.virtualizedScrollLeft);
    }, fe = (n) => {
      const {
        scroll: o,
        prefixCls: t,
        virtualized: l,
        columns: r
      } = i, {
        virtualizedData: a
      } = x, {
        getCellWidths: d
      } = R.value, s = d(r);
      if (!P(s))
        return null;
      const m = w(o, "y"), u = typeof m == "number", c = u ? m : 600;
      u || H.warn('You have to specific "scroll.y" which must be a number for table virtualization!');
      const h = {
        width: "100%",
        height: a != null && a.length ? c + "px" : null,
        overflowX: "auto",
        overflowY: "auto"
      }, y = j(`${t}-body`);
      return b(Ke, W(typeof l == "object" ? l : {}, {
        initialScrollOffset: x.cache.virtualizedScrollTop,
        onScroll: F,
        onItemsRendered: ue,
        ref: te,
        className: y,
        outerRef: D,
        height: a != null && a.length ? c : 0,
        width: h.width,
        itemData: a,
        itemSize: le,
        itemCount: a.length,
        itemKey: ae,
        innerElementType: se,
        outerElementType: ce,
        style: {
          ...h,
          direction: n
        },
        direction: n
      }), {
        default: ie
      });
    }, $ = (n = {
      groupKey: void 0
    }) => {
      const {
        dataSource: o,
        rowKey: t,
        group: l,
        groupKey: r,
        index: a
      } = n, d = Object.keys($e), s = Z(n, d), {
        handleRowExpanded: m
      } = R.value;
      return b(qe, W({
        ...s,
        onExpand: m,
        record: {
          groupKey: r,
          records: [...l].map((u) => _(o, u, t))
        },
        index: a,
        data: o
      }, {
        key: r || a
      }), null);
    }, G = (n = {
      renderExpandIcon: () => null
    }) => {
      const {
        style: o,
        components: t,
        renderExpandIcon: l,
        expandedRowRender: r,
        record: a,
        columns: d,
        expanded: s,
        index: m,
        rowKey: u,
        virtualized: c,
        displayNone: h
      } = n;
      let y = L(a, u);
      y == null && (y = m);
      const {
        getCellWidths: p
      } = R.value;
      return K !== R.value.flattenedColumns && (K = R.value.flattenedColumns, O = p(K)), b(Fe, {
        style: o,
        components: t,
        renderExpandIcon: l,
        expandedRowRender: r,
        record: a,
        columns: d,
        expanded: s,
        index: m,
        virtualized: c,
        key: Ie(y),
        cellWidths: O,
        displayNone: h
      }, null);
    };
    function M(n = {}) {
      const {
        rowKey: o,
        columns: t,
        expandedRowKeys: l,
        rowExpandable: r,
        record: a,
        index: d,
        level: s,
        expandBtnShouldInRow: m,
        // effect the display of the indent span
        selectedRowKeysSet: u,
        disabledRowKeysSet: c,
        expandRowByClick: h
      } = n, y = Object.keys(De), p = Z(n, y);
      let f = L(a, o);
      f == null && (f = d);
      const v = V(l, f), g = r && r(a), B = {
        level: void 0,
        expanded: v
      };
      (g || m) && (B.level = s, B.expandableRow = g, h && (B.onRowClick = re));
      const z = {
        selected: Pe(u, f),
        disabled: je(c, f)
      }, {
        getCellWidths: E
      } = R.value, S = E(t, null, !0);
      return (
        // 这里必须加Fragment，不然BaseRow会传入一个默认的props，来历不明？
        b(ge, null, [b(Ne, {
          ...p,
          ...B,
          ...z,
          key: f,
          rowKey: f,
          cellWidths: S
        }, null)])
      );
    }
    const ye = () => {
      const {
        groups: n,
        dataSource: o,
        rowKey: t,
        expandedRowKeys: l,
        keepDOM: r
      } = i, {
        flattenedColumns: a
      } = R.value, d = /* @__PURE__ */ new Map(), s = [];
      n != null && Array.isArray(o) && o.length && o.forEach((u) => {
        const c = L(u, t);
        n.forEach((h, y) => {
          if (h.has(c))
            return d.has(y) || d.set(y, /* @__PURE__ */ new Set([])), d.get(y).add(c), !1;
        });
      });
      let m = -1;
      return d.forEach((u, c) => {
        const h = V(l, c);
        if (s.push($({
          ...i,
          columns: a,
          index: ++m,
          group: u,
          groupKey: c,
          expanded: h
        })), h || r) {
          const y = [];
          u.forEach((p) => {
            const f = _(o, p, t);
            f != null && y.push(f);
          }), s.push(A(y, void 0, [], !h));
        }
      }), s;
    };
    function A(n = [], o = 0, t = [], l = !1) {
      const {
        rowKey: r,
        expandedRowRender: a,
        expandedRowKeys: d,
        childrenRecordName: s,
        rowExpandable: m,
        keepDOM: u
      } = i, c = typeof a == "function", h = x.cachedExpandBtnShouldInRow, {
        flattenedColumns: y
      } = R.value;
      return Be(n, (p, f) => {
        let v = L(p, r);
        v == null && (v = f);
        const g = w(p, s), B = !!(Array.isArray(g) && g.length);
        t.push(M({
          ...i,
          columns: y,
          expandBtnShouldInRow: h,
          displayNone: l,
          record: p,
          key: v,
          level: o,
          index: f
        }));
        const z = V(d, v), E = z || u;
        if (c && m && m(p) && E) {
          const S = G({
            ...i,
            columns: y,
            level: o,
            index: f,
            record: p,
            expanded: z,
            displayNone: l || !z
          });
          Te(S) || t.push(S);
        }
        if (B && E) {
          const S = A(g, o + 1);
          t.push(...S);
        }
      }), t;
    }
    const pe = (n) => {
      const {
        scroll: o,
        prefixCls: t,
        columns: l,
        components: r,
        fixed: a,
        handleWheel: d,
        headerRef: s,
        handleBodyScroll: m,
        anyColumnFixed: u,
        showHeader: c,
        emptySlot: h,
        includeHeader: y,
        dataSource: p,
        onScroll: f,
        groups: v,
        expandedRowRender: g,
        tableLayout: B
      } = i, z = w(o, "x"), E = w(o, "y"), S = {}, Y = {}, me = w(r, "body.outer", "table"), he = w(r, "body.wrapper") || "tbody";
      E && (S.maxHeight = typeof E == "string" ? E : E + "px"), z && (Y.width = typeof z == "string" ? z : z + "px"), u && P(p) && (S.overflow = "auto", S.WebkitTransform = "translate3d (0, 0, 0)");
      const we = b(He, {
        components: w(r, "body"),
        columns: l,
        prefixCls: t
      }, null), Re = `${t}-body`, X = b("div", {
        key: "bodyTable",
        class: Re,
        style: S,
        ref: D,
        onWheel: d,
        onScroll: m
      }, [b(me, {
        role: Q(v) || Ee(g) || We({
          dataSource: p
        }) ? "treegrid" : "grid",
        "aria-rowcount": p && p.length,
        "aria-colcount": l && l.length,
        style: Y,
        className: j(t, {
          [`${t}-fixed`]: B === "fixed"
        })
      }, {
        default: () => [we, y && c ? b(Ge, W(i, {
          ref: s,
          components: r,
          columns: l
        }), null) : null, b(he, {
          ref: i.bodyWrapperRef,
          className: `${t}-tbody`,
          onScroll: f
        }, {
          default: () => [Q(v) ? ye() : A(p)]
        })]
      }), h]);
      return a && l.length ? b("div", {
        key: "bodyTable",
        class: `${t}-body-outer`
      }, [X]) : X;
    };
    return () => {
      const {
        virtualized: n
      } = i, {
        direction: o
      } = R.value;
      return n ? fe(o) : pe();
    };
  }
});
export {
  Ye as BodyPropTypes,
  fn as default,
  Xe as vuePropsType
};
//# sourceMappingURL=index.js.map
