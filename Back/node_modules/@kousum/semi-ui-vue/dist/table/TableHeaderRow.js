import { defineComponent as U, useSlots as Y, reactive as Z, watch as ee, createVNode as C, mergeProps as B, isVNode as te } from "vue";
import j from "classnames";
import * as t from "../PropTypes";
import { vuePropsMake as oe } from "../PropTypes";
import { noop as re, get as x, set as se, map as q, findIndex as le, omit as W } from "lodash";
import { cssClasses as ne } from '@douyinfe/semi-foundation/lib/es/table/constants';
import { sliceColumnsByLevel as ie, getRTLAlign as ce, isFixedRight as O, isFixedLeft as F, isFirstFixedRight as z, isLastLeftFixed as E, arrayAdd as V } from '@douyinfe/semi-foundation/lib/es/table/utils';
import { useBaseComponent as ae } from "../_base/baseComponent";
import { useTableContext as fe } from "./tableContext/Consumer";
import de from "../tooltip";
import pe from "../locale/localeConsumer";
import { getNextSortOrder as me } from "./utils";
function I(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !te(s);
}
const ue = {
  components: t.object,
  row: t.array,
  prefixCls: t.string,
  onHeaderRow: t.func,
  index: t.oneOfType([t.string, t.number]),
  style: t.object,
  columns: t.array,
  fixed: t.oneOfType([t.bool, t.string]),
  selectedRowKeysSet: {
    type: t.object,
    required: !0
  }
}, ye = {
  onHeaderRow: re,
  prefixCls: ne.PREFIX,
  columns: [],
  components: {
    header: {
      wrapper: "thead",
      row: "tr",
      cell: "th"
    }
  }
}, he = oe(ue, ye), Le = /* @__PURE__ */ U({
  props: {
    ...he
  },
  name: "TableHeaderRow",
  setup(s, {}) {
    Y();
    let k = null;
    const {
      context: S
    } = fe(), M = Z({}), {
      adapter: X
    } = ae(s, M);
    X();
    const A = (l) => {
      if (k = l, l && S.value.setHeadWidths) {
        const {
          prefixCls: u,
          row: o,
          index: T
        } = s, f = `.${u}-row-head`, R = l && l.querySelectorAll && l.querySelectorAll(f);
        S.value.setHeadWidths(q(R, (y, d) => {
          let p = x(o, [d, "column", "width"]);
          const h = x(o, [d, "column", "key"]);
          return typeof p != "number" && (p = y && y.getBoundingClientRect().width || 0), {
            width: p,
            key: h
          };
        }), T);
      }
    };
    return ee(() => s.columns, (l, u, o) => {
      u !== s.columns && k && A(k);
    }), () => {
      const {
        components: l,
        row: u,
        prefixCls: o,
        onHeaderRow: T,
        index: f,
        style: R,
        columns: y
      } = s, {
        getCellWidths: d,
        direction: p
      } = S.value, h = p === "rtl", n = ie(y, f), b = (d == null ? void 0 : d(n)) || [], _ = x(l, "header.row", "tr"), D = x(l, "header.cell", "th"), N = T(y, f) || {};
      se(N, "className", j(x(N, "className"), `${o}-row`));
      const P = q(u, (G, g) => {
        const {
          column: e,
          ...K
        } = G, m = typeof e.onHeaderCell == "function" ? e.onHeaderCell(e, g, f) : {};
        let i = {
          ...m.style
        };
        if (e.align) {
          const r = ce(e.align, p);
          i = {
            ...i,
            textAlign: r
          }, m.className = j(m.className, e.className, {
            [`${o}-align-${r}`]: !!r
          });
        }
        let H, L, $, v;
        if (h ? (H = O(e), L = F(e), $ = z(n, e), v = E(n, e)) : (H = F(e), L = O(e), $ = E(n, e), v = z(n, e)), m.className = j(
          `${o}-row-head`,
          e.className,
          m.className,
          // `${prefixCls}-fixed-columns`,
          {
            [`${o}-cell-fixed-left`]: H,
            [`${o}-cell-fixed-left-last`]: $,
            [`${o}-cell-fixed-right`]: L,
            [`${o}-cell-fixed-right-first`]: v,
            [`${o}-row-head-ellipsis`]: e.ellipsis
          }
        ), b.length && n.length) {
          const r = le(n, (a) => a && a.key != null && a.key === e.key);
          r > -1 && (F(e) ? i = {
            ...i,
            position: "sticky",
            [h ? "right" : "left"]: V(b, 0, r) + "px"
          } : O(e) && (i = {
            ...i,
            position: "sticky",
            [h ? "left" : "right"]: V(b, r + 1) + "px"
          }));
        }
        Object.assign(K, {
          resize: e.resize
        });
        const c = W({
          ...K,
          ...m
        }, ["colStart", "colEnd", "hasSubColumns", "parents", "level"]), {
          rowSpan: J,
          colSpan: Q
        } = c;
        if (J === 0 || Q === 0)
          return null;
        typeof e.clickToSort == "function" && (c.onClick ? c.onClick = (r) => {
          c.onClick(r), e.clickToSort(r);
        } : c.onClick = e.clickToSort);
        const w = C(D, B({
          role: "columnheader",
          "aria-colindex": g + 1
        }, W(c, "children"), {
          style: i,
          key: e.key || e.dataIndex || g
        }), {
          default: () => [c.children]
        });
        if (typeof e.clickToSort == "function" && e.showSortTip === !0) {
          let r = me(e.sortOrder);
          return C(pe, {
            componentName: "Table",
            key: e.key || e.dataIndex || g
          }, {
            default: (a, xe) => C(de, {
              content: a[r]
            }, I(w) ? w : {
              default: () => [w]
            })
          });
        }
        return w;
      });
      return C(_, B({
        role: "row",
        "aria-rowindex": f + 1
      }, N, {
        style: R,
        ref: A
      }), I(P) ? P : {
        default: () => [P]
      });
    };
  }
});
export {
  Le as default,
  he as vuePropsType
};
//# sourceMappingURL=TableHeaderRow.js.map
