import { createVNode as u, defineComponent as ye, useSlots as ft, reactive as mt, ref as _, onMounted as gt, onUnmounted as ht, watch as vt, mergeProps as O, isVNode as bt, toRaw as E, nextTick as de, Fragment as k, createTextVNode as Ct } from "vue";
import * as n from "../PropTypes";
import { vuePropsMake as yt } from "../PropTypes";
import { FixedSizeList as wt } from "@kousum/vue3-window";
import S from "classnames";
import It from '@douyinfe/semi-foundation/lib/es/select/foundation';
import { cssClasses as St, numbers as we, strings as B } from '@douyinfe/semi-foundation/lib/es/select/constants';
import { useHasInProps as Ie, useBaseComponent as xt, getProps as Tt } from "../_base/baseComponent";
import { noop as x, isEqual as pe, get as ee, isNumber as Ot, isString as fe, isFunction as $t } from "lodash";
import te from "../tag";
import me from "../tag/group";
import Pt from "../overflowList/index";
import Lt from "../space/index";
import Et from "../typography/text";
import { LocaleConsumerFunc as kt } from "../locale/localeConsumer";
import ge from "../popover/index";
import { numbers as Mt } from '@douyinfe/semi-foundation/lib/es/popover/constants';
import Rt from '@douyinfe/semi-foundation/lib/es/utils/Event';
import { getOptionsFromGroup as Dt } from "./utils";
import ne from "./virtualRow";
import he from "../input";
import q from "./option";
import { default as $n } from "./option";
import Se from "./optionGroup";
import { default as Ln } from "./optionGroup";
import _t from "../spin";
import Ft from "../trigger";
import { IconChevronDown as At, IconClear as zt, IconSearch as Vt } from "@kousum/semi-icons-vue";
import { getFragmentChildren as Nt, getFocusableElements as Ht, getActiveElement as Gt, isSemiIcon as ve } from "../_utils";
import be from '@douyinfe/semi-foundation/lib/es/utils/warning';
import { getUuidShort as Ce } from '@douyinfe/semi-foundation/lib/es/utils/uuid';
import '@douyinfe/semi-foundation/lib/es/select/select.css';
function D(r) {
  return typeof r == "function" || Object.prototype.toString.call(r) === "[object Object]" && !bt(r);
}
const i = St.PREFIX, jt = kt(), Wt = 0, Kt = {
  "aria-describedby": n.string,
  "aria-errormessage": n.string,
  "aria-invalid": n.bool,
  "aria-labelledby": n.string,
  "aria-label": n.string,
  "aria-required": n.bool,
  autoFocus: n.bool,
  autoClearSearchValue: n.bool,
  borderless: n.bool,
  defaultValue: n.oneOfType([n.string, n.number, n.array, n.object]),
  value: n.oneOfType([n.string, n.number, n.array, n.object]),
  placeholder: n.node,
  onChange: n.func,
  multiple: n.bool,
  // Whether to turn on the input box filtering function, when it is a function, it represents a custom filtering function
  filter: [n.func, n.bool],
  // How many tags can you choose?
  max: n.number,
  // How many tabs are displayed at most, and the rest are displayed in + N
  maxTagCount: n.number,
  maxHeight: n.oneOfType([n.string, n.number]),
  style: n.object,
  className: n.string,
  size: String,
  disabled: n.bool,
  emptyContent: n.node,
  onDropdownVisibleChange: n.func,
  zIndex: n.number,
  position: String,
  onSearch: n.func,
  getPopupContainer: n.func,
  dropdownClassName: n.string,
  dropdownStyle: n.object,
  outerTopSlot: n.node,
  innerTopSlot: n.node,
  inputProps: n.object,
  outerBottomSlot: n.node,
  innerBottomSlot: n.node,
  // Options slot
  optionList: n.array,
  // O
  dropdownMatchSelectWidth: n.bool,
  loading: n.bool,
  defaultOpen: n.bool,
  validateStatus: String,
  defaultActiveFirstOption: n.bool,
  triggerRender: n.func,
  stopPropagation: n.bool,
  // motion doesn't need to be exposed
  motion: n.oneOfType([n.func, n.bool, n.object]),
  onChangeWithObject: n.bool,
  suffix: n.node,
  prefix: n.node,
  insetLabel: n.node,
  insetLabelId: n.string,
  showClear: n.bool,
  showArrow: n.bool,
  renderSelectedItem: n.func,
  allowCreate: n.bool,
  renderCreateItem: n.func,
  onMouseEnter: n.func,
  onMouseLeave: n.func,
  clickToHide: n.bool,
  onExceed: n.func,
  onCreate: n.func,
  remote: n.bool,
  onDeselect: n.func,
  // The main difference between onSelect and onChange is that when multiple selections are selected, onChange contains all options, while onSelect only contains items for the current operation
  onSelect: n.func,
  autoAdjustOverflow: n.bool,
  mouseEnterDelay: n.number,
  mouseLeaveDelay: n.number,
  spacing: n.oneOfType([n.number, n.object]),
  onBlur: n.func,
  onFocus: n.func,
  onClear: n.func,
  virtualize: n.object,
  renderOptionItem: n.func,
  onListScroll: n.func,
  arrowIcon: n.node,
  preventScroll: n.bool,
  // open: PropTypes.bool,
  // tagClosable: PropTypes.bool,
  showRestTagsPopover: n.bool,
  restTagsPopoverProps: n.object,
  id: String,
  expandRestTagsOnClick: n.bool,
  ellipsisTrigger: n.bool,
  searchPosition: String,
  searchPlaceholder: String,
  clearIcon: n.node,
  dropdownMargin: [n.number, n.object],
  isInInputGroup: Boolean
}, Bt = {
  stopPropagation: !0,
  motion: !0,
  borderless: !1,
  zIndex: Mt.DEFAULT_Z_INDEX,
  // position: 'bottomLeft',
  filter: !1,
  multiple: !1,
  disabled: !1,
  defaultOpen: !1,
  allowCreate: !1,
  placeholder: "",
  onDropdownVisibleChange: x,
  onChangeWithObject: !1,
  onChange: x,
  onSearch: x,
  onMouseEnter: x,
  onMouseLeave: x,
  onDeselect: x,
  onSelect: x,
  onCreate: x,
  onExceed: x,
  onFocus: x,
  onBlur: x,
  onClear: x,
  onListScroll: x,
  maxHeight: we.LIST_HEIGHT,
  dropdownMatchSelectWidth: !0,
  defaultActiveFirstOption: !0,
  // In order to meet the needs of A11y, change to true
  showArrow: !0,
  showClear: !1,
  searchPosition: B.SEARCH_POSITION_TRIGGER,
  remote: !1,
  autoAdjustOverflow: !0,
  autoClearSearchValue: !0,
  arrowIcon: u(At, {
    "aria-label": ""
  }, null),
  // Radio selection is different from the default renderSelectedItem for multiple selection, so it is not declared here
  // renderSelectedItem: (optionNode) => optionNode.label,
  // The default creator rendering is related to i18, so it is not declared here
  // renderCreateItem: (input) => input
  showRestTagsPopover: !1,
  restTagsPopoverProps: {},
  expandRestTagsOnClick: !1,
  ellipsisTrigger: !1
}, xe = yt(Kt, Bt), qt = /* @__PURE__ */ ye({
  props: {
    ...xe,
    children: Array
  },
  name: "Select_",
  setup(r, {
    expose: U
  }) {
    ft();
    const h = mt({
      isOpen: !1,
      isFocus: !1,
      options: [],
      // All options
      selections: /* @__PURE__ */ new Map(),
      // A collection of all currently selected items, k: label, v: {value,... otherProps}
      dropdownMinWidth: null,
      optionKey: Wt,
      inputValue: "",
      showInput: !1,
      focusIndex: r.defaultActiveFirstOption ? 0 : -1,
      keyboardEventSet: {},
      optionGroups: [],
      isHovering: !1,
      isFocusInContainer: !1,
      isFullTags: !1,
      overflowItemCount: 0
    });
    let F = "", I = "", b = _(), N = _(), X = _(), H = _(), J = _();
    const Z = _();
    let A, g;
    A = null, be("optionLabelProp" in r, "[Semi Select] 'optionLabelProp' has already been deprecated, please use 'renderSelectedItem' instead."), be("labelInValue" in r, "[Semi Select] 'labelInValue' has already been deprecated, please use 'onChangeWithObject' instead.");
    const {
      hasInProps: Oe
    } = Ie(), G = new Rt(), {
      adapter: $e,
      context: oe,
      getDataAttr: Pe
    } = xt(r, h), Le = (t) => Z.value = t;
    function Ee() {
      const t = {
        registerKeyDown: (e) => {
          const o = {
            onKeyDown: e
          };
          h.keyboardEventSet = o;
        },
        unregisterKeyDown: () => {
          h.keyboardEventSet = {};
        },
        updateFocusIndex: (e) => {
          h.focusIndex = e;
        },
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        scrollToFocusOption: () => {
        }
      }, s = {
        updateInputValue: (e) => {
          h.inputValue = e;
        },
        toggleInputShow: (e, o) => {
          h.showInput = e, de(() => {
            o == null || o();
          });
        },
        focusInput: () => {
          const {
            preventScroll: e
          } = r;
          N.value && N.value.$el && N.value.$el.children[0].focus({
            preventScroll: e
          });
        },
        focusDropdownInput: () => {
          const {
            preventScroll: e
          } = r;
          X.value && X.value.focus({
            preventScroll: e
          });
        }
      }, c = {
        notifyMaxLimit: (e) => r.onExceed(e),
        getMaxLimit: () => r.max,
        registerClickOutsideHandler: (e) => {
          const o = (l) => {
            var v, C;
            const d = J.value && ((C = (v = J.value).getRef) == null ? void 0 : C.call(v).vnode.el), a = H.value, p = d, m = l.target, f = l.composedPath && l.composedPath() || [m];
            !(p && p.contains(m)) && !(a && a.contains(m)) && !(f.includes(a) || f.includes(p)) && e(l);
          };
          A = o, document.addEventListener("mousedown", o, !1);
        },
        unregisterClickOutsideHandler: () => {
          A && (document.removeEventListener("mousedown", A, !1), A = null);
        },
        rePositionDropdown: () => {
          let {
            optionKey: e
          } = h;
          e = e + 1, h.optionKey = e;
        },
        notifyDeselect: (e, o) => {
          delete o._parentGroup, r.onDeselect(e, o);
        }
      };
      return {
        ...$e(),
        ...t,
        ...s,
        ...c,
        on: (e, o) => G.on(e, o),
        off: (e) => G.off(e),
        once: (e, o) => G.once(e, o),
        emit: (e) => G.emit(e),
        // Collect all subitems, each item is visible by default when collected, and is not selected
        //slots.default?slots.default():null
        getOptionsFromChildren: () => {
          let e = [], o = [];
          const {
            optionList: l
          } = r;
          if (l && l.length)
            o = l.map((d, a) => ({
              _show: !0,
              _selected: !1,
              _scrollIndex: a,
              ...d
            })), e[0] = {
              children: o,
              label: ""
            };
          else {
            const d = Dt(r.children);
            e = d.optionGroups, o = d.options;
          }
          return h.optionGroups = e, E(o);
        },
        updateOptions: (e) => {
          h.options = e;
        },
        openMenu: (e) => {
          h.isOpen = !0, de(() => {
            e == null || e();
          });
        },
        closeMenu: () => {
          h.isOpen = !1;
        },
        getTriggerWidth: () => {
          const e = H.value;
          return e && e.getBoundingClientRect().width;
        },
        setOptionWrapperWidth: (e) => {
          h.dropdownMinWidth = e;
        },
        updateSelection: (e) => {
          setTimeout(() => {
            h.selections = e;
          });
        },
        // clone Map, important!!!, prevent unexpected modify on state
        getSelections: () => new Map(E(h.selections)),
        notifyChange: (e) => {
          r.onChange(e);
        },
        notifySelect: (e, o) => {
          delete o._parentGroup, r.onSelect(e, o);
        },
        notifyDropdownVisibleChange: (e) => {
          r.onDropdownVisibleChange(e);
        },
        notifySearch: (e, o) => {
          r.onSearch(e, o);
        },
        notifyCreate: (e) => {
          r.onCreate(e);
        },
        notifyMouseEnter: (e) => {
          r.onMouseEnter(e);
        },
        notifyMouseLeave: (e) => {
          r.onMouseLeave(e);
        },
        notifyFocus: (e) => {
          r.onFocus(e);
        },
        notifyBlur: (e) => {
          r.onBlur(e);
        },
        notifyClear: () => {
          r.onClear();
        },
        notifyListScroll: (e) => {
          r.onListScroll(e);
        },
        updateHovering: (e) => {
          h.isHovering = e;
        },
        updateFocusState: (e) => {
          h.isFocus = e;
        },
        updateOverflowItemCount: (e) => {
          h.overflowItemCount = e;
        },
        focusTrigger: () => {
          try {
            const {
              preventScroll: e
            } = r;
            H.value.focus({
              preventScroll: e
            });
          } catch {
          }
        },
        getContainer: () => Z.value,
        getFocusableElements: (e) => Ht(e),
        getActiveElement: () => Gt(),
        setIsFocusInContainer: (e) => {
          h.isFocusInContainer = e;
        },
        getIsFocusInContainer: () => h.isFocusInContainer,
        updateScrollTop: (e) => {
          var d;
          let o;
          "renderOptionItem" in Tt(r) ? (o = `.${i}-option-custom-selected`, e !== void 0 && (o = `.${i}-option-custom:nth-child(${e + 1})`)) : (o = `.${i}-option-selected`, e !== void 0 && (o = `.${i}-option:nth-child(${e + 1})`));
          let l = (d = Z.value) == null ? void 0 : d.querySelector(`#${i}-${F} ${o}`);
          if (Array.isArray(l) && (l = l[0]), l) {
            const a = l.parentNode;
            a.scrollTop = l.offsetTop - a.offsetTop - a.clientHeight / 2 + l.clientHeight / 2;
          }
        }
      };
    }
    const ke = Ee();
    g = new It(ke), gt(() => {
      g.init(), F = Ce(), I = r.id || Ce();
    }), ht(() => {
      g.destroy();
    }), vt([() => r.value, () => r.optionList, () => r.children], (t, [s, c, e]) => {
      const o = e.map((a) => a.key), l = r.children.map((a) => a.key);
      let d = !1;
      (!pe(o, l) || !pe(c, r.optionList)) && (d = !0, g.handleOptionListChange()), (s !== r.value || d) && (Oe("value") ? g.handleValueChange(r.value) : g.handleOptionListChangeHadDefaultValue());
    });
    const j = (t, s) => {
      g.handleInputChange(t, s);
    };
    function le() {
      const {
        size: t,
        multiple: s,
        disabled: c,
        inputProps: e,
        filter: o
      } = r, l = ee(e, "className"), d = S(`${i}-input`, {
        [`${i}-input-single`]: !s,
        [`${i}-input-multiple`]: s
      }, l), {
        inputValue: a,
        focusIndex: p
      } = h, m = {
        value: a,
        disabled: c,
        className: d,
        onChange: j,
        ...e
      };
      let f = {};
      return s && (f = {
        width: a ? `${a.length * 16}px` : "2px"
      }, m.style = f), u(he, O({
        ref: N,
        size: t,
        "aria-activedescendant": p !== -1 ? `${I}-option-${p}` : "",
        onFocus: (v) => {
          s && o && (h.isFocus = !0), v.stopPropagation();
        }
      }, m), null);
    }
    function Me() {
      const {
        size: t,
        multiple: s,
        disabled: c,
        inputProps: e,
        filter: o,
        searchPosition: l,
        searchPlaceholder: d
      } = r, {
        inputValue: a,
        focusIndex: p
      } = h, m = S(`${i}-dropdown-search-wrapper`, {}), f = ee(e, "className"), v = S(`${i}-dropdown-input`, {
        [`${i}-dropdown-input-single`]: !s,
        [`${i}-dropdown-input-multiple`]: s
      }, f), C = {
        value: a,
        disabled: c,
        className: v,
        onChange: j,
        placeholder: d,
        showClear: !0,
        ...e,
        /**
         * When searchPosition is trigger, the keyboard events are bound to the outer trigger div, so there is no need to listen in input.
         * When searchPosition is dropdown, the popup and the outer trigger div are not parent- child relationships,
         * and bubbles cannot occur, so onKeydown needs to be listened in input.
         *  */
        onKeyDown: (y) => g._handleKeyDown(y)
      };
      return u("div", {
        class: m
      }, [u(he, O({
        ref: X,
        prefix: u(Vt, null, null),
        "aria-activedescendant": p !== -1 ? `${I}-option-${p}` : ""
      }, C), null)]);
    }
    function Re() {
      g.close();
    }
    function De() {
      g.open();
    }
    function _e() {
      g.clearInput();
    }
    function Fe() {
      g.selectAll();
    }
    function Ae() {
      g.clearSelected();
    }
    function ze() {
      g.focus();
    }
    U({
      close: Re,
      open: De,
      clearInput: _e,
      selectAll: Fe,
      deselectAll: Ae,
      focus: ze
    });
    function Q(t, s, c) {
      g.onSelect(E(t), s, c);
    }
    function re(t) {
      t.stopImmediatePropagation(), g.handleClearClick(t);
    }
    function Ve() {
      return u(q, {
        empty: !0,
        emptyContent: r.emptyContent
      }, null);
    }
    function Ne() {
      const t = `${i}-loading-wrapper`;
      return u("div", {
        class: t
      }, [u(_t, null, null)]);
    }
    function se(t, s, c) {
      const {
        focusIndex: e,
        inputValue: o
      } = h, {
        renderOptionItem: l
      } = r;
      let d;
      const a = s === e;
      let p = c || {};
      return t.style && (p = {
        ...p,
        ...t.style
      }), t._inputCreateOnly ? d = He(t, a, s, c) : ("key_" in t && (t._keyInOptionList = t.key_), d = u(q, O({
        showTick: !0
      }, t, {
        optionRest: t,
        selected: t._selected,
        onSelect: (m, f) => Q(m, s, f),
        focused: a,
        onMouseEnter: () => ie(s),
        style: p,
        key: t._keyInOptionList || t._keyInJsx || t.label + t.value + s,
        renderOptionItem: l,
        inputValue: o,
        semiOptionId: `${I}-option-${s}`
      }), {
        default: () => [t.label]
      })), d;
    }
    function He(t, s, c, e) {
      const {
        renderCreateItem: o
      } = r;
      if (typeof o > "u")
        return u(q, O({
          key: t.key_ || t.label + t.value,
          onSelect: (a, p) => Q(a, c, p),
          onMouseEnter: () => ie(c),
          showTick: !0
        }, t, {
          optionRest: t,
          focused: s,
          style: e
        }), {
          default: () => [u(jt, {
            componentName: "Select"
          }, {
            default: (a) => u(k, null, [u("span", {
              class: `${i}-create-tips`
            }, [a.createText]), t.value])
          })]
        });
      const l = o(t.value, s, e);
      return (
        // eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/interactive-supports-focus
        u("div", {
          role: "button",
          "aria-label": "Use the input box to create an optional item",
          onClick: (d) => Q(t, c, d),
          key: t.key_ || t.label
        }, [l])
      );
    }
    function ie(t) {
      g.handleOptionMouseEnter(t);
    }
    function Ge(t) {
      const s = [], c = /* @__PURE__ */ new Map();
      return t.forEach((e, o) => {
        const l = e._parentGroup, d = se(e, o);
        if (l && !c.has(l.label)) {
          const a = u(Se, O(l, {
            key: l.label
          }), null);
          c.set(l.label, !0), s.push(a);
        }
        s.push(d);
      }), s;
    }
    function je(t) {
      const {
        virtualize: s
      } = r, {
        direction: c
      } = oe.value, {
        height: e,
        width: o,
        itemSize: l
      } = s;
      return u(wt, {
        ref: b,
        height: e || we.LIST_HEIGHT,
        itemCount: t.length,
        itemSize: l,
        itemData: {
          visibleOptions: t,
          renderOption: se
        },
        width: o,
        style: {
          direction: c
        }
      }, D(ne) ? ne : {
        default: () => [ne]
      });
    }
    function We(t) {
      const {
        dropdownMinWidth: s,
        options: c,
        selections: e
      } = h, {
        maxHeight: o,
        dropdownClassName: l,
        dropdownStyle: d,
        outerTopSlot: a,
        innerTopSlot: p,
        outerBottomSlot: m,
        innerBottomSlot: f,
        loading: v,
        virtualize: C,
        multiple: y,
        emptyContent: T,
        searchPosition: w,
        filter: M
      } = r, z = E(c).filter((P) => P._show);
      let $ = Ge(z);
      C && ($ = je(z));
      const R = {
        minWidth: typeof s == "string" ? s : s + "px",
        ...d
      }, Y = S({
        [`${i}-option-list`]: !0,
        [`${i}-option-list-chosen`]: e.size
      }), K = !c.length || !E(c).some((P) => P._show);
      return u("div", {
        id: `${i}-${F}`,
        class: l,
        style: R,
        ref: Le,
        onKeydown: (P) => g.handleContainerKeyDown(P)
      }, [a ? u("div", {
        class: `${i}-option-list-outer-top-slot`,
        onMouseenter: () => g.handleSlotMouseEnter()
      }, [a]) : null, w === B.SEARCH_POSITION_DROPDOWN && M ? Me() : null, u("div", {
        style: {
          maxHeight: `${o}px`
        },
        class: Y,
        role: "listbox",
        "aria-multiselectable": y,
        onScroll: (P) => g.handleListScroll(P)
      }, [p ? u("div", {
        class: `${i}-option-list-inner-top-slot`,
        onMouseenter: () => g.handleSlotMouseEnter()
      }, [p]) : null, v ? Ne() : K ? Ve() : $, f ? u("div", {
        class: `${i}-option-list-inner-bottom-slot`,
        onMouseenter: () => g.handleSlotMouseEnter()
      }, [f]) : null]), m ? u("div", {
        class: `${i}-option-list-outer-bottom-slot`,
        onMouseenter: () => g.handleSlotMouseEnter()
      }, [m]) : null]);
    }
    function Ke(t, s) {
      let {
        renderSelectedItem: c,
        searchPosition: e
      } = r;
      const {
        placeholder: o
      } = r, {
        showInput: l,
        inputValue: d
      } = h;
      let a = "";
      const p = [...t];
      if (typeof c > "u" && (c = (C) => C.label), p.length) {
        const C = p[0][1];
        a = c(C);
      }
      const m = e === B.SEARCH_POSITION_TRIGGER, f = S({
        [`${i}-selection-text`]: !0,
        [`${i}-selection-placeholder`]: !a && a !== 0,
        [`${i}-selection-text-hide`]: d && l && m,
        // show Input
        [`${i}-selection-text-inactive`]: !d && l && m
        // Stack Input & RenderText(opacity 0.4)
      }), v = `${i}-content-wrapper`;
      return u("div", {
        class: v
      }, [u("span", {
        class: f,
        "x-semi-prop": "placeholder",
        key: a
      }, [a || a === 0 ? a : o]), s && l && m ? le() : null]);
    }
    const ae = (t, s, c) => {
      const {
        size: e,
        disabled: o
      } = r, l = t[0], {
        value: d
      } = t[1], a = t[1].disabled || o, p = (C, y) => {
        y && typeof y.preventDefault == "function" && y.preventDefault(), g.removeTag({
          label: l,
          value: d
        });
      }, {
        content: m,
        isRenderInTag: f
      } = c(t[1], {
        index: s,
        disabled: a,
        onClose: p
      }), v = {
        disabled: a,
        closable: !a,
        onClose: p
      };
      return f ? u(te, O(v, {
        color: "white",
        size: e || "large",
        key: d,
        tabIndex: -1
      }), D(m) ? m : {
        default: () => [m]
      }) : u(k, {
        key: d
      }, [m]);
    };
    function W(t, s, c) {
      const {
        size: e,
        disabled: o
      } = r;
      let {
        renderSelectedItem: l
      } = r;
      const d = t[0], {
        value: a
      } = t[1], p = t[1].disabled || o, m = (T, w) => {
        w && typeof w.preventDefault == "function" && w.preventDefault(), g.removeTag({
          label: d,
          value: a
        });
      };
      typeof l > "u" && (l = (T) => ({
        isRenderInTag: !0,
        content: T.label
      }));
      const {
        content: f,
        isRenderInTag: v
      } = l(t[1], {
        index: s,
        disabled: p,
        onClose: m
      }), C = {
        disabled: p,
        closable: !p,
        onClose: m
      }, y = c && !$t(r.renderSelectedItem) ? u(Et, {
        size: "small",
        ellipsis: {
          rows: 1,
          showTooltip: {
            type: "popover",
            opts: {
              style: {
                width: "auto",
                fontSize: 12
              }
            }
          }
        }
      }, D(f) ? f : {
        default: () => [f]
      }) : f;
      return v ? u(te, O(C, {
        color: "white",
        size: e || "large",
        key: a,
        style: {
          maxWidth: "100%"
        }
      }), D(y) ? y : {
        default: () => [y]
      }) : u(k, {
        key: a
      }, [y]);
    }
    function Be(t, s) {
      const {
        size: c,
        showRestTagsPopover: e,
        restTagsPopoverProps: o
      } = r;
      let l = u(te, {
        closable: !1,
        size: c || "large",
        color: "grey",
        className: `${i}-content-wrapper-collapse-tag`,
        key: `_+${t}`,
        style: {
          marginRight: 0,
          flexShrink: 0
        }
      }, {
        default: () => [Ct("+"), t]
      });
      if (e) {
        let d;
        const a = /* @__PURE__ */ function() {
          return l;
        }();
        l = u(ge, O({
          showArrow: !0,
          content: u(Lt, {
            spacing: 2,
            wrap: !0,
            style: {
              maxWidth: "400px"
            }
          }, D(d = s.map((p, m) => W(p, m))) ? d : {
            default: () => [d]
          }),
          trigger: "hover",
          position: "top",
          autoAdjustOverflow: !0
        }, o, {
          key: `_+${t}_Popover`
        }), D(l) ? l : {
          default: () => [a]
        });
      }
      return l;
    }
    function qe(t, s) {
      return t.length && t[0] ? W(t[0], s, !0) : null;
    }
    function Ue(t) {
      const {
        overflowItemCount: s,
        selections: c
      } = h, {
        maxTagCount: e
      } = r, o = c.size - e > 0 ? c.size - e + t.length - 1 : t.length - 1;
      s !== o && g.updateOverflowItemCount(c.size, o);
    }
    function Xe(t, s) {
      const {
        overflowItemCount: c
      } = h, e = typeof s == "number" ? t.slice(0, s) : t;
      return u("div", {
        class: `${i}-content-wrapper-collapse`
      }, [u(Pt, {
        items: e,
        key: String(t.length),
        overflowRenderer: (o) => qe(o, s - 1),
        onOverflow: (o) => Ue(o),
        visibleItemRenderer: (o, l) => W(o, l)
      }, null), c > 0 && Be(c, t.slice(t.length - c))]);
    }
    function Je(t, s) {
      let {
        renderSelectedItem: c
      } = r;
      const {
        showRestTagsPopover: e,
        restTagsPopoverProps: o,
        maxTagCount: l
      } = r, {
        isFullTags: d
      } = h;
      let a;
      if (typeof c > "u" && (c = (p) => ({
        isRenderInTag: !0,
        content: p.label
      })), e) {
        const m = (d ? t : t.slice(0, l)).map((f, v) => ae(f, v, c));
        a = u(me, {
          tagList: m,
          maxTagCount: s,
          restCount: d ? void 0 : t.length - l,
          size: "large",
          mode: "custom",
          showPopover: e,
          popoverProps: o,
          onPlusNMouseEnter: () => {
            g.updateIsFullTags();
          }
        }, null);
      } else {
        const m = t.slice(0, l).map((f, v) => ae(f, v, c));
        a = u(me, {
          tagList: m,
          maxTagCount: s,
          restCount: t.length - l,
          size: "large",
          mode: "custom"
        }, null);
      }
      return a;
    }
    function Ze(t, s) {
      let {
        renderSelectedItem: c,
        searchPosition: e
      } = r;
      const {
        placeholder: o,
        maxTagCount: l,
        expandRestTagsOnClick: d,
        ellipsisTrigger: a
      } = r, {
        inputValue: p,
        isOpen: m
      } = h, f = [...t], v = S({
        [`${i}-content-wrapper`]: !0,
        [`${i}-content-wrapper-one-line`]: l && !m,
        [`${i}-content-wrapper-empty`]: !f.length
      }), C = S({
        [`${i}-selection-text`]: !0,
        [`${i}-selection-placeholder`]: !f.length,
        [`${i}-selection-text-hide`]: f && f.length
      }), y = o && !p ? u("span", {
        class: C
      }, [o]) : null, T = f.length > l ? l : void 0, w = !l, M = a ? Xe(f, T) : Je(f, T), z = w || d && m ? f.map(($, R) => W($, R)) : M;
      return s && B.SEARCH_POSITION_TRIGGER, u(k, null, [u("div", {
        class: v
      }, [f && f.length ? z : y, s ? le() : null])]);
    }
    function Qe(t) {
      g.handleMouseEnter(t);
    }
    function Ye(t) {
      g.handleMouseLeave(t);
    }
    function et(t) {
      g.handleKeyPress(t);
    }
    function tt(t) {
      const {
        virtualize: s
      } = r, {
        selections: c
      } = h;
      if (t)
        if (s) {
          let e = -1;
          if (E(c).forEach((o) => {
            const l = ee(o, "_scrollIndex");
            Ot(l) && l >= 0 && (e = e !== -1 && e < l ? e : l);
          }), e !== -1)
            try {
              b.value.scrollToItem(e, "center");
            } catch (o) {
              console.error(o);
            }
        } else
          g.updateScrollTop();
    }
    function nt() {
      const {
        suffix: t
      } = r, s = S({
        [`${i}-suffix`]: !0,
        [`${i}-suffix-text`]: t && fe(t),
        [`${i}-suffix-icon`]: ve(t)
      });
      return u("div", {
        class: s,
        "x-semi-prop": "suffix"
      }, [t]);
    }
    function ot() {
      const {
        prefix: t,
        insetLabel: s,
        insetLabelId: c
      } = r, e = t || s, o = S({
        [`${i}-prefix`]: !0,
        [`${i}-inset-label`]: s,
        [`${i}-prefix-text`]: e && fe(e),
        [`${i}-prefix-icon`]: ve(e)
      });
      return u("div", {
        class: o,
        id: c,
        "x-semi-prop": "prefix,insetLabel"
      }, [e]);
    }
    function lt() {
      const {
        disabled: t,
        multiple: s,
        filter: c,
        style: e,
        id: o,
        size: l,
        className: d,
        validateStatus: a,
        showArrow: p,
        suffix: m,
        prefix: f,
        insetLabel: v,
        placeholder: C,
        triggerRender: y,
        arrowIcon: T,
        clearIcon: w,
        borderless: M,
        ...z
      } = r, {
        selections: $,
        isOpen: R,
        keyboardEventSet: Y,
        inputValue: K,
        isHovering: P,
        isFocus: rt,
        showInput: st,
        focusIndex: ce
      } = h, ue = typeof y == "function", V = !!c, it = ue ? S(d) : S(i, d, {
        [`${i}-borderless`]: M,
        [`${i}-open`]: R,
        [`${i}-focus`]: rt,
        [`${i}-disabled`]: t,
        [`${i}-single`]: !s,
        [`${i}-multiple`]: s,
        [`${i}-filterable`]: V,
        [`${i}-small`]: l === "small",
        [`${i}-large`]: l === "large",
        [`${i}-error`]: a === "error",
        [`${i}-warning`]: a === "warning",
        [`${i}-no-arrow`]: !p,
        [`${i}-with-prefix`]: f || v,
        [`${i}-with-suffix`]: m
      }), at = r.showClear && ($.size || K) && !t && (P || R), ct = p ? u("div", {
        class: `${i}-arrow`,
        "x-semi-prop": "arrowIcon"
      }, [T]) : u("div", {
        class: `${i}-arrow-empty`
      }, null), ut = w || u(zt, null, null), dt = ue ? u(Ft, {
        value: Array.from(E($).values()),
        inputValue: K,
        onChange: j,
        onSearch: j,
        onRemove: (L) => g.removeTag(L),
        onClear: re,
        disabled: t,
        triggerRender: y,
        placeholder: C,
        componentName: "Select",
        componentProps: {
          ...r
        }
      }, null) : [u(k, {
        key: "prefix"
      }, [f || v ? ot() : null]), u(k, {
        key: "selection"
      }, [u("div", {
        class: S(`${i}-selection`)
      }, [s ? Ze(E($), V) : Ke(E($), V)])]), u(k, {
        key: "suffix"
      }, [m ? nt() : null]), u(k, {
        key: "clearicon"
      }, [at ? u("div", {
        class: S(`${i}-clear`),
        onClick: re
      }, [ut]) : ct])], pt = t || V && st || V && s ? -1 : 0;
      return u("div", O({
        role: "combobox",
        "aria-disabled": t,
        "aria-expanded": R,
        "aria-controls": `${i}-${F}`,
        "aria-haspopup": "listbox",
        "aria-label": "select value",
        "aria-invalid": r["aria-invalid"],
        "aria-errormessage": r["aria-errormessage"],
        "aria-labelledby": r["aria-labelledby"],
        "aria-describedby": r["aria-describedby"],
        "aria-required": r["aria-required"],
        class: it,
        ref: (L) => H.value = L,
        onClick: (L) => g.handleClick(L),
        style: e,
        id: o,
        tabindex: pt,
        "aria-activedescendant": ce !== -1 ? `${I}-option-${ce}` : "",
        onMouseenter: Qe,
        onMouseleave: Ye,
        onFocus: (L) => g.handleTriggerFocus(L),
        onBlur: (L) => g.handleTriggerBlur(L),
        onKeypress: et
      }, Y, Pe()), [dt]);
    }
    return () => {
      const {
        direction: t
      } = oe.value, s = t === "rtl" ? "bottomRight" : "bottomLeft", {
        position: c = s,
        zIndex: e,
        getPopupContainer: o,
        motion: l,
        autoAdjustOverflow: d,
        mouseLeaveDelay: a,
        mouseEnterDelay: p,
        spacing: m,
        stopPropagation: f,
        dropdownMargin: v
      } = r, {
        isOpen: C,
        optionKey: y
      } = h, T = We(r.children ? r.children : null), w = lt();
      return u(ge, {
        getPopupContainer: o,
        motion: l,
        autoAdjustOverflow: d,
        mouseLeaveDelay: a,
        mouseEnterDelay: p,
        zIndex: e,
        ref: J,
        content: T,
        visible: C,
        trigger: "custom",
        rePosKey: y,
        position: c,
        spacing: m,
        stopPropagation: f,
        disableArrowKeyDown: !0,
        onVisibleChange: (M) => tt(M),
        afterClose: () => g.handlePopoverClose()
      }, D(w) ? w : {
        default: () => [w]
      });
    };
  }
}), Ut = /* @__PURE__ */ ye({
  props: {
    ...xe
  },
  name: "Select",
  setup(r, {
    slots: U,
    expose: h
  }) {
    const {
      getProps: F
    } = Ie(), I = _();
    return h({
      close() {
        var b;
        (b = I.value) == null || b.close();
      },
      open() {
        var b;
        (b = I.value) == null || b.open();
      },
      clearInput() {
        var b;
        (b = I.value) == null || b.clearInput();
      },
      selectAll() {
        var b;
        (b = I.value) == null || b.selectAll();
      },
      deselectAll() {
        var b;
        (b = I.value) == null || b.deselectAll();
      },
      focus() {
        var b;
        (b = I.value) == null || b.focus();
      }
    }), () => {
      const b = Nt(U);
      return u(qt, O({
        ref: I
      }, F(r), {
        children: b || []
      }), null);
    };
  }
}), Te = Ut;
Te.Option = q;
Te.OptGroup = Se;
export {
  $n as SelectOption,
  Ln as SelectOptionGroup,
  Te as default,
  xe as vuePropsType
};
//# sourceMappingURL=index.js.map
