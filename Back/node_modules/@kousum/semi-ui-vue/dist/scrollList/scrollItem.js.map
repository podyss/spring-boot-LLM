{"version":3,"file":"scrollItem.js","sources":["../../src/components/scrollList/scrollItem.tsx"],"sourcesContent":["import {\n  defineComponent,\n  ref,\n  h,\n  Fragment,\n  useSlots,\n  CSSProperties,\n  reactive,\n  onUnmounted,\n  onMounted,\n  watch,\n  watchEffect,\n  nextTick,\n  ComponentObjectPropsOptions,\n  PropType,\n} from 'vue';\n\nimport { useBaseComponent } from '../_base/baseComponent';\nimport classnames from 'classnames';\nimport { noop, debounce, throttle, find, map, findIndex, times } from 'lodash';\n\nimport { cssClasses, numbers } from '@douyinfe/semi-foundation/scrollList/constants';\nimport ItemFoundation, { Item, ScrollItemAdapter } from '@douyinfe/semi-foundation/scrollList/itemFoundation';\nimport animatedScrollTo from '@douyinfe/semi-foundation/scrollList/scrollTo';\nimport isElement from '@douyinfe/semi-foundation/utils/isElement';\nimport { Motion } from '../_base/base';\nimport { AriaAttributes } from '../AriaAttributes';\nimport { CombineProps } from '../interface';\n\nconst msPerFrame = 1000 / 60;\nconst blankReg = /^\\s*$/;\nconst wheelMode = 'wheel';\n\ninterface DebounceSelectFn {\n  (e: UIEvent, newSelectedNode: HTMLElement): void;\n\n  cancel(): void;\n}\n\nexport interface ScrollItemProps<T extends Item> {\n  mode?: string;\n  cycled?: boolean;\n  list?: T[];\n  selectedIndex?: number;\n  onSelect?: (data: T) => void;\n  transform?: (value: any, text: string) => string;\n  className?: string;\n  motion?: Motion;\n  style?: CSSProperties;\n  type?: string | number; // used to identify the scrollItem, used internally by the semi component, and does not need to be exposed to the user\n  'aria-label'?: AriaAttributes['aria-label'];\n  class?: string;\n}\n\nexport interface ScrollItemState {\n  prependCount: number;\n  appendCount: number;\n}\n\nfunction scrollItemFunc<T extends Item>() {\n  const vuePropsType: CombineProps<ScrollItemProps<T>> = {\n    className: String,\n    style: Object,\n    class: String,\n    selectedIndex: {\n      type: Number,\n      default: 0,\n    },\n    motion: {\n      type: [Object, String, Boolean, Function],\n      default: true,\n    },\n    transform: Function as PropType<ScrollItemProps<any>['transform']>,\n    list: {\n      type: [Array],\n      default: [],\n    },\n    onSelect: {\n      type: Function as PropType<ScrollItemProps<any>['onSelect']>,\n      default: noop,\n    },\n    cycled: {\n      type: Boolean,\n      default: false,\n    },\n    mode: {\n      type: String,\n      default: wheelMode,\n    },\n    type: [String, Number], //used to identify the scrollItem, used internally by the semi component, and does not need to be exposed to the user\n    'aria-label': String,\n  };\n  const scrollItem_ = defineComponent({\n    props: { ...vuePropsType },\n    name: 'ScrollItem',\n    setup(props, {}) {\n      const slots = useSlots();\n\n      const state = reactive<ScrollItemState>({\n        prependCount: 0,\n        appendCount: 0,\n        // selectedIndex: props.selectedIndex,\n        // fakeSelectedIndex: props.selectedIndex,\n      });\n\n      const selectedNode = ref();\n      const willSelectNode = ref();\n      const list = ref();\n      const selector = ref();\n      const wrapper = ref();\n\n      let scrollAnimation: any;\n      let scrolling: boolean;\n      let throttledAdjustList: DebounceSelectFn;\n      let debouncedSelect: DebounceSelectFn;\n\n      scrollAnimation = null;\n\n      // cache if select action comes from outside\n      const { adapter: adapterInject } = useBaseComponent<ScrollItemProps<any>>(props, state);\n\n      /**\n       *\n       * reset position to center of the scrollWrapper\n       *\n       * @param selectedNode_\n       * @param scrollWrapper\n       * @param {number} duration\n       */\n      const scrollToCenter: ScrollItemAdapter['scrollToCenter'] = (selectedNode_, scrollWrapper, duration) => {\n        selectedNode_ = selectedNode_ || selectedNode.value;\n\n        scrollWrapper = scrollWrapper || wrapper.value;\n        if (isElement(selectedNode_) && isElement(scrollWrapper)) {\n          const scrollRect = scrollWrapper.getBoundingClientRect();\n          const selectedRect = selectedNode_.getBoundingClientRect();\n\n          const targetTop =\n            scrollWrapper.scrollTop +\n            (selectedRect.top - (scrollRect.top + scrollRect.height / 2 - selectedRect.height / 2));\n\n          scrollToPos(targetTop, typeof duration === 'number' ? duration : numbers.DEFAULT_SCROLL_DURATION);\n        }\n      };\n\n      const isDisabledIndex = (index: number) => {\n        if (Array.isArray(props.list) && props.list.length && index > -1) {\n          const size = props.list.length;\n          const indexInData = index % size;\n\n          return isDisabledData(props.list[indexInData]);\n        }\n\n        return false;\n      };\n      function adapter(): ScrollItemAdapter<ScrollItemProps<any>, ScrollItemState, any> {\n        return {\n          ...adapterInject<ScrollItemProps<any>, ScrollItemState>(),\n          setState: (states_, callback) => {\n            for (const statesKey in states_) {\n              if (states_.hasOwnProperty(statesKey)) {\n                state[statesKey] = states_[statesKey];\n              }\n            }\n\n            // TODO callback需要nextTick\n            nextTick(() => {\n              callback();\n            });\n          },\n          setPrependCount: (prependCount) => (state.prependCount = prependCount),\n          setAppendCount: (appendCount) => (state.appendCount = appendCount),\n          isDisabledIndex: isDisabledIndex,\n          setSelectedNode: (selectedNode_) => _cacheWillSelectNode(selectedNode_),\n          notifySelectItem: (...args) => props.onSelect(...args),\n          scrollToCenter: scrollToCenter,\n        };\n      }\n\n      const foundation = new ItemFoundation<ScrollItemProps<any>, ScrollItemState, any>(adapter());\n\n      onMounted(() => {\n        foundation.init();\n\n        const { mode, cycled, selectedIndex } = props;\n\n        const selectedNode_ = getNodeByIndex(\n          typeof selectedIndex === 'number' && selectedIndex > -1 ? selectedIndex : 0\n        ) as HTMLElement;\n\n        _cacheSelectedNode(selectedNode_);\n        _cacheWillSelectNode(selectedNode_);\n\n        if (mode === wheelMode && cycled) {\n          foundation.initWheelList(list.value, wrapper.value, () => {\n            // we have to scroll in next tick\n            // setTimeout(() => {\n            scrollToNode(selectedNode_, 0);\n            // });\n          });\n        } else {\n          scrollToNode(selectedNode_, 0);\n        }\n      });\n      onUnmounted(() => {\n        if (props.cycled) {\n          throttledAdjustList.cancel();\n          debouncedSelect.cancel();\n        }\n      });\n\n      throttledAdjustList = throttle((e, nearestNode) => {\n        foundation.adjustInfiniteList(list.value, wrapper.value, nearestNode);\n      }, msPerFrame);\n\n      debouncedSelect = debounce((e, nearestNode) => {\n        _cacheSelectedNode(nearestNode);\n        foundation.selectNode(nearestNode, list.value);\n      }, msPerFrame * 5);\n\n      watch(\n        [() => props.selectedIndex, willSelectNode, list, selectedNode, selector, wrapper],\n        (value, [prevPropsSelectedIndex]) => {\n          const { selectedIndex } = props;\n          if (prevPropsSelectedIndex !== selectedIndex) {\n            // smooth scroll to selected option\n            const willSelectIndex = getIndexByNode(willSelectNode.value);\n\n            if (!indexIsSame(willSelectIndex, selectedIndex)) {\n              const newSelectedNode = getNodeByOffset(\n                selectedNode.value,\n                selectedIndex - prevPropsSelectedIndex,\n                list.value\n              );\n              _cacheWillSelectNode(newSelectedNode);\n            }\n\n            _cacheSelectedNode(willSelectNode.value);\n\n            scrollToIndex(selectedIndex);\n          }\n        }\n      );\n\n      const _cacheNode = (name: string, node: any) => {\n        if (name && node) {\n          switch (name) {\n            case 'selectedNode':\n              selectedNode.value = node;\n              break;\n            case 'willSelectNode':\n              willSelectNode.value = node;\n              break;\n            case 'list':\n              list.value = node;\n              break;\n            case 'selector':\n              selector.value = node;\n              break;\n            case 'wrapper':\n              wrapper.value = node;\n              break;\n            default:\n              break;\n          }\n        }\n      };\n\n      const _cacheSelectedNode = (selectedNode_: any) => _cacheNode('selectedNode', selectedNode_);\n\n      const _cacheWillSelectNode = (node: any) => _cacheNode('willSelectNode', node);\n\n      const _cacheListNode = (list: any) => _cacheNode('list', list);\n\n      const _cacheSelectorNode = (selector: any) => _cacheNode('selector', selector);\n\n      const _cacheWrapperNode = (wrapper: any) => _cacheNode('wrapper', wrapper);\n\n      /* istanbul ignore next */\n      const _isFirst = (node: Element) => {\n        if (isElement(node) && isElement(list)) {\n          const children = list.value.children;\n          const index = findIndex(children, node);\n\n          return index === 0;\n        }\n\n        return false;\n      };\n\n      /* istanbul ignore next */\n      const _isLast = (node: Element) => {\n        if (isElement(node) && isElement(list.value)) {\n          const { children } = list.value;\n          const index = findIndex(children, node);\n\n          return index === children.length - 1;\n        }\n\n        return false;\n      };\n\n      /**\n       *\n       * @param {HTMLElement} refNode\n       * @param {number} offset\n       * @param {HTMLElement} listWrapper\n       *\n       * @returns {HTMLElement}\n       */\n      function getNodeByOffset(refNode: Element, offset: number, listWrapper: Element) {\n        const { list } = props;\n\n        if (\n          isElement(refNode) &&\n          isElement(listWrapper) &&\n          typeof offset === 'number' &&\n          Array.isArray(list) &&\n          list.length\n        ) {\n          offset = offset % list.length;\n          const refIndex = getIndexByNode(refNode);\n\n          let targetIndex = refIndex + offset;\n\n          while (targetIndex < 0) {\n            targetIndex += list.length;\n          }\n\n          if (offset) {\n            return getNodeByIndex(targetIndex);\n          }\n        }\n        return refNode;\n      }\n\n      const indexIsSame = (index1: number, index2: number) => {\n        const { list } = props;\n\n        if (list.length) {\n          return index1 % list.length === index2 % list.length;\n        }\n        return undefined;\n      };\n\n      const isDisabledNode = (node: Element) => {\n        const listWrapper = list;\n\n        if (isElement(node) && isElement(listWrapper.value)) {\n          const index = findIndex(listWrapper.value.children, (child) => child === node);\n\n          return isDisabledIndex(index);\n        }\n\n        return false;\n      };\n\n      const isDisabledData = (data: any) => data && typeof data === 'object' && data.disabled;\n\n      const isWheelMode = () => props.mode === wheelMode;\n\n      const addClassToNode = (selectedNode_: Element, selectedCls = cssClasses.SELECTED) => {\n        selectedNode_ = selectedNode_ || selectedNode.value;\n\n        if (isElement(selectedNode_) && isElement(list.value)) {\n          const { children } = list.value;\n          const reg = new RegExp(`\\\\s*${selectedCls}\\\\s*`, 'g');\n\n          map(children, (node) => {\n            node.className = node.className && node.className.replace(reg, ' ');\n\n            if (blankReg.test(node.className)) {\n              node.className = '';\n            }\n          });\n\n          if (selectedNode_.className && !blankReg.test(selectedNode_.className)) {\n            selectedNode_.className += ` ${selectedCls}`;\n          } else {\n            selectedNode_.className = selectedCls;\n          }\n        }\n      };\n\n      // 必须用函数判断一下 不然返回值一直是0\n      const getIndexByNode = (node: Element) =>\n        findIndex(list.value.children, function (o) {\n          return o == node;\n        });\n\n      const getNodeByIndex = (index: number) => {\n        if (index > -1) {\n          return find(list.value.children, (node, idx: number) => {\n            if (idx === index) {\n              node.scrollTop;\n            }\n            return idx === index;\n          });\n        }\n\n        const defaultSelectedNode = find(list.value.children, (child) => !isDisabledNode(child));\n\n        return defaultSelectedNode;\n      };\n\n      const scrollToIndex = (selectedIndex: number, duration?: number) => {\n        // move to selected item\n        duration = typeof duration === 'number' ? duration : numbers.DEFAULT_SCROLL_DURATION;\n        // eslint-disable-next-line\n        selectedIndex = selectedIndex == null ? props.selectedIndex : selectedIndex;\n\n        // isWheelMode() && addClassToNode();\n        scrollToNode(selectedNode.value, duration);\n      };\n\n      const scrollToNode = (node: HTMLElement, duration: number) => {\n        const wrapperHeight = wrapper.value.offsetHeight;\n        const itemHeight = getItmHeight(node);\n        const targetTop =\n          (node.offsetTop || (list.value.children.length * itemHeight) / 2) - (wrapperHeight - itemHeight) / 2;\n\n        scrollToPos(targetTop, duration);\n      };\n\n      const scrollToPos = (targetTop: number, duration = numbers.DEFAULT_SCROLL_DURATION) => {\n        // isWheelMode() && addClassToNode();\n\n        if (duration && props.motion) {\n          if (scrollAnimation) {\n            scrollAnimation.destroy();\n            scrolling = false;\n          }\n\n          if (wrapper.value.scrollTop === targetTop) {\n            if (isWheelMode()) {\n              const nodeInfo = foundation.getNearestNodeInfo(list.value, selector.value);\n              addClassToNode(nodeInfo.nearestNode);\n            }\n          } else {\n            scrollAnimation = animatedScrollTo(wrapper.value, targetTop, duration);\n            scrollAnimation.on('rest', () => {\n              if (isWheelMode()) {\n                const nodeInfo = foundation.getNearestNodeInfo(list.value, selector.value);\n                addClassToNode(nodeInfo.nearestNode);\n              }\n            });\n            scrollAnimation.start();\n          }\n        } else {\n          wrapper.value.scrollTop = targetTop;\n        }\n      };\n\n      const scrollToSelectItem = (e) => {\n        const { nearestNode } = foundation.getNearestNodeInfo(list.value, selector.value);\n\n        if (props.cycled) {\n          throttledAdjustList(e, nearestNode);\n        }\n\n        debouncedSelect(e, nearestNode);\n      };\n\n      const clickToSelectItem = (e) => {\n        // const index = foundation.selectNearestIndex(e.nativeEvent, list);\n        e && e.stopImmediatePropagation && e.stopImmediatePropagation();\n        const { targetNode: node, infoInList } = foundation.getTargetNode(e, list.value);\n\n        if (node && infoInList && !infoInList.disabled) {\n          debouncedSelect(null, node);\n        }\n      };\n\n      const getItmHeight = (itm: HTMLElement) => (itm && itm.offsetHeight) || numbers.DEFAULT_ITEM_HEIGHT;\n\n      const renderItemList = (prefixKey = '') => {\n        const { selectedIndex, mode, transform: commonTrans } = props;\n\n        return props.list.map((item, index) => {\n          const { transform: itemTrans } = item;\n\n          const transform = typeof itemTrans === 'function' ? itemTrans : commonTrans;\n          const selected = selectedIndex === index;\n          const cls = classnames({\n            [`${cssClasses.PREFIX}-item-sel`]: selected && mode !== wheelMode,\n            [`${cssClasses.PREFIX}-item-disabled`]: Boolean(item.disabled),\n          });\n\n          let text = '';\n\n          if (selected) {\n            if (typeof transform === 'function') {\n              text = transform(item.value, item.text);\n            } else {\n              // eslint-disable-next-line\n              text = item.text == null ? item.value : item.text;\n            }\n          } else {\n            // eslint-disable-next-line\n            text = item.text == null ? item.value : item.text;\n          }\n\n          const events: { onClick?: () => void } = {};\n\n          if (!isWheelMode() && !item.disabled) {\n            events.onClick = () => foundation.selectIndex(index, list.value);\n          }\n\n          return (\n            // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n            <li\n              key={prefixKey + index}\n              {...events}\n              class={cls}\n              role=\"option\"\n              aria-selected={selected}\n              aria-disabled={item.disabled}\n            >\n              {text}\n            </li>\n          );\n        });\n      };\n\n      const renderNormalList = () => {\n        const { className, style } = props;\n\n        const inner = renderItemList();\n\n        const wrapperCls = classnames(`${cssClasses.PREFIX}-item`, className);\n\n        return (\n          <div style={style} class={wrapperCls} ref={_cacheWrapperNode}>\n            <ul role=\"listbox\" aria-multiselectable={false} aria-label={props['aria-label']} ref={_cacheListNode}>\n              {inner}\n            </ul>\n          </div>\n        );\n      };\n\n      /**\n       * List of Rendering Unlimited Modes\n       */\n      const renderInfiniteList = () => {\n        const { cycled, className, style } = props;\n        const { prependCount, appendCount } = state;\n\n        const prependList = times(prependCount).reduce((arr, num) => {\n          const items = renderItemList(`pre_${num}_`);\n          arr.unshift(...items);\n\n          return arr;\n        }, []);\n        const appendList = times(appendCount).reduce((arr, num) => {\n          const items = renderItemList(`app_${num}_`);\n          arr.push(...items);\n          return arr;\n        }, []);\n\n        const inner = renderItemList();\n\n        const listWrapperCls = classnames(`${cssClasses.PREFIX}-list-outer`, {\n          [`${cssClasses.PREFIX}-list-outer-nocycle`]: !cycled,\n        });\n\n        const wrapperCls = classnames(`${cssClasses.PREFIX}-item-wheel`, className);\n\n        const selectorCls = classnames(`${cssClasses.PREFIX}-selector`);\n\n        const preShadeCls = classnames(`${cssClasses.PREFIX}-shade`, `${cssClasses.PREFIX}-shade-pre`);\n        const postShadeCls = classnames(`${cssClasses.PREFIX}-shade`, `${cssClasses.PREFIX}-shade-post`);\n\n        return (\n          <div class={wrapperCls} style={style}>\n            <div class={preShadeCls} />\n            <div class={selectorCls} ref={_cacheSelectorNode} />\n            <div class={postShadeCls} />\n            <div class={listWrapperCls} ref={_cacheWrapperNode} onScroll={scrollToSelectItem}>\n              <ul\n                role=\"listbox\"\n                aria-label={props['aria-label']}\n                aria-multiselectable={false}\n                ref={_cacheListNode}\n                onClick={clickToSelectItem}\n              >\n                {prependList}\n                {inner}\n                {appendList}\n              </ul>\n            </div>\n          </div>\n        );\n      };\n\n      return () => {\n        return isWheelMode() ? renderInfiniteList() : renderNormalList();\n      };\n    },\n  });\n\n  return scrollItem_;\n}\nconst ScrollItem = scrollItemFunc<any>();\nexport default ScrollItem;\nexport { scrollItemFunc };\n"],"names":["msPerFrame","blankReg","wheelMode","scrollItemFunc","defineComponent","props","className","String","style","Object","class","selectedIndex","type","Number","default","motion","Boolean","Function","transform","list","Array","onSelect","noop","cycled","mode","name","setup","useSlots","state","reactive","prependCount","appendCount","selectedNode","ref","willSelectNode","selector","wrapper","scrollAnimation","throttledAdjustList","debouncedSelect","adapter","adapterInject","useBaseComponent","scrollToCenter","selectedNode_","scrollWrapper","duration","value","isElement","scrollRect","getBoundingClientRect","selectedRect","targetTop","scrollTop","top","height","scrollToPos","numbers","DEFAULT_SCROLL_DURATION","isDisabledIndex","index","isArray","length","size","indexInData","isDisabledData","setState","states_","callback","statesKey","hasOwnProperty","nextTick","setPrependCount","setAppendCount","setSelectedNode","_cacheWillSelectNode","notifySelectItem","args","foundation","ItemFoundation","onMounted","init","getNodeByIndex","_cacheSelectedNode","initWheelList","scrollToNode","onUnmounted","cancel","throttle","e","nearestNode","adjustInfiniteList","debounce","selectNode","watch","prevPropsSelectedIndex","willSelectIndex","getIndexByNode","indexIsSame","newSelectedNode","getNodeByOffset","scrollToIndex","_cacheNode","node","_cacheListNode","_cacheSelectorNode","_cacheWrapperNode","refNode","offset","listWrapper","targetIndex","index1","index2","isDisabledNode","findIndex","children","child","data","disabled","isWheelMode","addClassToNode","selectedCls","cssClasses","SELECTED","reg","RegExp","map","replace","test","o","find","idx","wrapperHeight","offsetHeight","itemHeight","getItmHeight","offsetTop","destroy","nodeInfo","getNearestNodeInfo","animatedScrollTo","on","start","scrollToSelectItem","clickToSelectItem","stopImmediatePropagation","targetNode","infoInList","getTargetNode","itm","DEFAULT_ITEM_HEIGHT","renderItemList","prefixKey","commonTrans","item","itemTrans","selected","cls","classnames","PREFIX","text","events","onClick","selectIndex","_createVNode","_mergeProps","renderNormalList","inner","wrapperCls","renderInfiniteList","prependList","times","reduce","arr","num","items","unshift","appendList","push","listWrapperCls","selectorCls","preShadeCls","postShadeCls","ScrollItem"],"mappings":"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"}