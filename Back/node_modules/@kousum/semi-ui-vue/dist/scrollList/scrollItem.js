import { defineComponent as fe, useSlots as me, reactive as Ie, ref as S, onMounted as ve, onUnmounted as he, watch as pe, nextTick as ge, createVNode as d, mergeProps as Ne } from "vue";
import { useBaseComponent as ye } from "../_base/baseComponent";
import m from "classnames";
import { throttle as be, debounce as Se, findIndex as G, find as K, noop as Te, map as Ce, times as V } from "lodash";
import { numbers as w, cssClasses as a } from '@douyinfe/semi-foundation/lib/es/scrollList/constants';
import Re from '@douyinfe/semi-foundation/lib/es/scrollList/itemFoundation';
import xe from '@douyinfe/semi-foundation/lib/es/scrollList/scrollTo';
import f from '@douyinfe/semi-foundation/lib/es/utils/isElement';
const q = 1e3 / 60, J = /^\s*$/, P = "wheel";
function Ee() {
  return /* @__PURE__ */ fe({
    props: {
      ...{
        className: String,
        style: Object,
        class: String,
        selectedIndex: {
          type: Number,
          default: 0
        },
        motion: {
          type: [Object, String, Boolean, Function],
          default: !0
        },
        transform: Function,
        list: {
          type: [Array],
          default: []
        },
        onSelect: {
          type: Function,
          default: Te
        },
        cycled: {
          type: Boolean,
          default: !1
        },
        mode: {
          type: String,
          default: P
        },
        type: [String, Number],
        //used to identify the scrollItem, used internally by the semi component, and does not need to be exposed to the user
        "aria-label": String
      }
    },
    name: "ScrollItem",
    setup(o, {}) {
      me();
      const p = Ie({
        prependCount: 0,
        appendCount: 0
        // selectedIndex: props.selectedIndex,
        // fakeSelectedIndex: props.selectedIndex,
      }), I = S(), T = S(), c = S(), g = S(), i = S();
      let v, $, C;
      v = null;
      const {
        adapter: Q
      } = ye(o, p), Y = (e, t, l) => {
        if (e = e || I.value, t = t || i.value, f(e) && f(t)) {
          const n = t.getBoundingClientRect(), s = e.getBoundingClientRect(), r = t.scrollTop + (s.top - (n.top + n.height / 2 - s.height / 2));
          z(r, typeof l == "number" ? l : w.DEFAULT_SCROLL_DURATION);
        }
      }, B = (e) => {
        if (Array.isArray(o.list) && o.list.length && e > -1) {
          const t = o.list.length, l = e % t;
          return se(o.list[l]);
        }
        return !1;
      };
      function Z() {
        return {
          ...Q(),
          setState: (e, t) => {
            for (const l in e)
              e.hasOwnProperty(l) && (p[l] = e[l]);
            ge(() => {
              t();
            });
          },
          setPrependCount: (e) => p.prependCount = e,
          setAppendCount: (e) => p.appendCount = e,
          isDisabledIndex: B,
          setSelectedNode: (e) => D(e),
          notifySelectItem: (...e) => o.onSelect(...e),
          scrollToCenter: Y
        };
      }
      const u = new Re(Z());
      ve(() => {
        u.init();
        const {
          mode: e,
          cycled: t,
          selectedIndex: l
        } = o, n = W(typeof l == "number" && l > -1 ? l : 0);
        A(n), D(n), e === P && t ? u.initWheelList(c.value, i.value, () => {
          k(n, 0);
        }) : k(n, 0);
      }), he(() => {
        o.cycled && ($.cancel(), C.cancel());
      }), $ = be((e, t) => {
        u.adjustInfiniteList(c.value, i.value, t);
      }, q), C = Se((e, t) => {
        A(t), u.selectNode(t, c.value);
      }, q * 5), pe([() => o.selectedIndex, T, c, I, g, i], (e, [t]) => {
        const {
          selectedIndex: l
        } = o;
        if (t !== l) {
          const n = M(T.value);
          if (!le(n, l)) {
            const s = te(I.value, l - t, c.value);
            D(s);
          }
          A(T.value), oe(l);
        }
      });
      const N = (e, t) => {
        if (e && t)
          switch (e) {
            case "selectedNode":
              I.value = t;
              break;
            case "willSelectNode":
              T.value = t;
              break;
            case "list":
              c.value = t;
              break;
            case "selector":
              g.value = t;
              break;
            case "wrapper":
              i.value = t;
              break;
          }
      }, A = (e) => N("selectedNode", e), D = (e) => N("willSelectNode", e), U = (e) => N("list", e), ee = (e) => N("selector", e), H = (e) => N("wrapper", e);
      function te(e, t, l) {
        const {
          list: n
        } = o;
        if (f(e) && f(l) && typeof t == "number" && Array.isArray(n) && n.length) {
          t = t % n.length;
          let r = M(e) + t;
          for (; r < 0; )
            r += n.length;
          if (t)
            return W(r);
        }
        return e;
      }
      const le = (e, t) => {
        const {
          list: l
        } = o;
        if (l.length)
          return e % l.length === t % l.length;
      }, ne = (e) => {
        const t = c;
        if (f(e) && f(t.value)) {
          const l = G(t.value.children, (n) => n === e);
          return B(l);
        }
        return !1;
      }, se = (e) => e && typeof e == "object" && e.disabled, R = () => o.mode === P, j = (e, t = a.SELECTED) => {
        if (e = e || I.value, f(e) && f(c.value)) {
          const {
            children: l
          } = c.value, n = new RegExp(`\\s*${t}\\s*`, "g");
          Ce(l, (s) => {
            s.className = s.className && s.className.replace(n, " "), J.test(s.className) && (s.className = "");
          }), e.className && !J.test(e.className) ? e.className += ` ${t}` : e.className = t;
        }
      }, M = (e) => G(c.value.children, function(t) {
        return t == e;
      }), W = (e) => e > -1 ? K(c.value.children, (l, n) => (n === e && l.scrollTop, n === e)) : K(c.value.children, (l) => !ne(l)), oe = (e, t) => {
        t = typeof t == "number" ? t : w.DEFAULT_SCROLL_DURATION, e = e ?? o.selectedIndex, k(I.value, t);
      }, k = (e, t) => {
        const l = i.value.offsetHeight, n = re(e), s = (e.offsetTop || c.value.children.length * n / 2) - (l - n) / 2;
        z(s, t);
      }, z = (e, t = w.DEFAULT_SCROLL_DURATION) => {
        if (t && o.motion)
          if (v && v.destroy(), i.value.scrollTop === e) {
            if (R()) {
              const l = u.getNearestNodeInfo(c.value, g.value);
              j(l.nearestNode);
            }
          } else
            v = xe(i.value, e, t), v.on("rest", () => {
              if (R()) {
                const l = u.getNearestNodeInfo(c.value, g.value);
                j(l.nearestNode);
              }
            }), v.start();
        else
          i.value.scrollTop = e;
      }, ce = (e) => {
        const {
          nearestNode: t
        } = u.getNearestNodeInfo(c.value, g.value);
        o.cycled && $(e, t), C(e, t);
      }, ae = (e) => {
        e && e.stopImmediatePropagation && e.stopImmediatePropagation();
        const {
          targetNode: t,
          infoInList: l
        } = u.getTargetNode(e, c.value);
        t && l && !l.disabled && C(null, t);
      }, re = (e) => e && e.offsetHeight || w.DEFAULT_ITEM_HEIGHT, x = (e = "") => {
        const {
          selectedIndex: t,
          mode: l,
          transform: n
        } = o;
        return o.list.map((s, r) => {
          const {
            transform: E
          } = s, F = typeof E == "function" ? E : n, y = t === r, X = m({
            [`${a.PREFIX}-item-sel`]: y && l !== P,
            [`${a.PREFIX}-item-disabled`]: !!s.disabled
          });
          let h = "";
          y && typeof F == "function" ? h = F(s.value, s.text) : h = s.text == null ? s.value : s.text;
          const L = {};
          return !R() && !s.disabled && (L.onClick = () => u.selectIndex(r, c.value)), // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
          d("li", Ne({
            key: e + r
          }, L, {
            class: X,
            role: "option",
            "aria-selected": y,
            "aria-disabled": s.disabled
          }), [h]);
        });
      }, ie = () => {
        const {
          className: e,
          style: t
        } = o, l = x(), n = m(`${a.PREFIX}-item`, e);
        return d("div", {
          style: t,
          class: n,
          ref: H
        }, [d("ul", {
          role: "listbox",
          "aria-multiselectable": !1,
          "aria-label": o["aria-label"],
          ref: U
        }, [l])]);
      }, ue = () => {
        const {
          cycled: e,
          className: t,
          style: l
        } = o, {
          prependCount: n,
          appendCount: s
        } = p, r = V(n).reduce((b, O) => {
          const _ = x(`pre_${O}_`);
          return b.unshift(..._), b;
        }, []), E = V(s).reduce((b, O) => {
          const _ = x(`app_${O}_`);
          return b.push(..._), b;
        }, []), F = x(), y = m(`${a.PREFIX}-list-outer`, {
          [`${a.PREFIX}-list-outer-nocycle`]: !e
        }), X = m(`${a.PREFIX}-item-wheel`, t), h = m(`${a.PREFIX}-selector`), L = m(`${a.PREFIX}-shade`, `${a.PREFIX}-shade-pre`), de = m(`${a.PREFIX}-shade`, `${a.PREFIX}-shade-post`);
        return d("div", {
          class: X,
          style: l
        }, [d("div", {
          class: L
        }, null), d("div", {
          class: h,
          ref: ee
        }, null), d("div", {
          class: de
        }, null), d("div", {
          class: y,
          ref: H,
          onScroll: ce
        }, [d("ul", {
          role: "listbox",
          "aria-label": o["aria-label"],
          "aria-multiselectable": !1,
          ref: U,
          onClick: ae
        }, [r, F, E])])]);
      };
      return () => R() ? ue() : ie();
    }
  });
}
const _e = Ee();
export {
  _e as default,
  Ee as scrollItemFunc
};
//# sourceMappingURL=scrollItem.js.map
