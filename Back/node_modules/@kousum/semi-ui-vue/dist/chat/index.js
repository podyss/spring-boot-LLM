import { defineComponent as te, useSlots as ne, ref as k, reactive as oe, watch as A, onMounted as ae, onUnmounted as se, nextTick as le, createVNode as s } from "vue";
import I from "classnames";
import * as t from "../PropTypes";
import { vuePropsMake as re } from "../PropTypes";
import ie from "./inputBox";
import '@douyinfe/semi-foundation/lib/es/chat/chat.css';
import ce from "./hint";
import { IconChevronDown as ue, IconDisc as de } from "@kousum/semi-icons-vue";
import he from "./chatContent";
import { cssClasses as fe, strings as ge } from '@douyinfe/semi-foundation/lib/es/chat/constants';
import pe from '@douyinfe/semi-foundation/lib/es/chat/foundation';
import { LocaleConsumerFunc as Ce } from "../locale/localeConsumer";
import T from "../button";
import { useBaseComponent as me } from "../_base/baseComponent";
const G = Ce(), i = fe.PREFIX, {
  CHAT_ALIGN: ye,
  MODE: Se,
  SEND_HOT_KEY: be,
  MESSAGE_STATUS: P
} = ge, ve = {
  role: String,
  className: t.string,
  style: t.object,
  roleConfig: t.object,
  chats: t.array,
  hints: t.array,
  renderHintBox: t.func,
  onChatsChange: t.func,
  align: t.string,
  chatBoxRenderConfig: t.object,
  customMarkDownComponents: t.object,
  onClear: t.func,
  onMessageDelete: t.func,
  onMessageReset: t.func,
  onMessageCopy: t.func,
  onMessageGoodFeedback: t.func,
  onMessageBadFeedback: t.func,
  onInputChange: t.func,
  inputContentConvert: t.func,
  onMessageSend: t.func,
  InputBoxStyle: t.object,
  onHintClick: t.func,
  onStopGenerator: t.func,
  inputBoxStyle: t.object,
  renderInputArea: t.func,
  sendHotKey: t.string,
  inputBoxCls: t.string,
  renderFullInputBox: t.func,
  placeholder: t.string,
  topSlot: t.node || t.array,
  bottomSlot: t.node || t.array,
  showStopGenerate: t.bool,
  showClearContext: t.bool,
  hintStyle: t.object,
  hintCls: t.string,
  uploadProps: t.object,
  uploadTipProps: t.object,
  mode: t.string,
  renderDivider: t.func
}, Me = {
  align: ye.LEFT_RIGHT,
  showStopGenerate: !1,
  mode: Se.BUBBLE,
  showClearContext: !1,
  sendHotKey: be.ENTER
}, Be = re(ve, Me), je = /* @__PURE__ */ te({
  props: {
    ...Be
  },
  name: "index",
  setup(a, {
    attrs: ke
  }) {
    ne();
    const y = k();
    let p;
    const H = k(), S = k(), b = k(), r = oe({
      backBottomVisible: !1,
      chats: [],
      cacheHints: [],
      wheelScroll: !1,
      uploadAreaVisible: !1
    }), {
      adapter: F
    } = me(a, r);
    function L() {
      return {
        ...F(),
        getContainerRef: () => y.value,
        setWheelScroll: (e) => {
          r.wheelScroll = e;
        },
        notifyChatsChange: (e) => {
          const {
            onChatsChange: n
          } = a;
          n && n(e);
        },
        notifyLikeMessage: (e) => {
          const {
            onMessageGoodFeedback: n
          } = a;
          n && n(e);
        },
        notifyDislikeMessage: (e) => {
          const {
            onMessageBadFeedback: n
          } = a;
          n && n(e);
        },
        notifyCopyMessage: (e) => {
          const {
            onMessageCopy: n
          } = a;
          n && n(e);
        },
        notifyClearContext: () => {
          const {
            onClear: e
          } = a;
          e && e();
        },
        notifyMessageSend: (e, n) => {
          const {
            onMessageSend: c
          } = a;
          c && c(e, n);
        },
        notifyInputChange: (e) => {
          const {
            onInputChange: n
          } = a;
          n && n(e);
        },
        setBackBottomVisible: (e) => {
          r.backBottomVisible !== e && (r.backBottomVisible = e);
        },
        registerWheelEvent: () => {
          C.unRegisterWheelEvent();
          const e = y.value;
          e && (p = (n) => {
            (b == null ? void 0 : b.value) === n.currentTarget && (C.setWheelScroll(!0), C.unRegisterWheelEvent());
          }, e.addEventListener("wheel", p));
        },
        unRegisterWheelEvent: () => {
          if (p) {
            const e = y.value;
            if (e)
              e.removeEventListener("wheel", p);
            else
              return;
            p = null;
          }
        },
        notifyStopGenerate: (e) => {
          const {
            onStopGenerator: n
          } = a;
          n && n(e);
        },
        notifyHintClick: (e) => {
          const {
            onHintClick: n
          } = a;
          n && n(e);
        },
        setUploadAreaVisible: (e) => {
          r.uploadAreaVisible = e;
        },
        manualUpload: (e) => {
          const n = H.value;
          n && n.insert(e);
        },
        getDropAreaElement: () => S == null ? void 0 : S.value
      };
    }
    const C = L(), o = new pe(C);
    function R(e, n) {
      const {
        chats: c,
        hints: l
      } = e, u = {};
      return c !== n.chats && (u.chats = c ?? []), l !== n.cacheHints && (u.cacheHints = l), Object.keys(u).length ? u : null;
    }
    A([() => a.chats, () => a.hints, () => r.chats, () => r.cacheHints], (e) => {
      const n = R({
        ...a
      }, {
        ...r
      });
      n && Object.keys(n).forEach((c) => {
        r[c] = n[c];
      });
    }, {
      immediate: !0
    }), ae(() => {
      o.init();
    }), se(() => {
      o.destroy();
    }), A([() => a.chats, () => a.hints, () => r.chats, () => r.cacheHints, () => r.wheelScroll], (e, n, c) => {
      const {
        chats: l,
        hints: u
      } = a, {
        chats: d,
        cacheHints: v
      } = {
        chats: n[2],
        cacheHints: n[3]
      }, {
        wheelScroll: x
      } = r;
      let f = !1;
      if (l !== d && Array.isArray(l) && Array.isArray(d)) {
        const m = l[l.length - 1], M = d[d.length - 1];
        l.length > d.length ? (d.length === 0 || m.id !== M.id) && (f = !0) : l.length === d.length && l.length && (m.status !== "complete" || m.status !== M.status) && (f = !0);
      }
      u !== v && u.length > v.length && (f = !0), !x && f && le(() => {
        o.scrollToBottomImmediately();
      });
    });
    function j(e) {
      b.value = e.target, o.containerScroll(e);
    }
    return () => {
      const {
        topSlot: e,
        bottomSlot: n,
        roleConfig: c,
        hints: l,
        onChatsChange: u,
        onMessageCopy: d,
        renderInputArea: v,
        chatBoxRenderConfig: x,
        align: f,
        renderHintBox: m,
        style: M,
        className: $,
        showStopGenerate: D,
        customMarkDownComponents: N,
        mode: O,
        showClearContext: V,
        placeholder: U,
        inputBoxCls: W,
        inputBoxStyle: _,
        hintStyle: K,
        hintCls: z,
        uploadProps: X,
        uploadTipProps: Y,
        sendHotKey: q,
        renderDivider: J
      } = a, {
        backBottomVisible: Q,
        chats: B,
        wheelScroll: Z,
        uploadAreaVisible: ee
      } = r;
      let w = !1;
      const h = B.length > 0 && B[B.length - 1];
      let E = !1;
      if (h && D) {
        const g = (h == null ? void 0 : h.status) && [P.LOADING, P.INCOMPLETE].includes(h == null ? void 0 : h.status);
        E = g, D && (w = g);
      }
      return s("div", {
        class: I(`${i}`, $),
        style: M,
        onDragover: o.handleDragOver
      }, [ee && s("div", {
        ref: S,
        class: `${i}-dropArea`,
        onDragover: o.handleContainerDragOver,
        onDrop: o.handleContainerDrop,
        onDragleave: o.handleContainerDragLeave
      }, [s("span", {
        class: `${i}-dropArea-text`
      }, [s(G, {
        componentName: "Chat"
      }, {
        default: (g) => g.dropAreaText
      })])]), s("div", {
        class: `${i}-inner`
      }, [e, s("div", {
        class: `${i}-content`
      }, [s("div", {
        "data-testid": "chat-container-scroll",
        class: I(`${i}-container`, {
          "semi-chat-container-scroll-hidden": !Z
        }),
        onScroll: j,
        ref: y
      }, [s(he, {
        align: f,
        mode: O,
        chats: B,
        roleConfig: c,
        customMarkDownComponents: N,
        onMessageDelete: o.deleteMessage,
        onChatsChange: u,
        onMessageBadFeedback: o.dislikeMessage,
        onMessageGoodFeedback: o.likeMessage,
        onMessageReset: o.resetMessage,
        onMessageCopy: d,
        chatBoxRenderConfig: x,
        renderDivider: J
      }, null), !!(l != null && l.length) && s(ce, {
        className: z,
        style: K,
        value: l,
        onHintClick: o.onHintClick,
        renderHintBox: m
      }, null)])]), Q && !w && s("span", {
        class: `${i}-action`
      }, [s(T, {
        class: `${i}-action-content ${i}-action-backBottom`,
        icon: s(ue, {
          size: "extra-large"
        }, null),
        type: "tertiary",
        onClick: o.scrollToBottomWithAnimation
      }, null)]), w && s("span", {
        class: `${i}-action`
      }, [s(T, {
        class: `${i}-action-content ${i}-action-stop`,
        icon: s(de, {
          size: "extra-large"
        }, null),
        type: "tertiary",
        onClick: o.stopGenerate
      }, {
        default: () => [s(G, {
          componentName: "Chat"
        }, {
          default: (g) => g.stop
        })]
      })]), s(ie, {
        showClearContext: V,
        uploadRef: H,
        manualUpload: C.manualUpload,
        style: _,
        class: W,
        placeholder: U,
        disableSend: E,
        onClearContext: o.clearContext,
        onSend: o.onMessageSend,
        onInputChange: o.onInputChange,
        renderInputArea: v,
        uploadProps: X,
        uploadTipProps: Y,
        sendHotKey: q
      }, null), n])]);
    };
  }
});
export {
  ve as chatPropTypes,
  je as default
};
//# sourceMappingURL=index.js.map
