import { defineComponent as h, useSlots as f, createVNode as o } from "vue";
import B from "classnames";
import x from "./chatBoxAvatar";
import v from "./chatBoxTitle";
import M from "./chatBoxContent";
import R from "./chatBoxAction";
import { cssClasses as F, strings as k } from '@douyinfe/semi-foundation/lib/es/chat/constants';
import { useMemo as t } from "../../_utils/useMemo";
import { chatBoxPropTypes as A } from "./chatPropsType";
import { vuePropsMake as T } from "../../PropTypes";
const {
  PREFIX_CHAT_BOX: l
} = F, {
  ROLE: b,
  CHAT_ALIGN: N
} = k, y = T(A, {
  chatBoxRenderConfig: {}
}), ne = /* @__PURE__ */ h({
  props: {
    ...y
  },
  name: "index",
  setup(e, {
    attrs: D
  }) {
    f();
    const r = t(() => {
      var n, s;
      return ((n = e.message) == null ? void 0 : n.role) === ((s = e.previousMessage) == null ? void 0 : s.role);
    }, [() => e.message.role, () => e.previousMessage]), a = t(() => {
      let n = {};
      return e.roleConfig && (n = e.roleConfig[e.message.role] ?? {}), n;
    }, [() => e.message.role, () => e.roleConfig]), g = t(() => o(x, {
      continueSend: r.value,
      role: a.value,
      message: e.message,
      customRenderFunc: e.chatBoxRenderConfig.renderChatBoxAvatar
    }, null), [a, () => e.message, () => e.chatBoxRenderConfig.renderChatBoxAvatar]), c = t(() => o(v, {
      role: a.value,
      message: e.message,
      customRenderFunc: e.chatBoxRenderConfig.renderChatBoxTitle
    }, null), [a, () => e.message, () => e.message, () => e.chatBoxRenderConfig.renderChatBoxTitle]), d = t(() => o(M, {
      mode: e.mode,
      role: a.value,
      message: e.message,
      customMarkDownComponents: e.customMarkDownComponents,
      customRenderFunc: e.chatBoxRenderConfig.renderChatBoxContent
    }, null), [() => e.message, a, () => e.chatBoxRenderConfig.renderChatBoxContent]), C = t(() => o(R, {
      toast: e.toast,
      role: a.value,
      message: e.message,
      lastChat: e.lastChat,
      onMessageBadFeedback: e.onMessageBadFeedback,
      onMessageCopy: e.onMessageCopy,
      onChatsChange: e.onChatsChange,
      onMessageDelete: e.onMessageDelete,
      onMessageGoodFeedback: e.onMessageGoodFeedback,
      onMessageReset: e.onMessageReset,
      customRenderFunc: e.chatBoxRenderConfig.renderChatBoxAction
    }, null), [() => e.message, a, () => e.lastChat, () => e.onMessageBadFeedback, () => e.onMessageGoodFeedback, () => e.onMessageCopy, () => e.onChatsChange, () => e.onMessageDelete, () => e.onMessageReset, () => e.chatBoxRenderConfig.renderChatBoxAction]), i = t(() => B(l, {
      [`${l}-right`]: e.message.role === b.USER && e.align === N.LEFT_RIGHT
    }), [() => e.message.role, () => e.align]);
    return () => {
      const {
        message: n,
        lastChat: s,
        align: G,
        toast: w,
        mode: E,
        roleConfig: P,
        onMessageBadFeedback: S,
        onMessageGoodFeedback: _,
        onMessageCopy: H,
        onChatsChange: I,
        onMessageDelete: L,
        onMessageReset: O,
        chatBoxRenderConfig: u = {},
        customMarkDownComponents: X,
        previousMessage: $
      } = e, {
        renderChatBoxAvatar: U,
        renderChatBoxAction: V,
        renderChatBoxContent: j,
        renderChatBoxTitle: q,
        renderFullChatBox: m
      } = u;
      return typeof m != "function" ? o("div", {
        class: i.value
      }, [g.value, o("div", {
        class: `${l}-wrap`
      }, [!r.value && c.value, d.value, C.value])]) : m({
        message: n,
        role: a,
        defaultNodes: {
          avatar: g.value,
          title: c.value,
          content: d.value,
          action: C.value
        },
        className: i.value
      });
    };
  }
});
export {
  ne as default
};
//# sourceMappingURL=index.js.map
