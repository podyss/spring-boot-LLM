import { defineComponent as G, ref as J, reactive as Q, watch as b, onMounted as W, createVNode as d, mergeProps as V } from "vue";
import * as a from "../PropTypes";
import { vuePropsMake as Y } from "../PropTypes";
import C from "classnames";
import Z from '@douyinfe/semi-foundation/lib/es/input/textareaFoundation';
import { cssClasses as ee } from '@douyinfe/semi-foundation/lib/es/input/constants';
import { useHasInProps as te, useBaseComponent as ne } from "../_base/baseComponent";
import '@douyinfe/semi-foundation/lib/es/input/textarea.css';
import { throttle as ae, isUndefined as oe, omit as le, isFunction as L, noop as o } from "lodash";
import { IconClear as re } from "@kousum/semi-icons-vue";
import ue from "../resizeObserver";
const r = ee.PREFIX, se = {
  autosize: [a.bool, a.object],
  borderless: a.bool,
  placeholder: a.string,
  value: a.string,
  rows: a.number,
  cols: a.number,
  maxCount: a.number,
  onEnterPress: a.func,
  validateStatus: a.string,
  className: a.string,
  style: a.object,
  showClear: a.bool,
  onClear: a.func,
  onResize: a.func,
  getValueLength: a.func,
  disabledEnterStartNewLine: a.bool,
  // TODO
  // resize: PropTypes.bool,
  class: {
    type: String,
    default: ""
  },
  defaultValue: {
    type: [String, Boolean, Object, Array, void 0],
    // @ts-ignore
    default: void 0
  },
  disabled: Boolean,
  readonly: Boolean,
  autoFocus: Boolean,
  showCounter: {
    type: Boolean,
    default: !1
  },
  minlength: Number,
  maxlength: Number,
  "onUpdate:value": Function,
  onChange: {
    type: Function,
    default: o
  },
  onBlur: {
    type: Function,
    default: o
  },
  onFocus: {
    type: Function,
    default: o
  },
  onInput: {
    type: Function,
    default: o
  },
  onKeyDown: {
    type: Function,
    default: o
  },
  onKeyUp: {
    type: Function,
    default: o
  },
  onKeyPress: {
    type: Function,
    default: o
  },
  onPressEnter: {
    type: Function,
    default: o
  },
  onPaste: {
    type: Function,
    default: o
  },
  forwardRef: {
    type: [Function, Object],
    default: o
  }
}, ie = {
  autosize: !1,
  borderless: !1,
  rows: 4,
  cols: 20,
  showCounter: !1,
  showClear: !1,
  onEnterPress: o,
  onChange: o,
  onBlur: o,
  onFocus: o,
  onKeyDown: o,
  onResize: o,
  onClear: o
  // resize: false,
}, ce = Y(se, ie), Be = /* @__PURE__ */ G({
  props: {
    ...ce
  },
  name: "TextArea",
  setup(t, {
    slots: de,
    attrs: x
  }) {
    const {
      getProps: z
    } = te();
    let F = J(null);
    const p = t["onUpdate:value"], E = "value" in z(t) ? t.value : t.defaultValue, s = Q({
      value: E,
      isFocus: !1,
      maxlength: 0,
      isHover: !1,
      height: 0,
      minlength: t.minlength,
      cachedValue: t.value
    }), {
      adapter: R
    } = ne(t, s), S = K();
    b(() => s.value, () => {
      t.autosize && i.resizeTextarea();
    });
    function K() {
      return {
        ...R(),
        setValue: (e) => {
          p && p(e), s.value = e;
        },
        getRef: () => F.value,
        toggleFocusing: (e) => s.isFocus = e,
        toggleHovering: (e) => s.isHover = e,
        notifyChange: (e, n) => {
          t.onChange(e, n);
        },
        notifyClear: (e) => t.onClear(e),
        notifyBlur: (e, n) => t.onBlur(n),
        notifyFocus: (e, n) => t.onFocus(n),
        notifyKeyDown: (e) => {
          t.onKeyDown(e);
        },
        notifyHeightUpdate: (e) => {
          s.height = e, t.onResize({
            height: e
          });
        },
        notifyPressEnter: (e) => {
          t.onEnterPress && t.onEnterPress(e);
        },
        setMinLength: (e) => s.minlength = e
      };
    }
    function M(e, n) {
      const l = {};
      return e.value !== n.cachedValue && (l.value = e.value, l.cachedValue = e.value), l;
    }
    b(() => t.value, (e) => {
      const n = M({
        ...t
      }, {
        ...s
      });
      n && Object.keys(n).forEach((l) => {
        s[l] = n[l];
      });
    }, {
      immediate: !0
    }), W(() => {
      var e;
      c && ((e = c == null ? void 0 : c.cancel) == null || e.call(c), c = null);
    }), b([() => t.value, () => t.autosize, () => t.placeholder], (e, [n, l, h]) => {
      (t.value !== n || t.placeholder !== h) && t.autosize && i.resizeTextarea();
    });
    const j = (e) => {
      i.handleClear(e);
    };
    function A() {
      const {
        showClear: e
      } = t, n = i.isAllowClear(), l = C(`${r}-clearbtn`, {
        [`${r}-clearbtn-hidden`]: !n
      });
      return e ? d("div", {
        class: l,
        onClick: j
      }, [d(re, null, null)]) : null;
    }
    function I() {
      let e, n, l, h;
      const {
        showCounter: m,
        maxCount: f,
        getValueLength: g
      } = t;
      if (m || f) {
        const {
          value: y
        } = s;
        n = y ? L(g) ? g(y) : y.length : 0, l = f || null, h = C(`${r}-textarea-counter`, {
          [`${r}-textarea-counter-exceed`]: n > l
        }), e = d("div", {
          class: h
        }, [n, l ? "/" : null, l]);
      } else
        e = null;
      return e;
    }
    const P = (e) => {
      F.value = e;
      const {
        forwardRef: n
      } = t;
      typeof n == "function" ? n(e) : n && typeof n == "object" && (n.value = e);
    };
    let i = new Z(S), c = ae(i.resizeTextarea, 10);
    return () => {
      const {
        autosize: e,
        placeholder: n,
        onEnterPress: l,
        onResize: h,
        // resize,
        disabled: m,
        readonly: f,
        class: g,
        showCounter: y,
        validateStatus: $,
        maxCount: fe,
        defaultValue: he,
        style: N,
        forwardRef: me,
        autoFocus: U,
        getValueLength: D,
        maxlength: T,
        minlength: ge,
        showClear: H,
        borderless: O,
        ..._
      } = t, {
        isFocus: k,
        value: w,
        minlength: B
      } = s, X = C(g, `${r}-textarea-wrapper`, {
        [`${r}-textarea-borderless`]: O,
        [`${r}-textarea-wrapper-disabled`]: m,
        [`${r}-textarea-wrapper-readonly`]: f,
        [`${r}-textarea-wrapper-${$}`]: !!$,
        [`${r}-textarea-wrapper-focus`]: k
        // [`${prefixCls}-textarea-wrapper-resize`]: !autosize && resize,
      }), q = C(`${r}-textarea`, {
        [`${r}-textarea-disabled`]: m,
        [`${r}-textarea-readonly`]: f,
        [`${r}-textarea-autosize`]: typeof e != "boolean" ? oe(e == null ? void 0 : e.maxRows) : e,
        [`${r}-textarea-showClear`]: H
      }), v = {
        ...x,
        ...le(_, "insetLabel", "insetLabelId", "getValueLength", "onClear", "showClear", "disabledEnterStartNewLine"),
        class: q,
        disabled: m,
        autofocus: U || x.autofocus,
        readonly: f,
        placeholder: n || null,
        onInput: (u) => {
          i.handleChange(u.target.value, u);
        },
        onChange: (u) => {
        },
        onFocus: (u) => i.handleFocus(u),
        onBlur: (u) => i.handleBlur(u),
        onKeydown: (u) => {
          i.handleKeyDown(u);
        },
        value: w ?? ""
      };
      return L(D) || (v.maxLength = T), B && (v.minLength = B), d("div", {
        class: X,
        style: N,
        onMouseenter: (u) => i.handleMouseEnter(u),
        onMouseleave: (u) => i.handleMouseLeave(u)
      }, [e ? d(ue, {
        onResize: c
      }, {
        default: () => [d("textarea", V(v, {
          "data-testid": "test_base_textarea",
          ref: P
        }), null)]
      }) : d("textarea", V(v, {
        "data-testid": "test_base_textarea",
        ref: P
      }), null), A(), I()]);
    };
  }
});
export {
  Be as default,
  ce as vuePropsType
};
//# sourceMappingURL=textArea.js.map
