import { defineComponent as xe, reactive as $e, ref as I, watch as j, onMounted as Pe, createVNode as d, mergeProps as Se } from "vue";
import h from "classnames";
import * as n from "../PropTypes";
import { vuePropsMake as Ie } from "../PropTypes";
import Me from '@douyinfe/semi-foundation/lib/es/input/foundation';
import { cssClasses as Fe, strings as M } from '@douyinfe/semi-foundation/lib/es/input/constants';
import { isSemiIcon as y, styleNum as Be } from "../_utils";
import { useHasInProps as Ke, useBaseComponent as _e } from "../_base/baseComponent";
import '@douyinfe/semi-foundation/lib/es/input/input.css';
import { isFunction as Ee, noop as p, isString as C, isUndefined as De } from "lodash";
import { IconClear as Le, IconEyeClosedSolid as Ve, IconEyeOpened as Ae } from "@kousum/semi-icons-vue";
const l = Fe.PREFIX;
M.SIZE;
M.STATUS;
M.MODE;
const ke = {
  role: n.string,
  "aria-label": n.string,
  "aria-labelledby": n.string,
  "aria-invalid": [n.bool, n.string],
  "aria-errormessage": n.string,
  "aria-describedby": n.string,
  "aria-required": n.bool,
  addonBefore: n.node,
  addonAfter: n.node,
  clearIcon: n.node,
  prefix: n.node,
  suffix: n.node,
  mode: String,
  value: n.any,
  defaultValue: n.any,
  disabled: n.bool,
  readonly: n.bool,
  autoFocus: n.bool,
  type: n.string,
  showClear: n.bool,
  hideSuffix: n.bool,
  placeholder: n.any,
  size: String,
  className: n.string,
  style: n.object,
  validateStatus: String,
  onClear: n.func,
  onChange: n.func,
  onBlur: n.func,
  onFocus: n.func,
  onPaste: n.func,
  onInput: n.func,
  onKeyDown: n.func,
  onKeyUp: n.func,
  onKeyPress: n.func,
  onEnterPress: n.func,
  insetLabel: n.node,
  insetLabelId: n.string,
  inputStyle: n.object,
  getValueLength: n.func,
  preventScroll: n.bool,
  borderless: n.bool,
  onlyBorder: n.number,
  minlength: Number,
  maxlength: Number,
  forwardRef: [n.object, n.func],
  showClearIgnoreDisabled: n.bool,
  onCompositionstart: n.func,
  onCompositionend: n.func
}, Ue = {
  addonBefore: "",
  addonAfter: "",
  prefix: "",
  suffix: "",
  readonly: !1,
  type: "text",
  showClear: !1,
  hideSuffix: !1,
  placeholder: "",
  size: "default",
  className: "",
  onClear: p,
  onChange: p,
  onBlur: p,
  onFocus: p,
  onPaste: p,
  onInput: p,
  onKeyDown: p,
  onKeyUp: p,
  onKeyPress: p,
  onEnterPress: p,
  validateStatus: "default",
  borderless: !1
}, je = Ie(ke, Ue), ln = /* @__PURE__ */ xe({
  props: {
    ...je
  },
  name: "Input",
  setup(t, {
    slots: Ne,
    attrs: F,
    expose: N
  }) {
    const {
      getProps: v
    } = Ke(), O = "value" in v(t) ? t.value : t.defaultValue, i = $e({
      value: O,
      cachedValue: t.value,
      // Cache current props.value value
      disabled: !1,
      props: {},
      paddingLeft: "",
      isFocus: !1,
      isHovering: !1,
      eyeClosed: t.mode === "password",
      minlength: t.minlength,
      maxlength: t.maxlength
    }), {
      adapter: T
    } = _e(t, i), H = R();
    function R() {
      return {
        ...T(),
        setValue: (e) => {
          i.value = e;
        },
        setEyeClosed: (e) => i.eyeClosed = e,
        toggleFocusing: (e) => {
          i.isFocus = e;
        },
        focusInput: () => {
          const {
            preventScroll: e
          } = t, o = c && c.value;
          o && o.focus({
            preventScroll: e
          });
        },
        toggleHovering: (e) => i.isHovering = e,
        getIfFocusing: () => i.isFocus,
        notifyChange: (e, o) => {
          t.onChange(e, o);
        },
        notifyBlur: (e, o) => t.onBlur(o),
        notifyFocus: (e, o) => t.onFocus(o),
        notifyInput: (e) => t.onInput(e),
        notifyKeyPress: (e) => t.onKeyPress(e),
        notifyKeyDown: (e) => t.onKeyDown(e),
        notifyKeyUp: (e) => t.onKeyUp(e),
        notifyEnterPress: (e) => t.onEnterPress(e),
        notifyClear: (e) => t.onClear(e),
        setMinLength: (e) => i.minlength,
        isEventTarget: (e) => e && e.target === e.currentTarget
      };
    }
    let c = I(null);
    I(null), I(null);
    let r = new Me(H);
    function W(e, o) {
      const a = {};
      return e.value !== o.cachedValue && (a.value = e.value, a.cachedValue = e.value), a;
    }
    j(() => t.value, (e) => {
      const o = W({
        ...v(t)
      }, {
        ...i
      });
      o && Object.keys(o).forEach((a) => {
        i[a] = o[a];
      });
    }, {
      immediate: !0
    }), j(() => t.mode, (e, o) => {
      e !== o && G(o);
    }), Pe(() => {
      r.init();
      const {
        disabled: e,
        autoFocus: o,
        preventScroll: a
      } = t;
      !e && (t.autoFocus || F.autofocus) && c.value.focus({
        preventScroll: a
      });
    });
    const z = (e) => {
      r.handleClear(e);
    }, q = (e) => {
      r.handleClick(e);
    }, X = (e) => {
      i.isHovering = !0;
    }, Z = (e) => {
      i.isHovering = !1;
    }, G = (e) => {
      r.handleModeChange(e);
    }, J = (e) => {
      r.handleClickEye(e);
    }, Q = (e) => {
      r.handleMouseDown(e);
    }, Y = (e) => {
      r.handleMouseUp(e);
    }, ee = (e) => {
      r.handleModeEnterPress(e);
    }, B = (e) => {
      r.handleClickPrefixOrSuffix(e);
    }, K = (e) => {
      r.handlePreventMouseDown(e);
    };
    function ne() {
      const {
        addonBefore: e
      } = t;
      if (e) {
        const o = h({
          [`${l}-prepend`]: !0,
          [`${l}-prepend-text`]: e && C(e),
          [`${l}-prepend-icon`]: y(e)
        });
        return d("div", {
          class: o,
          "x-semi-prop": "addonBefore"
        }, [e]);
      }
      return null;
    }
    function oe() {
      const {
        addonAfter: e
      } = t;
      if (e) {
        const o = h({
          [`${l}-append`]: !0,
          [`${l}-append-text`]: e && C(e),
          [`${l}-append-icon`]: y(e)
        });
        return d("div", {
          class: o,
          "x-semi-prop": "addonAfter"
        }, [e]);
      }
      return null;
    }
    function te() {
      const e = h(`${l}-clearbtn`), {
        clearIcon: o
      } = t;
      return r.isAllowClear() ? d("div", {
        class: e,
        onMousedown: z
      }, [o || d(Le, null, null)]) : null;
    }
    function le() {
      const {
        eyeClosed: e
      } = i, {
        mode: o,
        disabled: a
      } = t, u = h(`${l}-modebtn`), g = e ? d(Ve, null, null) : d(Ae, null, null), x = o === "password" && !a, $ = e ? "Show password" : "Hidden password";
      return x ? d("div", {
        role: "button",
        tabindex: 0,
        "aria-label": $,
        class: u,
        onClick: J,
        onMousedown: Q,
        onMouseup: Y,
        onKeypress: ee
      }, [g]) : null;
    }
    function re() {
      const {
        prefix: e,
        insetLabel: o,
        insetLabelId: a
      } = t, u = e || o;
      if (!u)
        return null;
      const g = h({
        [`${l}-prefix`]: !0,
        [`${l}-inset-label`]: o,
        [`${l}-prefix-text`]: u && C(u),
        [`${l}-prefix-icon`]: y(u)
      });
      return d("div", {
        class: g,
        onMousedown: K,
        onClick: B,
        id: a,
        "x-semi-prop": "prefix,insetLabel"
      }, [u]);
    }
    function ae(e) {
      const {
        suffix: o,
        hideSuffix: a
      } = t;
      if (!o)
        return null;
      const u = h({
        [`${l}-suffix`]: !0,
        [`${l}-suffix-text`]: o && C(o),
        [`${l}-suffix-icon`]: y(o),
        [`${l}-suffix-hidden`]: e && !!a
      });
      return d("div", {
        class: u,
        onMousedown: K,
        onClick: B,
        "x-semi-prop": "suffix"
      }, [o]);
    }
    function se() {
      const {
        forwardRef: e
      } = t;
      if (!De(e)) {
        if (typeof e == "function")
          return (o) => {
            e(o), c.value = o;
          };
        if (Object.prototype.toString.call(e) === "[object Object]")
          return c = e, e;
      }
      return c;
    }
    return N({
      focus: () => {
        c.value.focus();
      },
      blur: () => {
        c.value.blur();
      },
      getDom: () => c.value,
      get value() {
        var e;
        return (e = c.value) == null ? void 0 : e.value;
      }
    }), () => {
      const {
        addonAfter: e,
        addonBefore: o,
        autoFocus: a,
        className: u,
        disabled: g,
        placeholder: x,
        prefix: $,
        mode: _,
        insetLabel: ie,
        insetLabelId: Oe,
        validateStatus: P,
        type: E,
        readonly: D,
        size: m,
        suffix: L,
        style: V,
        showClear: ue,
        onEnterPress: Te,
        onClear: He,
        hideSuffix: de,
        inputStyle: ce,
        forwardRef: Re,
        maxlength: fe,
        getValueLength: pe,
        defaultValue: We,
        preventScroll: ze,
        borderless: he,
        showClearIgnoreDisabled: qe,
        onlyBorder: b,
        ...ge
      } = v(t), {
        value: S,
        isFocus: ye,
        minlength: A
      } = i, k = r.isAllowClear(), me = y(L), be = se(), f = `${l}-wrapper`, we = h(f, u, {
        [`${l}-wrapper__with-prefix`]: $ || ie,
        [`${l}-wrapper__with-suffix`]: L,
        [`${l}-wrapper__with-suffix-hidden`]: k && !!de,
        [`${l}-wrapper__with-suffix-icon`]: me,
        [`${l}-wrapper__with-append`]: o,
        [`${l}-wrapper__with-prepend`]: e,
        [`${l}-wrapper__with-append-only`]: o && !e,
        [`${l}-wrapper__with-prepend-only`]: !o && e,
        [`${f}-readonly`]: D,
        [`${f}-disabled`]: g,
        [`${f}-warning`]: P === "warning",
        [`${f}-error`]: P === "error",
        [`${f}-focus`]: ye,
        [`${f}-clearable`]: ue,
        [`${f}-modebtn`]: _ === "password",
        [`${f}-hidden`]: E === "hidden",
        [`${f}-${m}`]: m,
        [`${l}-borderless`]: he,
        [`${l}-only_border`]: b != null
      }), Ce = h(l, {
        [`${l}-${m}`]: m,
        [`${l}-disabled`]: g,
        [`${l}-sibling-clearbtn`]: r.isAllowClear(),
        [`${l}-sibling-modebtn`]: _ === "password"
      }), ve = S ?? "", w = {
        ...F,
        ...ge,
        style: {
          ...ce
        },
        autofocus: a,
        class: Ce,
        disabled: g,
        readonly: D,
        type: r.handleInputType(E),
        placeholder: x,
        onInput: (s) => {
          r.handleChange(s.target.value, s);
        },
        onChange: (s) => {
        },
        onFocus: (s) => r.handleFocus(s),
        onPaste: t.onPaste,
        onBlur: (s) => r.handleBlur(s),
        onKeyup: (s) => r.handleKeyUp(s),
        onKeydown: (s) => r.handleKeyDown(s),
        onKeypress: (s) => r.handleKeyPress(s),
        value: ve
      };
      Ee(pe) || (w.maxlength = fe), A && (w.minlength = A), P === "error" && (w["aria-invalid"] = "true");
      let U = {
        ...V
      };
      return b !== void 0 && (U = {
        borderWidth: Be(b),
        ...V
      }), // eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions
      d("div", {
        class: we,
        style: U,
        onMouseenter: (s) => X(),
        onMouseleave: (s) => Z(),
        onClick: (s) => q(s)
      }, [ne(), re(), d("input", Se(w, {
        ref: be
      }), null), te(), ae(k), le(), oe()]);
    };
  }
});
export {
  ln as Input,
  je as VuePropsType,
  ln as default,
  ke as propTypes
};
//# sourceMappingURL=index.js.map
