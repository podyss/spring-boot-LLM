import { defineComponent as $, reactive as b, onMounted as j, onUnmounted as R, provide as S, createVNode as v, mergeProps as C } from "vue";
import P from "classnames";
import { cssClasses as y } from '@douyinfe/semi-foundation/lib/es/grid/constants';
import '@douyinfe/semi-foundation/lib/es/grid/grid.css';
import { registerMediaQuery as A } from "../_utils/index";
const x = ["xxl", "xl", "lg", "md", "sm", "xs"], F = null, d = {
  xs: "(max-width: 575px)",
  sm: "(min-width: 576px)",
  md: "(min-width: 768px)",
  lg: "(min-width: 992px)",
  xl: "(min-width: 1200px)",
  xxl: "(min-width: 1600px)"
}, E = {
  type: String,
  align: String,
  justify: String,
  className: String,
  style: [String, Object],
  gutter: [Number, Array],
  prefixCls: {
    type: String,
    default: y.PREFIX
  }
}, I = /* @__PURE__ */ $({
  props: {
    ...E
  },
  name: "Row",
  setup(i, {
    slots: c
  }) {
    y.PREFIX;
    const a = b({
      screens: {
        xs: !0,
        sm: !0,
        md: !0,
        lg: !0,
        xl: !0,
        xxl: !0
      }
    });
    let p = [];
    j(() => {
      p = Object.keys(d).map((t) => A(d[t], {
        match: () => {
          typeof i.gutter == "object" && (a.screens[t] = !0);
        },
        unmatch: () => {
          typeof i.gutter == "object" && (a.screens[t] = !0);
        }
      }));
    }), R(() => {
      p.forEach((t) => t());
    });
    function f() {
      const {
        gutter: t = 0
      } = i, e = [0, 0];
      return (Array.isArray(t) ? t.slice(0, 2) : [t, 0]).forEach((r, u) => {
        if (typeof r == "object")
          for (let n = 0; n < x.length; n++) {
            const o = x[n];
            if (a.screens[o] && r[o] !== void 0) {
              e[u] = r[o];
              break;
            }
          }
        else
          e[u] = r || 0;
      }), e;
    }
    return S("gutters", f()), () => {
      const {
        prefixCls: t,
        type: e,
        justify: m,
        align: r,
        className: u,
        style: n,
        ...o
      } = i, s = f(), l = `${t}-row`, h = P({
        [l]: e !== "flex",
        [`${l}-${e}`]: e,
        [`${l}-${e}-${m}`]: e && m,
        [`${l}-${e}-${r}`]: e && r
      }, u), w = {
        ...s[0] > 0 ? {
          marginLeft: s[0] / -2,
          marginRight: s[0] / -2
        } : {},
        ...s[1] > 0 ? {
          marginTop: s[1] / -2,
          marginBottom: s[1] / -2
        } : {},
        ...n
      }, g = {
        ...o
      };
      return delete g.gutter, v("div", C(g, {
        class: h,
        style: w
      }), [c.default ? c.default() : null]);
    };
  }
});
export {
  F as RowContext,
  I as default,
  E as vuePropsType
};
//# sourceMappingURL=row.js.map
