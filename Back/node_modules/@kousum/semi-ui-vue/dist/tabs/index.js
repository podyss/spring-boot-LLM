import { defineComponent as S, useSlots as M, ref as ne, reactive as ae, watch as w, isVNode as m, createVNode as u, mergeProps as x } from "vue";
import D from "classnames";
import * as t from "../PropTypes";
import { vuePropsMake as oe } from "../PropTypes";
import { cssClasses as v } from '@douyinfe/semi-foundation/lib/es/tabs/constants';
import re from '@douyinfe/semi-foundation/lib/es/utils/isNullOrUndefined';
import ie from '@douyinfe/semi-foundation/lib/es/utils/getDataAttr';
import se from '@douyinfe/semi-foundation/lib/es/tabs/foundation';
import { pick as B, isEqual as I } from "lodash";
import '@douyinfe/semi-foundation/lib/es/tabs/tabs.css';
import N from "./TabBar";
import { default as Se } from "./TabPane";
import { default as xe } from "./TabItem";
import ce from "./tabs-context";
import { useBaseComponent as le, useHasInProps as be } from "../_base/baseComponent";
import { getFragmentChildren as ye } from "../_utils";
export * from "./interface";
const k = ["className", "style", "disabled", "itemKey", "tab", "icon"], fe = {
  activeKey: t.string,
  className: t.string,
  collapsible: t.bool,
  contentStyle: t.oneOfType([t.object]),
  defaultActiveKey: t.string,
  keepDOM: t.bool,
  lazyRender: t.bool,
  onChange: t.func,
  onTabClick: t.func,
  renderTabBar: t.func,
  showRestInDropdown: t.bool,
  size: t.string,
  style: t.object,
  tabBarClassName: t.string,
  tabBarExtraContent: t.node,
  tabBarStyle: t.object,
  tabList: t.array,
  tabPaneMotion: t.bool,
  tabPosition: t.string,
  type: t.string,
  onTabClose: t.func,
  preventScroll: t.bool,
  more: t.oneOfType([t.number, t.object]),
  arrowPosition: t.string,
  renderArrow: t.func,
  dropdownProps: t.object,
  onVisibleTabsChange: t.func,
  visibleTabsStyle: t.object
}, de = {
  // children: [],
  collapsible: !1,
  keepDOM: !0,
  lazyRender: !1,
  onChange: () => {
  },
  onTabClick: () => {
  },
  size: "large",
  tabPaneMotion: !0,
  tabPosition: "top",
  type: "line",
  onTabClose: () => {
  },
  showRestInDropdown: !0,
  arrowPosition: "both"
}, L = oe(fe, de), ue = /* @__PURE__ */ S({
  props: {
    ...L,
    children: Array
  },
  name: "TabsIndex",
  setup(a, {}) {
    M();
    const p = ne(), o = ae({
      activeKey: "",
      panes: K(),
      prevActiveKey: null,
      forceDisableMotion: !1
    }), {
      adapter: T
    } = le(a, o);
    function O() {
      return {
        ...T(),
        collectPane: () => {
          const e = K();
          o.panes = e;
        },
        collectActiveKey: () => {
          const {
            tabList: e,
            activeKey: n
          } = a;
          if (typeof n < "u")
            return;
          const {
            activeKey: r
          } = o, i = K();
          i.findIndex((s) => s.itemKey === r) === -1 && (i.length > 0 ? o.activeKey = i[0].itemKey : o.activeKey = "");
        },
        notifyTabClick: (e, n) => {
          a.onTabClick(e, n);
        },
        notifyChange: (e) => {
          a.onChange(e);
        },
        setNewActiveKey: (e) => {
          o.activeKey = e;
        },
        getDefaultActiveKeyFromChildren: () => {
          const {
            tabList: e
          } = a;
          let n = "";
          return (e || a.children.map((i) => m(i) ? i.props : null)).forEach((i) => {
            i && !n && !i.disabled && (n = i.itemKey);
          }), n;
        },
        notifyTabDelete: (e) => {
          a.onTabClose && a.onTabClose(e);
        }
      };
    }
    const j = O(), y = new se(j);
    o.activeKey = y.getDefaultActiveKey();
    function R(e) {
      const n = {};
      return !re(e.activeKey) && e.activeKey !== o.activeKey && (o.prevActiveKey = o.activeKey, n.activeKey = e.activeKey), n;
    }
    w([() => a.activeKey], () => {
      const e = R({
        ...a
      });
      e && Object.keys(e).forEach((n) => {
        o[n] = e[n];
      });
    }), w([() => a.children, () => a.tabList, () => a.activeKey, () => o.activeKey], (e, [n, r, i, s]) => {
      const l = (n || []).map((c) => B(m(c) ? c.props : null, k)), f = (a.children || []).map((c) => B(m(c) ? c.props : null, k)), C = a.tabList || r;
      if (I(a.tabList, r) || y.handleTabListChange(), s !== o.activeKey && s !== o.prevActiveKey && (o.prevActiveKey = s), i !== a.activeKey) {
        const c = (() => {
          const h = new Set(l.map((b) => b.itemKey));
          return f.map((b) => b.itemKey).filter((b) => !h.has(b));
        })();
        o.forceDisableMotion = c.includes(a.activeKey);
      }
      !I(l, f) && !C && y.handleTabPanesChange();
    });
    const E = (e) => {
      p.value = e;
    };
    function K() {
      const {
        tabList: e
      } = a;
      return Array.isArray(e) && e.length ? e : a.children.filter((n) => {
        var r;
        return typeof n.type != "symbol" && ((r = n.type) == null ? void 0 : r.name) === "TabPane";
      }).map((n) => {
        if (n) {
          const {
            tab: r,
            icon: i,
            disabled: s,
            itemKey: l,
            closable: f
          } = n.props;
          return {
            tab: r,
            icon: i,
            disabled: s,
            itemKey: l,
            closable: f
          };
        }
      });
    }
    const z = (e, n) => {
      y.handleTabClick(e, n);
    }, F = () => {
      const {
        activeKey: e
      } = o, {
        tabList: n
      } = a;
      return n || !Array.isArray(a.children) ? a.children : a.children.filter((r) => m(r) && r.type && r.type.isTabPane ? r.props.itemKey === e : !0);
    }, V = (e, n) => {
      n.stopPropagation(), y.handleTabDelete(e);
    };
    return () => {
      const {
        className: e,
        collapsible: n,
        contentStyle: r,
        keepDOM: i,
        lazyRender: s,
        renderTabBar: l,
        showRestInDropdown: f,
        size: C,
        style: c,
        tabBarClassName: h,
        tabBarExtraContent: b,
        tabBarStyle: $,
        tabPaneMotion: _,
        tabPosition: d,
        type: q,
        more: H,
        onVisibleTabsChange: U,
        visibleTabsStyle: W,
        arrowPosition: G,
        renderArrow: J,
        dropdownProps: Q,
        ...X
      } = a, {
        panes: P,
        activeKey: g
      } = o, Y = D(e, {
        [v.TABS]: !0,
        [`${v.TABS}-${d}`]: d
      }), Z = D({
        [v.TABS_CONTENT]: !0,
        [`${v.TABS_CONTENT}-${d}`]: d
      }), A = {
        activeKey: g,
        className: h,
        collapsible: n,
        list: P,
        onTabClick: z,
        showRestInDropdown: f,
        size: C,
        style: $,
        tabBarExtraContent: b,
        tabPosition: d,
        type: q,
        deleteTabItem: V,
        handleKeyDown: y.handleKeyDown,
        more: H,
        onVisibleTabsChange: U,
        visibleTabsStyle: W,
        arrowPosition: G,
        renderArrow: J,
        dropdownProps: Q
      }, ee = l ? l(A, N) : u(N, A, null), te = i ? a.children : F();
      return u("div", x({
        class: Y,
        style: c
      }, ie(X)), [ee, u(ce.Provider, {
        value: {
          activeKey: g,
          lazyRender: s,
          panes: P,
          tabPaneMotion: _,
          tabPosition: d,
          prevActiveKey: o.prevActiveKey,
          forceDisableMotion: o.forceDisableMotion
        }
      }, {
        default: () => [u("div", {
          ref: E,
          class: Z,
          style: {
            ...r
          }
        }, [te])]
      })]);
    };
  }
}), Ie = /* @__PURE__ */ S({
  props: {
    ...L
  },
  name: "Tabs",
  setup(a, {}) {
    const p = M(), {
      getProps: o
    } = be();
    return () => {
      const T = ye(p);
      return u(ue, x(o(a), {
        children: T
      }), null);
    };
  }
});
export {
  xe as TabItem,
  Se as TabPane,
  Ie as default,
  L as vuePropsType
};
//# sourceMappingURL=index.js.map
